// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "ads/common/offline_user_data.proto" (package "google.ads.googleads.v11.common", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserIdentifierSourceEnum_UserIdentifierSource } from "../enums/user_identifier_source";
// Proto file describing offline user data.

/**
 * Address identifier of offline data.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.OfflineUserAddressInfo
 */
export interface OfflineUserAddressInfo {
    /**
     * First name of the user, which is hashed as SHA-256 after normalized
     * (Lowercase all characters; Remove any extra spaces before, after, and in
     * between).
     *
     * @generated from protobuf field: optional string hashed_first_name = 7;
     */
    hashedFirstName?: string;
    /**
     * Last name of the user, which is hashed as SHA-256 after normalized (lower
     * case only and no punctuation).
     *
     * @generated from protobuf field: optional string hashed_last_name = 8;
     */
    hashedLastName?: string;
    /**
     * City of the address. Only accepted for Store Sales and
     * ConversionAdjustmentUploadService.
     *
     * @generated from protobuf field: optional string city = 9;
     */
    city?: string;
    /**
     * State code of the address. Only accepted for Store Sales and
     * ConversionAdjustmentUploadService.
     *
     * @generated from protobuf field: optional string state = 10;
     */
    state?: string;
    /**
     * 2-letter country code in ISO-3166-1 alpha-2 of the user's address.
     *
     * @generated from protobuf field: optional string country_code = 11;
     */
    countryCode?: string;
    /**
     * Postal code of the user's address.
     *
     * @generated from protobuf field: optional string postal_code = 12;
     */
    postalCode?: string;
    /**
     * The street address of the user hashed using SHA-256 hash function after
     * normalization (lower case only). Only accepted for
     * ConversionAdjustmentUploadService.
     *
     * @generated from protobuf field: optional string hashed_street_address = 13;
     */
    hashedStreetAddress?: string;
}
/**
 * User identifying information.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.UserIdentifier
 */
export interface UserIdentifier {
    /**
     * Source of the user identifier when the upload is from Store Sales,
     * ConversionUploadService, or ConversionAdjustmentUploadService.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.UserIdentifierSourceEnum.UserIdentifierSource user_identifier_source = 6;
     */
    userIdentifierSource: UserIdentifierSourceEnum_UserIdentifierSource;
    /**
     * @generated from protobuf oneof: identifier
     */
    identifier: {
        oneofKind: "hashedEmail";
        /**
         * Hashed email address using SHA-256 hash function after normalization.
         * Accepted for Customer Match, Store Sales, ConversionUploadService, and
         * ConversionAdjustmentUploadService.
         *
         * @generated from protobuf field: string hashed_email = 7;
         */
        hashedEmail: string;
    } | {
        oneofKind: "hashedPhoneNumber";
        /**
         * Hashed phone number using SHA-256 hash function after normalization
         * (E164 standard). Accepted for Customer Match, Store Sales,
         * ConversionUploadService, and ConversionAdjustmentUploadService.
         *
         * @generated from protobuf field: string hashed_phone_number = 8;
         */
        hashedPhoneNumber: string;
    } | {
        oneofKind: "mobileId";
        /**
         * Mobile device ID (advertising ID/IDFA). Accepted only for Customer Match.
         *
         * @generated from protobuf field: string mobile_id = 9;
         */
        mobileId: string;
    } | {
        oneofKind: "thirdPartyUserId";
        /**
         * Advertiser-assigned user ID for Customer Match upload, or
         * third-party-assigned user ID for Store Sales. Accepted only for Customer
         * Match and Store Sales.
         *
         * @generated from protobuf field: string third_party_user_id = 10;
         */
        thirdPartyUserId: string;
    } | {
        oneofKind: "addressInfo";
        /**
         * Address information. Accepted only for Customer Match, Store Sales, and
         * ConversionAdjustmentUploadService.
         *
         * @generated from protobuf field: google.ads.googleads.v11.common.OfflineUserAddressInfo address_info = 5;
         */
        addressInfo: OfflineUserAddressInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Attribute of the store sales transaction.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.TransactionAttribute
 */
export interface TransactionAttribute {
    /**
     * Timestamp when transaction occurred. Required.
     * The format is "YYYY-MM-DD HH:MM:SS[+/-HH:MM]", where [+/-HH:MM] is an
     * optional timezone offset from UTC. If the offset is absent, the API will
     * use the account's timezone as default.
     * Examples: "2018-03-05 09:15:00" or "2018-02-01 14:34:30+03:00"
     *
     * @generated from protobuf field: optional string transaction_date_time = 8;
     */
    transactionDateTime?: string;
    /**
     * Transaction amount in micros. Required.
     * Transaction amount in micros needs to be greater than 1000.
     * If item Attributes are provided, it represents the total value of the
     * items, after multiplying the unit price per item by the quantity provided
     * in the ItemAttributes.
     *
     * @generated from protobuf field: optional double transaction_amount_micros = 9;
     */
    transactionAmountMicros?: number;
    /**
     * Transaction currency code. ISO 4217 three-letter code is used. Required.
     *
     * @generated from protobuf field: optional string currency_code = 10;
     */
    currencyCode?: string;
    /**
     * The resource name of conversion action to report conversions to.
     * Required.
     *
     * @generated from protobuf field: optional string conversion_action = 11;
     */
    conversionAction?: string;
    /**
     * Transaction order id.
     * Accessible only to customers on the allow-list.
     *
     * @generated from protobuf field: optional string order_id = 12;
     */
    orderId?: string;
    /**
     * Store attributes of the transaction.
     * Accessible only to customers on the allow-list.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.StoreAttribute store_attribute = 6;
     */
    storeAttribute?: StoreAttribute;
    /**
     * Value of the custom variable for each transaction.
     * Accessible only to customers on the allow-list.
     *
     * @generated from protobuf field: optional string custom_value = 13;
     */
    customValue?: string;
    /**
     * Item attributes of the transaction.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.ItemAttribute item_attribute = 14;
     */
    itemAttribute?: ItemAttribute;
}
/**
 * Store attributes of the transaction.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.StoreAttribute
 */
export interface StoreAttribute {
    /**
     * Store code from
     * https://support.google.com/business/answer/3370250#storecode
     *
     * @generated from protobuf field: optional string store_code = 2;
     */
    storeCode?: string;
}
/**
 * Item attributes of the transaction.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.ItemAttribute
 */
export interface ItemAttribute {
    /**
     * A unique identifier of a product. It can be either the Merchant Center Item
     * ID or GTIN (Global Trade Item Number).
     *
     * @generated from protobuf field: string item_id = 1;
     */
    itemId: string;
    /**
     * ID of the Merchant Center Account.
     *
     * @generated from protobuf field: optional int64 merchant_id = 2;
     */
    merchantId?: bigint;
    /**
     * Common Locale Data Repository (CLDR) territory code of the country
     * associated with the feed where your items are uploaded. See
     * https://developers.google.com/google-ads/api/reference/data/codes-formats#country-codes
     * for more information.
     *
     * @generated from protobuf field: string country_code = 3;
     */
    countryCode: string;
    /**
     * ISO 639-1 code of the language associated with the feed where your items
     * are uploaded
     *
     * @generated from protobuf field: string language_code = 4;
     */
    languageCode: string;
    /**
     * The number of items sold. Defaults to 1 if not set.
     *
     * @generated from protobuf field: int64 quantity = 5;
     */
    quantity: bigint;
}
/**
 * User data holding user identifiers and attributes.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.UserData
 */
export interface UserData {
    /**
     * User identification info. Required.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.UserIdentifier user_identifiers = 1;
     */
    userIdentifiers: UserIdentifier[];
    /**
     * Additional transactions/attributes associated with the user.
     * Required when updating store sales data.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.TransactionAttribute transaction_attribute = 2;
     */
    transactionAttribute?: TransactionAttribute;
    /**
     * Additional attributes associated with the user. Required when updating
     * customer match attributes. These have an expiration of 540 days.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.UserAttribute user_attribute = 3;
     */
    userAttribute?: UserAttribute;
}
/**
 * User attribute, can only be used with CUSTOMER_MATCH_WITH_ATTRIBUTES job
 * type.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.UserAttribute
 */
export interface UserAttribute {
    /**
     * Advertiser defined lifetime value for the user.
     *
     * @generated from protobuf field: optional int64 lifetime_value_micros = 1;
     */
    lifetimeValueMicros?: bigint;
    /**
     * Advertiser defined lifetime value bucket for the user. The valid range for
     * a lifetime value bucket is from 1 (low) to 10 (high), except for remove
     * operation where 0 will also be accepted.
     *
     * @generated from protobuf field: optional int32 lifetime_value_bucket = 2;
     */
    lifetimeValueBucket?: number;
    /**
     * Timestamp of the last purchase made by the user.
     * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
     * optional timezone offset from UTC. If the offset is absent, the API will
     * use the account's timezone as default.
     *
     * @generated from protobuf field: string last_purchase_date_time = 3;
     */
    lastPurchaseDateTime: string;
    /**
     * Advertiser defined average number of purchases that are made by the user in
     * a 30 day period.
     *
     * @generated from protobuf field: int32 average_purchase_count = 4;
     */
    averagePurchaseCount: number;
    /**
     * Advertiser defined average purchase value in micros for the user.
     *
     * @generated from protobuf field: int64 average_purchase_value_micros = 5;
     */
    averagePurchaseValueMicros: bigint;
    /**
     * Timestamp when the user was acquired.
     * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
     * optional timezone offset from UTC. If the offset is absent, the API will
     * use the account's timezone as default.
     *
     * @generated from protobuf field: string acquisition_date_time = 6;
     */
    acquisitionDateTime: string;
    /**
     * The shopping loyalty related data. Shopping utilizes this data to provide
     * users with a better experience. Accessible only to merchants on the
     * allow-list with the user's consent.
     *
     * @generated from protobuf field: optional google.ads.googleads.v11.common.ShoppingLoyalty shopping_loyalty = 7;
     */
    shoppingLoyalty?: ShoppingLoyalty;
    /**
     * Optional. Advertiser defined lifecycle stage for the user. The accepted values are
     * “Lead”, “Active” and “Churned”.
     *
     * @generated from protobuf field: string lifecycle_stage = 8;
     */
    lifecycleStage: string;
    /**
     * Optional. Timestamp of the first purchase made by the user.
     * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
     * optional timezone offset from UTC. If the offset is absent, the API will
     * use the account's timezone as default.
     *
     * @generated from protobuf field: string first_purchase_date_time = 9;
     */
    firstPurchaseDateTime: string;
    /**
     * Optional. Advertiser defined events and their attributes. All the values in the
     * nested fields are required. Currently this field is in beta.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.EventAttribute event_attribute = 10;
     */
    eventAttribute: EventAttribute[];
}
/**
 * Advertiser defined events and their attributes. All the values in the
 * nested fields are required.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.EventAttribute
 */
export interface EventAttribute {
    /**
     * Required. Advertiser defined event to be used for remarketing. The accepted values
     * are “Viewed”, “Cart”, “Purchased” and “Recommended”.
     *
     * @generated from protobuf field: string event = 1;
     */
    event: string;
    /**
     * Required. Timestamp at which the event happened.
     * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
     * optional timezone offset from UTC. If the offset is absent, the API will
     * use the account's timezone as default.
     *
     * @generated from protobuf field: string event_date_time = 2;
     */
    eventDateTime: string;
    /**
     * Required. Item attributes of the event.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.EventItemAttribute item_attribute = 3;
     */
    itemAttribute: EventItemAttribute[];
}
/**
 * Event Item attributes of the Customer Match.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.EventItemAttribute
 */
export interface EventItemAttribute {
    /**
     * Optional. A unique identifier of a product. It can be either the Merchant Center Item
     * ID or GTIN (Global Trade Item Number).
     *
     * @generated from protobuf field: string item_id = 1;
     */
    itemId: string;
}
/**
 * The shopping loyalty related data. Shopping utilizes this data to provide
 * users with a better experience.
 * Accessible only to merchants on the allow-list.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.ShoppingLoyalty
 */
export interface ShoppingLoyalty {
    /**
     * The membership tier. It is a free-form string as each merchant may have
     * their own loyalty system. For example, it could be a number from 1 to 10,
     * or a string such as "Golden" or "Silver", or even empty string "".
     *
     * @generated from protobuf field: optional string loyalty_tier = 1;
     */
    loyaltyTier?: string;
}
/**
 * Metadata for customer match user list.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.CustomerMatchUserListMetadata
 */
export interface CustomerMatchUserListMetadata {
    /**
     * The resource name of remarketing list to update data.
     * Required for job of CUSTOMER_MATCH_USER_LIST type.
     *
     * @generated from protobuf field: optional string user_list = 2;
     */
    userList?: string;
}
/**
 * Metadata for Store Sales Direct.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.StoreSalesMetadata
 */
export interface StoreSalesMetadata {
    /**
     * This is the fraction of all transactions that are identifiable (for
     * example, associated with any form of customer information). Required. The
     * fraction needs to be between 0 and 1 (excluding 0).
     *
     * @generated from protobuf field: optional double loyalty_fraction = 5;
     */
    loyaltyFraction?: number;
    /**
     * This is the ratio of sales being uploaded compared to the overall sales
     * that can be associated with a customer. Required.
     * The fraction needs to be between 0 and 1 (excluding 0). For example, if you
     * upload half the sales that you are able to associate with a customer, this
     * would be 0.5.
     *
     * @generated from protobuf field: optional double transaction_upload_fraction = 6;
     */
    transactionUploadFraction?: number;
    /**
     * Name of the store sales custom variable key. A predefined key that
     * can be applied to the transaction and then later used for custom
     * segmentation in reporting.
     * Accessible only to customers on the allow-list.
     *
     * @generated from protobuf field: optional string custom_key = 7;
     */
    customKey?: string;
    /**
     * Metadata for a third party Store Sales upload.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.StoreSalesThirdPartyMetadata third_party_metadata = 3;
     */
    thirdPartyMetadata?: StoreSalesThirdPartyMetadata;
}
/**
 * Metadata for a third party Store Sales.
 * This product is only for customers on the allow-list. Contact your
 * Google business development representative for details on the upload
 * configuration.
 *
 * @generated from protobuf message google.ads.googleads.v11.common.StoreSalesThirdPartyMetadata
 */
export interface StoreSalesThirdPartyMetadata {
    /**
     * Time the advertiser uploaded the data to the partner. Required.
     * The format is "YYYY-MM-DD HH:MM:SS".
     * Examples: "2018-03-05 09:15:00" or "2018-02-01 14:34:30"
     *
     * @generated from protobuf field: optional string advertiser_upload_date_time = 7;
     */
    advertiserUploadDateTime?: string;
    /**
     * The fraction of transactions that are valid. Invalid transactions may
     * include invalid formats or values.
     * Required.
     * The fraction needs to be between 0 and 1 (excluding 0).
     *
     * @generated from protobuf field: optional double valid_transaction_fraction = 8;
     */
    validTransactionFraction?: number;
    /**
     * The fraction of valid transactions that are matched to a third party
     * assigned user ID on the partner side.
     * Required.
     * The fraction needs to be between 0 and 1 (excluding 0).
     *
     * @generated from protobuf field: optional double partner_match_fraction = 9;
     */
    partnerMatchFraction?: number;
    /**
     * The fraction of valid transactions that are uploaded by the partner to
     * Google.
     * Required.
     * The fraction needs to be between 0 and 1 (excluding 0).
     *
     * @generated from protobuf field: optional double partner_upload_fraction = 10;
     */
    partnerUploadFraction?: number;
    /**
     * Version of partner IDs to be used for uploads. Required.
     *
     * @generated from protobuf field: optional string bridge_map_version_id = 11;
     */
    bridgeMapVersionId?: string;
    /**
     * ID of the third party partner updating the transaction feed.
     *
     * @generated from protobuf field: optional int64 partner_id = 12;
     */
    partnerId?: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class OfflineUserAddressInfo$Type extends MessageType<OfflineUserAddressInfo> {
    constructor() {
        super("google.ads.googleads.v11.common.OfflineUserAddressInfo", [
            { no: 7, name: "hashed_first_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "hashed_last_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "city", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "postal_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "hashed_street_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OfflineUserAddressInfo>): OfflineUserAddressInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OfflineUserAddressInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfflineUserAddressInfo): OfflineUserAddressInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string hashed_first_name */ 7:
                    message.hashedFirstName = reader.string();
                    break;
                case /* optional string hashed_last_name */ 8:
                    message.hashedLastName = reader.string();
                    break;
                case /* optional string city */ 9:
                    message.city = reader.string();
                    break;
                case /* optional string state */ 10:
                    message.state = reader.string();
                    break;
                case /* optional string country_code */ 11:
                    message.countryCode = reader.string();
                    break;
                case /* optional string postal_code */ 12:
                    message.postalCode = reader.string();
                    break;
                case /* optional string hashed_street_address */ 13:
                    message.hashedStreetAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfflineUserAddressInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string hashed_first_name = 7; */
        if (message.hashedFirstName !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.hashedFirstName);
        /* optional string hashed_last_name = 8; */
        if (message.hashedLastName !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.hashedLastName);
        /* optional string city = 9; */
        if (message.city !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.city);
        /* optional string state = 10; */
        if (message.state !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.state);
        /* optional string country_code = 11; */
        if (message.countryCode !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.countryCode);
        /* optional string postal_code = 12; */
        if (message.postalCode !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.postalCode);
        /* optional string hashed_street_address = 13; */
        if (message.hashedStreetAddress !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.hashedStreetAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.OfflineUserAddressInfo
 */
export const OfflineUserAddressInfo = new OfflineUserAddressInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserIdentifier$Type extends MessageType<UserIdentifier> {
    constructor() {
        super("google.ads.googleads.v11.common.UserIdentifier", [
            { no: 6, name: "user_identifier_source", kind: "enum", T: () => ["google.ads.googleads.v11.enums.UserIdentifierSourceEnum.UserIdentifierSource", UserIdentifierSourceEnum_UserIdentifierSource] },
            { no: 7, name: "hashed_email", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "hashed_phone_number", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "mobile_id", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "third_party_user_id", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "address_info", kind: "message", oneof: "identifier", T: () => OfflineUserAddressInfo }
        ]);
    }
    create(value?: PartialMessage<UserIdentifier>): UserIdentifier {
        const message = { userIdentifierSource: 0, identifier: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserIdentifier): UserIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.ads.googleads.v11.enums.UserIdentifierSourceEnum.UserIdentifierSource user_identifier_source */ 6:
                    message.userIdentifierSource = reader.int32();
                    break;
                case /* string hashed_email */ 7:
                    message.identifier = {
                        oneofKind: "hashedEmail",
                        hashedEmail: reader.string()
                    };
                    break;
                case /* string hashed_phone_number */ 8:
                    message.identifier = {
                        oneofKind: "hashedPhoneNumber",
                        hashedPhoneNumber: reader.string()
                    };
                    break;
                case /* string mobile_id */ 9:
                    message.identifier = {
                        oneofKind: "mobileId",
                        mobileId: reader.string()
                    };
                    break;
                case /* string third_party_user_id */ 10:
                    message.identifier = {
                        oneofKind: "thirdPartyUserId",
                        thirdPartyUserId: reader.string()
                    };
                    break;
                case /* google.ads.googleads.v11.common.OfflineUserAddressInfo address_info */ 5:
                    message.identifier = {
                        oneofKind: "addressInfo",
                        addressInfo: OfflineUserAddressInfo.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).addressInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.ads.googleads.v11.enums.UserIdentifierSourceEnum.UserIdentifierSource user_identifier_source = 6; */
        if (message.userIdentifierSource !== 0)
            writer.tag(6, WireType.Varint).int32(message.userIdentifierSource);
        /* string hashed_email = 7; */
        if (message.identifier.oneofKind === "hashedEmail")
            writer.tag(7, WireType.LengthDelimited).string(message.identifier.hashedEmail);
        /* string hashed_phone_number = 8; */
        if (message.identifier.oneofKind === "hashedPhoneNumber")
            writer.tag(8, WireType.LengthDelimited).string(message.identifier.hashedPhoneNumber);
        /* string mobile_id = 9; */
        if (message.identifier.oneofKind === "mobileId")
            writer.tag(9, WireType.LengthDelimited).string(message.identifier.mobileId);
        /* string third_party_user_id = 10; */
        if (message.identifier.oneofKind === "thirdPartyUserId")
            writer.tag(10, WireType.LengthDelimited).string(message.identifier.thirdPartyUserId);
        /* google.ads.googleads.v11.common.OfflineUserAddressInfo address_info = 5; */
        if (message.identifier.oneofKind === "addressInfo")
            OfflineUserAddressInfo.internalBinaryWrite(message.identifier.addressInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.UserIdentifier
 */
export const UserIdentifier = new UserIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionAttribute$Type extends MessageType<TransactionAttribute> {
    constructor() {
        super("google.ads.googleads.v11.common.TransactionAttribute", [
            { no: 8, name: "transaction_date_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "transaction_amount_micros", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "conversion_action", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "order_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "store_attribute", kind: "message", T: () => StoreAttribute },
            { no: 13, name: "custom_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "item_attribute", kind: "message", T: () => ItemAttribute }
        ]);
    }
    create(value?: PartialMessage<TransactionAttribute>): TransactionAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionAttribute): TransactionAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string transaction_date_time */ 8:
                    message.transactionDateTime = reader.string();
                    break;
                case /* optional double transaction_amount_micros */ 9:
                    message.transactionAmountMicros = reader.double();
                    break;
                case /* optional string currency_code */ 10:
                    message.currencyCode = reader.string();
                    break;
                case /* optional string conversion_action */ 11:
                    message.conversionAction = reader.string();
                    break;
                case /* optional string order_id */ 12:
                    message.orderId = reader.string();
                    break;
                case /* google.ads.googleads.v11.common.StoreAttribute store_attribute */ 6:
                    message.storeAttribute = StoreAttribute.internalBinaryRead(reader, reader.uint32(), options, message.storeAttribute);
                    break;
                case /* optional string custom_value */ 13:
                    message.customValue = reader.string();
                    break;
                case /* google.ads.googleads.v11.common.ItemAttribute item_attribute */ 14:
                    message.itemAttribute = ItemAttribute.internalBinaryRead(reader, reader.uint32(), options, message.itemAttribute);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string transaction_date_time = 8; */
        if (message.transactionDateTime !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.transactionDateTime);
        /* optional double transaction_amount_micros = 9; */
        if (message.transactionAmountMicros !== undefined)
            writer.tag(9, WireType.Bit64).double(message.transactionAmountMicros);
        /* optional string currency_code = 10; */
        if (message.currencyCode !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.currencyCode);
        /* optional string conversion_action = 11; */
        if (message.conversionAction !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.conversionAction);
        /* optional string order_id = 12; */
        if (message.orderId !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.orderId);
        /* google.ads.googleads.v11.common.StoreAttribute store_attribute = 6; */
        if (message.storeAttribute)
            StoreAttribute.internalBinaryWrite(message.storeAttribute, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional string custom_value = 13; */
        if (message.customValue !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.customValue);
        /* google.ads.googleads.v11.common.ItemAttribute item_attribute = 14; */
        if (message.itemAttribute)
            ItemAttribute.internalBinaryWrite(message.itemAttribute, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.TransactionAttribute
 */
export const TransactionAttribute = new TransactionAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreAttribute$Type extends MessageType<StoreAttribute> {
    constructor() {
        super("google.ads.googleads.v11.common.StoreAttribute", [
            { no: 2, name: "store_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreAttribute>): StoreAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreAttribute): StoreAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string store_code */ 2:
                    message.storeCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string store_code = 2; */
        if (message.storeCode !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.storeCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.StoreAttribute
 */
export const StoreAttribute = new StoreAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemAttribute$Type extends MessageType<ItemAttribute> {
    constructor() {
        super("google.ads.googleads.v11.common.ItemAttribute", [
            { no: 1, name: "item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "merchant_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "language_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ItemAttribute>): ItemAttribute {
        const message = { itemId: "", countryCode: "", languageCode: "", quantity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemAttribute): ItemAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string item_id */ 1:
                    message.itemId = reader.string();
                    break;
                case /* optional int64 merchant_id */ 2:
                    message.merchantId = reader.int64().toBigInt();
                    break;
                case /* string country_code */ 3:
                    message.countryCode = reader.string();
                    break;
                case /* string language_code */ 4:
                    message.languageCode = reader.string();
                    break;
                case /* int64 quantity */ 5:
                    message.quantity = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string item_id = 1; */
        if (message.itemId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.itemId);
        /* optional int64 merchant_id = 2; */
        if (message.merchantId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.merchantId);
        /* string country_code = 3; */
        if (message.countryCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.countryCode);
        /* string language_code = 4; */
        if (message.languageCode !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.languageCode);
        /* int64 quantity = 5; */
        if (message.quantity !== 0n)
            writer.tag(5, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.ItemAttribute
 */
export const ItemAttribute = new ItemAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData$Type extends MessageType<UserData> {
    constructor() {
        super("google.ads.googleads.v11.common.UserData", [
            { no: 1, name: "user_identifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserIdentifier },
            { no: 2, name: "transaction_attribute", kind: "message", T: () => TransactionAttribute },
            { no: 3, name: "user_attribute", kind: "message", T: () => UserAttribute }
        ]);
    }
    create(value?: PartialMessage<UserData>): UserData {
        const message = { userIdentifiers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData): UserData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.common.UserIdentifier user_identifiers */ 1:
                    message.userIdentifiers.push(UserIdentifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.ads.googleads.v11.common.TransactionAttribute transaction_attribute */ 2:
                    message.transactionAttribute = TransactionAttribute.internalBinaryRead(reader, reader.uint32(), options, message.transactionAttribute);
                    break;
                case /* google.ads.googleads.v11.common.UserAttribute user_attribute */ 3:
                    message.userAttribute = UserAttribute.internalBinaryRead(reader, reader.uint32(), options, message.userAttribute);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.common.UserIdentifier user_identifiers = 1; */
        for (let i = 0; i < message.userIdentifiers.length; i++)
            UserIdentifier.internalBinaryWrite(message.userIdentifiers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.ads.googleads.v11.common.TransactionAttribute transaction_attribute = 2; */
        if (message.transactionAttribute)
            TransactionAttribute.internalBinaryWrite(message.transactionAttribute, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.ads.googleads.v11.common.UserAttribute user_attribute = 3; */
        if (message.userAttribute)
            UserAttribute.internalBinaryWrite(message.userAttribute, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.UserData
 */
export const UserData = new UserData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserAttribute$Type extends MessageType<UserAttribute> {
    constructor() {
        super("google.ads.googleads.v11.common.UserAttribute", [
            { no: 1, name: "lifetime_value_micros", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lifetime_value_bucket", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "last_purchase_date_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "average_purchase_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "average_purchase_value_micros", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "acquisition_date_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "shopping_loyalty", kind: "message", T: () => ShoppingLoyalty },
            { no: 8, name: "lifecycle_stage", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 9, name: "first_purchase_date_time", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 10, name: "event_attribute", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventAttribute, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<UserAttribute>): UserAttribute {
        const message = { lastPurchaseDateTime: "", averagePurchaseCount: 0, averagePurchaseValueMicros: 0n, acquisitionDateTime: "", lifecycleStage: "", firstPurchaseDateTime: "", eventAttribute: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserAttribute): UserAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 lifetime_value_micros */ 1:
                    message.lifetimeValueMicros = reader.int64().toBigInt();
                    break;
                case /* optional int32 lifetime_value_bucket */ 2:
                    message.lifetimeValueBucket = reader.int32();
                    break;
                case /* string last_purchase_date_time */ 3:
                    message.lastPurchaseDateTime = reader.string();
                    break;
                case /* int32 average_purchase_count */ 4:
                    message.averagePurchaseCount = reader.int32();
                    break;
                case /* int64 average_purchase_value_micros */ 5:
                    message.averagePurchaseValueMicros = reader.int64().toBigInt();
                    break;
                case /* string acquisition_date_time */ 6:
                    message.acquisitionDateTime = reader.string();
                    break;
                case /* optional google.ads.googleads.v11.common.ShoppingLoyalty shopping_loyalty */ 7:
                    message.shoppingLoyalty = ShoppingLoyalty.internalBinaryRead(reader, reader.uint32(), options, message.shoppingLoyalty);
                    break;
                case /* string lifecycle_stage */ 8:
                    message.lifecycleStage = reader.string();
                    break;
                case /* string first_purchase_date_time */ 9:
                    message.firstPurchaseDateTime = reader.string();
                    break;
                case /* repeated google.ads.googleads.v11.common.EventAttribute event_attribute */ 10:
                    message.eventAttribute.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 lifetime_value_micros = 1; */
        if (message.lifetimeValueMicros !== undefined)
            writer.tag(1, WireType.Varint).int64(message.lifetimeValueMicros);
        /* optional int32 lifetime_value_bucket = 2; */
        if (message.lifetimeValueBucket !== undefined)
            writer.tag(2, WireType.Varint).int32(message.lifetimeValueBucket);
        /* string last_purchase_date_time = 3; */
        if (message.lastPurchaseDateTime !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastPurchaseDateTime);
        /* int32 average_purchase_count = 4; */
        if (message.averagePurchaseCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.averagePurchaseCount);
        /* int64 average_purchase_value_micros = 5; */
        if (message.averagePurchaseValueMicros !== 0n)
            writer.tag(5, WireType.Varint).int64(message.averagePurchaseValueMicros);
        /* string acquisition_date_time = 6; */
        if (message.acquisitionDateTime !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.acquisitionDateTime);
        /* optional google.ads.googleads.v11.common.ShoppingLoyalty shopping_loyalty = 7; */
        if (message.shoppingLoyalty)
            ShoppingLoyalty.internalBinaryWrite(message.shoppingLoyalty, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string lifecycle_stage = 8; */
        if (message.lifecycleStage !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lifecycleStage);
        /* string first_purchase_date_time = 9; */
        if (message.firstPurchaseDateTime !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.firstPurchaseDateTime);
        /* repeated google.ads.googleads.v11.common.EventAttribute event_attribute = 10; */
        for (let i = 0; i < message.eventAttribute.length; i++)
            EventAttribute.internalBinaryWrite(message.eventAttribute[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.UserAttribute
 */
export const UserAttribute = new UserAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAttribute$Type extends MessageType<EventAttribute> {
    constructor() {
        super("google.ads.googleads.v11.common.EventAttribute", [
            { no: 1, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "event_date_time", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "item_attribute", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventItemAttribute, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<EventAttribute>): EventAttribute {
        const message = { event: "", eventDateTime: "", itemAttribute: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EventAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAttribute): EventAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string event */ 1:
                    message.event = reader.string();
                    break;
                case /* string event_date_time */ 2:
                    message.eventDateTime = reader.string();
                    break;
                case /* repeated google.ads.googleads.v11.common.EventItemAttribute item_attribute */ 3:
                    message.itemAttribute.push(EventItemAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event = 1; */
        if (message.event !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.event);
        /* string event_date_time = 2; */
        if (message.eventDateTime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.eventDateTime);
        /* repeated google.ads.googleads.v11.common.EventItemAttribute item_attribute = 3; */
        for (let i = 0; i < message.itemAttribute.length; i++)
            EventItemAttribute.internalBinaryWrite(message.itemAttribute[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.EventAttribute
 */
export const EventAttribute = new EventAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventItemAttribute$Type extends MessageType<EventItemAttribute> {
    constructor() {
        super("google.ads.googleads.v11.common.EventItemAttribute", [
            { no: 1, name: "item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<EventItemAttribute>): EventItemAttribute {
        const message = { itemId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EventItemAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventItemAttribute): EventItemAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string item_id */ 1:
                    message.itemId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventItemAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string item_id = 1; */
        if (message.itemId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.itemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.EventItemAttribute
 */
export const EventItemAttribute = new EventItemAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShoppingLoyalty$Type extends MessageType<ShoppingLoyalty> {
    constructor() {
        super("google.ads.googleads.v11.common.ShoppingLoyalty", [
            { no: 1, name: "loyalty_tier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShoppingLoyalty>): ShoppingLoyalty {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShoppingLoyalty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShoppingLoyalty): ShoppingLoyalty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string loyalty_tier */ 1:
                    message.loyaltyTier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShoppingLoyalty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string loyalty_tier = 1; */
        if (message.loyaltyTier !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.loyaltyTier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.ShoppingLoyalty
 */
export const ShoppingLoyalty = new ShoppingLoyalty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomerMatchUserListMetadata$Type extends MessageType<CustomerMatchUserListMetadata> {
    constructor() {
        super("google.ads.googleads.v11.common.CustomerMatchUserListMetadata", [
            { no: 2, name: "user_list", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CustomerMatchUserListMetadata>): CustomerMatchUserListMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomerMatchUserListMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomerMatchUserListMetadata): CustomerMatchUserListMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string user_list */ 2:
                    message.userList = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomerMatchUserListMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string user_list = 2; */
        if (message.userList !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.userList);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.CustomerMatchUserListMetadata
 */
export const CustomerMatchUserListMetadata = new CustomerMatchUserListMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreSalesMetadata$Type extends MessageType<StoreSalesMetadata> {
    constructor() {
        super("google.ads.googleads.v11.common.StoreSalesMetadata", [
            { no: 5, name: "loyalty_fraction", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "transaction_upload_fraction", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "custom_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "third_party_metadata", kind: "message", T: () => StoreSalesThirdPartyMetadata }
        ]);
    }
    create(value?: PartialMessage<StoreSalesMetadata>): StoreSalesMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreSalesMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreSalesMetadata): StoreSalesMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double loyalty_fraction */ 5:
                    message.loyaltyFraction = reader.double();
                    break;
                case /* optional double transaction_upload_fraction */ 6:
                    message.transactionUploadFraction = reader.double();
                    break;
                case /* optional string custom_key */ 7:
                    message.customKey = reader.string();
                    break;
                case /* google.ads.googleads.v11.common.StoreSalesThirdPartyMetadata third_party_metadata */ 3:
                    message.thirdPartyMetadata = StoreSalesThirdPartyMetadata.internalBinaryRead(reader, reader.uint32(), options, message.thirdPartyMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreSalesMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double loyalty_fraction = 5; */
        if (message.loyaltyFraction !== undefined)
            writer.tag(5, WireType.Bit64).double(message.loyaltyFraction);
        /* optional double transaction_upload_fraction = 6; */
        if (message.transactionUploadFraction !== undefined)
            writer.tag(6, WireType.Bit64).double(message.transactionUploadFraction);
        /* optional string custom_key = 7; */
        if (message.customKey !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.customKey);
        /* google.ads.googleads.v11.common.StoreSalesThirdPartyMetadata third_party_metadata = 3; */
        if (message.thirdPartyMetadata)
            StoreSalesThirdPartyMetadata.internalBinaryWrite(message.thirdPartyMetadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.StoreSalesMetadata
 */
export const StoreSalesMetadata = new StoreSalesMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreSalesThirdPartyMetadata$Type extends MessageType<StoreSalesThirdPartyMetadata> {
    constructor() {
        super("google.ads.googleads.v11.common.StoreSalesThirdPartyMetadata", [
            { no: 7, name: "advertiser_upload_date_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "valid_transaction_fraction", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "partner_match_fraction", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "partner_upload_fraction", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "bridge_map_version_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "partner_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StoreSalesThirdPartyMetadata>): StoreSalesThirdPartyMetadata {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreSalesThirdPartyMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreSalesThirdPartyMetadata): StoreSalesThirdPartyMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string advertiser_upload_date_time */ 7:
                    message.advertiserUploadDateTime = reader.string();
                    break;
                case /* optional double valid_transaction_fraction */ 8:
                    message.validTransactionFraction = reader.double();
                    break;
                case /* optional double partner_match_fraction */ 9:
                    message.partnerMatchFraction = reader.double();
                    break;
                case /* optional double partner_upload_fraction */ 10:
                    message.partnerUploadFraction = reader.double();
                    break;
                case /* optional string bridge_map_version_id */ 11:
                    message.bridgeMapVersionId = reader.string();
                    break;
                case /* optional int64 partner_id */ 12:
                    message.partnerId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreSalesThirdPartyMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string advertiser_upload_date_time = 7; */
        if (message.advertiserUploadDateTime !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.advertiserUploadDateTime);
        /* optional double valid_transaction_fraction = 8; */
        if (message.validTransactionFraction !== undefined)
            writer.tag(8, WireType.Bit64).double(message.validTransactionFraction);
        /* optional double partner_match_fraction = 9; */
        if (message.partnerMatchFraction !== undefined)
            writer.tag(9, WireType.Bit64).double(message.partnerMatchFraction);
        /* optional double partner_upload_fraction = 10; */
        if (message.partnerUploadFraction !== undefined)
            writer.tag(10, WireType.Bit64).double(message.partnerUploadFraction);
        /* optional string bridge_map_version_id = 11; */
        if (message.bridgeMapVersionId !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.bridgeMapVersionId);
        /* optional int64 partner_id = 12; */
        if (message.partnerId !== undefined)
            writer.tag(12, WireType.Varint).int64(message.partnerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.common.StoreSalesThirdPartyMetadata
 */
export const StoreSalesThirdPartyMetadata = new StoreSalesThirdPartyMetadata$Type();
