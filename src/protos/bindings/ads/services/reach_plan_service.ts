// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "ads/services/reach_plan_service.proto" (package "google.ads.googleads.v11.services", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserInterestInfo } from "../common/criteria";
import { DateRange } from "../common/dates";
import { FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit } from "../enums/frequency_cap_time_unit";
import { ReachPlanAdLengthEnum_ReachPlanAdLength } from "../enums/reach_plan_ad_length";
import { ReachPlanNetworkEnum_ReachPlanNetwork } from "../enums/reach_plan_network";
import { DeviceInfo } from "../common/criteria";
import { GenderInfo } from "../common/criteria";
import { ReachPlanAgeRangeEnum_ReachPlanAgeRange } from "../enums/reach_plan_age_range";
/**
 * Request message for [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableLocationsRequest
 */
export interface ListPlannableLocationsRequest {
}
/**
 * The list of plannable locations.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableLocationsResponse
 */
export interface ListPlannableLocationsResponse {
    /**
     * The list of locations available for planning.
     * See
     * https://developers.google.com/google-ads/api/reference/data/geotargets
     * for sample locations.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.PlannableLocation plannable_locations = 1;
     */
    plannableLocations: PlannableLocation[];
}
/**
 * A plannable location: country, metro region, province, etc.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannableLocation
 */
export interface PlannableLocation {
    /**
     * The location identifier.
     *
     * @generated from protobuf field: optional string id = 4;
     */
    id?: string;
    /**
     * The unique location name in English.
     *
     * @generated from protobuf field: optional string name = 5;
     */
    name?: string;
    /**
     * The parent country (not present if location is a country).
     * If present, will always be a GeoTargetConstant ID. Additional information
     * such as country name is provided by
     * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations] or
     * [GoogleAdsService.Search/SearchStream][].
     *
     * @generated from protobuf field: optional int64 parent_country_id = 6;
     */
    parentCountryId?: bigint;
    /**
     * The ISO-3166-1 alpha-2 country code that is associated with the location.
     *
     * @generated from protobuf field: optional string country_code = 7;
     */
    countryCode?: string;
    /**
     * The location's type. Location types correspond to target_type returned by
     * searching location type in [GoogleAdsService.Search/SearchStream][].
     *
     * @generated from protobuf field: optional string location_type = 8;
     */
    locationType?: string;
}
/**
 * Request to list available products in a given location.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableProductsRequest
 */
export interface ListPlannableProductsRequest {
    /**
     * Required. The ID of the selected location for planning. To list the available
     * plannable location IDs use [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
     *
     * @generated from protobuf field: string plannable_location_id = 2;
     */
    plannableLocationId: string;
}
/**
 * A response with all available products.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableProductsResponse
 */
export interface ListPlannableProductsResponse {
    /**
     * The list of products available for planning and related targeting metadata.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ProductMetadata product_metadata = 1;
     */
    productMetadata: ProductMetadata[];
}
/**
 * The metadata associated with an available plannable product.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ProductMetadata
 */
export interface ProductMetadata {
    /**
     * The code associated with the ad product (for example: BUMPER,
     * TRUEVIEW_IN_STREAM).
     * To list the available plannable product codes use
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: optional string plannable_product_code = 4;
     */
    plannableProductCode?: string;
    /**
     * The name associated with the ad product.
     *
     * @generated from protobuf field: string plannable_product_name = 3;
     */
    plannableProductName: string;
    /**
     * The allowed plannable targeting for this product.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.PlannableTargeting plannable_targeting = 2;
     */
    plannableTargeting?: PlannableTargeting;
}
/**
 * The targeting for which traffic metrics will be reported.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannableTargeting
 */
export interface PlannableTargeting {
    /**
     * Allowed plannable age ranges for the product for which metrics will be
     * reported. Actual targeting is computed by mapping this age range onto
     * standard Google common.AgeRangeInfo values.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_ranges = 1;
     */
    ageRanges: ReachPlanAgeRangeEnum_ReachPlanAgeRange[];
    /**
     * Targetable genders for the ad product.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.GenderInfo genders = 2;
     */
    genders: GenderInfo[];
    /**
     * Targetable devices for the ad product.
     * TABLET device targeting is automatically applied to reported metrics
     * when MOBILE targeting is selected for CPM_MASTHEAD,
     * GOOGLE_PREFERRED_BUMPER, and GOOGLE_PREFERRED_SHORT products.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.DeviceInfo devices = 3;
     */
    devices: DeviceInfo[];
    /**
     * Targetable networks for the ad product.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork networks = 4;
     */
    networks: ReachPlanNetworkEnum_ReachPlanNetwork[];
    /**
     * Targetable YouTube Select Lineups for the ad product.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.YouTubeSelectLineUp youtube_select_lineups = 5;
     */
    youtubeSelectLineups: YouTubeSelectLineUp[];
}
/**
 * Request message for [ReachPlanService.GenerateProductMixIdeas][google.ads.googleads.v11.services.ReachPlanService.GenerateProductMixIdeas].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasRequest
 */
export interface GenerateProductMixIdeasRequest {
    /**
     * Required. The ID of the customer.
     *
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * Required. The ID of the location, this is one of the IDs returned by
     * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
     *
     * @generated from protobuf field: string plannable_location_id = 6;
     */
    plannableLocationId: string;
    /**
     * Required. Currency code.
     * Three-character ISO 4217 currency code.
     *
     * @generated from protobuf field: string currency_code = 7;
     */
    currencyCode: string;
    /**
     * Required. Total budget.
     * Amount in micros. One million is equivalent to one unit.
     *
     * @generated from protobuf field: int64 budget_micros = 8;
     */
    budgetMicros: bigint;
    /**
     * The preferences of the suggested product mix.
     * An unset preference is interpreted as all possible values are allowed,
     * unless explicitly specified.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.Preferences preferences = 5;
     */
    preferences?: Preferences;
}
/**
 * Set of preferences about the planned mix.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.Preferences
 */
export interface Preferences {
    /**
     * True if ad skippable.
     * If not set, default is any value.
     *
     * @generated from protobuf field: optional bool is_skippable = 6;
     */
    isSkippable?: boolean;
    /**
     * True if ad start with sound.
     * If not set, default is any value.
     *
     * @generated from protobuf field: optional bool starts_with_sound = 7;
     */
    startsWithSound?: boolean;
    /**
     * The length of the ad.
     * If not set, default is any value.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ReachPlanAdLengthEnum.ReachPlanAdLength ad_length = 3;
     */
    adLength: ReachPlanAdLengthEnum_ReachPlanAdLength;
    /**
     * True if ad will only show on the top content.
     * If not set, default is false.
     *
     * @generated from protobuf field: optional bool top_content_only = 8;
     */
    topContentOnly?: boolean;
    /**
     * True if the price is guaranteed. The cost of serving the ad is agreed
     * upfront and not subject to an auction.
     * If not set, default is any value.
     *
     * @generated from protobuf field: optional bool has_guaranteed_price = 9;
     */
    hasGuaranteedPrice?: boolean;
}
/**
 * The suggested product mix.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasResponse
 */
export interface GenerateProductMixIdeasResponse {
    /**
     * A list of products (ad formats) and the associated budget allocation idea.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ProductAllocation product_allocation = 1;
     */
    productAllocation: ProductAllocation[];
}
/**
 * An allocation of a part of the budget on a given product.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ProductAllocation
 */
export interface ProductAllocation {
    /**
     * Selected product for planning. The product codes returned are within the
     * set of the ones returned by ListPlannableProducts when using the same
     * location ID.
     *
     * @generated from protobuf field: optional string plannable_product_code = 3;
     */
    plannableProductCode?: string;
    /**
     * The value to be allocated for the suggested product in requested currency.
     * Amount in micros. One million is equivalent to one unit.
     *
     * @generated from protobuf field: optional int64 budget_micros = 4;
     */
    budgetMicros?: bigint;
}
/**
 * Request message for [ReachPlanService.GenerateReachForecast][google.ads.googleads.v11.services.ReachPlanService.GenerateReachForecast].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateReachForecastRequest
 */
export interface GenerateReachForecastRequest {
    /**
     * Required. The ID of the customer.
     *
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * The currency code.
     * Three-character ISO 4217 currency code.
     *
     * @generated from protobuf field: optional string currency_code = 9;
     */
    currencyCode?: string;
    /**
     * Required. Campaign duration.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.CampaignDuration campaign_duration = 3;
     */
    campaignDuration?: CampaignDuration;
    /**
     * Chosen cookie frequency cap to be applied to each planned product.
     * This is equivalent to the frequency cap exposed in Google Ads when creating
     * a campaign, it represents the maximum number of times an ad can be shown to
     * the same user.
     * If not specified, no cap is applied.
     *
     * This field is deprecated in v4 and will eventually be removed.
     * Use cookie_frequency_cap_setting instead.
     *
     * @generated from protobuf field: optional int32 cookie_frequency_cap = 10;
     */
    cookieFrequencyCap?: number;
    /**
     * Chosen cookie frequency cap to be applied to each planned product.
     * This is equivalent to the frequency cap exposed in Google Ads when creating
     * a campaign, it represents the maximum number of times an ad can be shown to
     * the same user during a specified time interval.
     * If not specified, a default of 0 (no cap) is applied.
     *
     * This field replaces the deprecated cookie_frequency_cap field.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.FrequencyCap cookie_frequency_cap_setting = 8;
     */
    cookieFrequencyCapSetting?: FrequencyCap;
    /**
     * Chosen minimum effective frequency (the number of times a person was
     * exposed to the ad) for the reported reach metrics [1-10].
     * This won't affect the targeting, but just the reporting.
     * If not specified, a default of 1 is applied.
     *
     * This field cannot be combined with the effective_frequency_limit field.
     *
     * @generated from protobuf field: optional int32 min_effective_frequency = 11;
     */
    minEffectiveFrequency?: number;
    /**
     * The highest minimum effective frequency (the number of times a person was
     * exposed to the ad) value [1-10] to include in
     * Forecast.effective_frequency_breakdowns.
     * If not specified, Forecast.effective_frequency_breakdowns will not be
     * provided.
     *
     * The effective frequency value provided here will also be used as the
     * minimum effective frequency for the reported reach metrics.
     *
     * This field cannot be combined with the min_effective_frequency field.
     *
     * @generated from protobuf field: optional google.ads.googleads.v11.services.EffectiveFrequencyLimit effective_frequency_limit = 12;
     */
    effectiveFrequencyLimit?: EffectiveFrequencyLimit;
    /**
     * The targeting to be applied to all products selected in the product mix.
     *
     * This is planned targeting: execution details might vary based on the
     * advertising product, consult an implementation specialist.
     *
     * See specific metrics for details on how targeting affects them.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.Targeting targeting = 6;
     */
    targeting?: Targeting;
    /**
     * Required. The products to be forecast.
     * The max number of allowed planned products is 15.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.PlannedProduct planned_products = 7;
     */
    plannedProducts: PlannedProduct[];
    /**
     * Controls the forecast metrics returned in the response.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.ForecastMetricOptions forecast_metric_options = 13;
     */
    forecastMetricOptions?: ForecastMetricOptions;
    /**
     * The name of the customer being planned for. This is a user-defined value.
     * Required if targeting.audience_targeting is set.
     *
     * @generated from protobuf field: optional string customer_reach_group = 14;
     */
    customerReachGroup?: string;
}
/**
 * Effective frequency limit.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.EffectiveFrequencyLimit
 */
export interface EffectiveFrequencyLimit {
    /**
     * The highest effective frequency value to include in
     * Forecast.effective_frequency_breakdowns.
     * This field supports frequencies 1-10, inclusive.
     *
     * @generated from protobuf field: int32 effective_frequency_breakdown_limit = 1;
     */
    effectiveFrequencyBreakdownLimit: number;
}
/**
 * A rule specifying the maximum number of times an ad can be shown to a user
 * over a particular time period.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.FrequencyCap
 */
export interface FrequencyCap {
    /**
     * Required. The number of impressions, inclusive.
     *
     * @generated from protobuf field: int32 impressions = 3;
     */
    impressions: number;
    /**
     * Required. The type of time unit.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit time_unit = 2;
     */
    timeUnit: FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit;
}
/**
 * The targeting for which traffic metrics will be reported.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.Targeting
 */
export interface Targeting {
    /**
     * Required. The ID of the selected location. Plannable location IDs can be
     * obtained from [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
     *
     * @generated from protobuf field: optional string plannable_location_id = 6;
     */
    plannableLocationId?: string;
    /**
     * Targeted age range.
     * An unset value is equivalent to targeting all ages.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_range = 2;
     */
    ageRange: ReachPlanAgeRangeEnum_ReachPlanAgeRange;
    /**
     * Targeted genders.
     * An unset value is equivalent to targeting MALE and FEMALE.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.GenderInfo genders = 3;
     */
    genders: GenderInfo[];
    /**
     * Targeted devices.
     * If not specified, targets all applicable devices. Applicable devices vary
     * by product and region and can be obtained from
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.DeviceInfo devices = 4;
     */
    devices: DeviceInfo[];
    /**
     * Targetable network for the ad product.
     * If not specified, targets all applicable networks. Applicable networks vary
     * by product and region and can be obtained from
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork network = 5;
     */
    network: ReachPlanNetworkEnum_ReachPlanNetwork;
    /**
     * Targeted audiences.
     * If not specified, does not target any specific audience.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.AudienceTargeting audience_targeting = 7;
     */
    audienceTargeting?: AudienceTargeting;
}
/**
 * The duration of a planned campaign.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.CampaignDuration
 */
export interface CampaignDuration {
    /**
     * The duration value in days.
     *
     * This field cannot be combined with the date_range field.
     *
     * @generated from protobuf field: optional int32 duration_in_days = 2;
     */
    durationInDays?: number;
    /**
     * Date range of the campaign.
     * Dates are in the yyyy-mm-dd format and inclusive.
     * The end date must be < 1 year in the future and the
     * date range must be <= 92 days long.
     *
     * This field cannot be combined with the duration_in_days field.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.DateRange date_range = 3;
     */
    dateRange?: DateRange;
}
/**
 * A product being planned for reach.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannedProduct
 */
export interface PlannedProduct {
    /**
     * Required. Selected product for planning.
     * The code associated with the ad product (for example: Trueview, Bumper).
     * To list the available plannable product codes use
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: optional string plannable_product_code = 3;
     */
    plannableProductCode?: string;
    /**
     * Required. Maximum budget allocation in micros for the selected product.
     * The value is specified in the selected planning currency_code.
     * For example: 1 000 000$ = 1 000 000 000 000 micros.
     *
     * @generated from protobuf field: optional int64 budget_micros = 4;
     */
    budgetMicros?: bigint;
    /**
     * Targeting settings for the selected product.
     * To list the available targeting for each product use
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.AdvancedProductTargeting advanced_product_targeting = 5;
     */
    advancedProductTargeting?: AdvancedProductTargeting;
}
/**
 * Response message containing the generated reach curve.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateReachForecastResponse
 */
export interface GenerateReachForecastResponse {
    /**
     * Reference on target audiences for this curve.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.OnTargetAudienceMetrics on_target_audience_metrics = 1;
     */
    onTargetAudienceMetrics?: OnTargetAudienceMetrics;
    /**
     * The generated reach curve for the planned product mix.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.ReachCurve reach_curve = 2;
     */
    reachCurve?: ReachCurve;
}
/**
 * The reach curve for the planned products.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ReachCurve
 */
export interface ReachCurve {
    /**
     * All points on the reach curve.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ReachForecast reach_forecasts = 1;
     */
    reachForecasts: ReachForecast[];
}
/**
 * A point on reach curve.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ReachForecast
 */
export interface ReachForecast {
    /**
     * The cost in micros.
     *
     * @generated from protobuf field: int64 cost_micros = 5;
     */
    costMicros: bigint;
    /**
     * Forecasted traffic metrics for this point.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.Forecast forecast = 2;
     */
    forecast?: Forecast;
    /**
     * The forecasted allocation and traffic metrics for each planned product
     * at this point on the reach curve.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.PlannedProductReachForecast planned_product_reach_forecasts = 4;
     */
    plannedProductReachForecasts: PlannedProductReachForecast[];
}
/**
 * Forecasted traffic metrics for the planned products and targeting.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.Forecast
 */
export interface Forecast {
    /**
     * Number of unique people reached at least
     * GenerateReachForecastRequest.min_effective_frequency or
     * GenerateReachForecastRequest.effective_frequency_limit times that exactly
     * matches the Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the on_target_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: optional int64 on_target_reach = 5;
     */
    onTargetReach?: bigint;
    /**
     * Total number of unique people reached at least
     * GenerateReachForecastRequest.min_effective_frequency or
     * GenerateReachForecastRequest.effective_frequency_limit times. This includes
     * people that may fall outside the specified Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the total_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: optional int64 total_reach = 6;
     */
    totalReach?: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting.
     *
     * @generated from protobuf field: optional int64 on_target_impressions = 7;
     */
    onTargetImpressions?: bigint;
    /**
     * Total number of ad impressions. This includes impressions that may fall
     * outside the specified Targeting, due to insufficient information on
     * signed-in users.
     *
     * @generated from protobuf field: optional int64 total_impressions = 8;
     */
    totalImpressions?: bigint;
    /**
     * Number of times the ad's impressions were considered viewable.
     * See https://support.google.com/google-ads/answer/7029393 for
     * more information about what makes an ad viewable and how
     * viewability is measured.
     *
     * @generated from protobuf field: optional int64 viewable_impressions = 9;
     */
    viewableImpressions?: bigint;
    /**
     * A list of effective frequency forecasts. The list is ordered starting with
     * 1+ and ending with the value set in
     * GenerateReachForecastRequest.effective_frequency_limit. If no
     * effective_frequency_limit was set, this list will be empty.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.EffectiveFrequencyBreakdown effective_frequency_breakdowns = 10;
     */
    effectiveFrequencyBreakdowns: EffectiveFrequencyBreakdown[];
    /**
     * Number of unique people reached that exactly matches the Targeting
     * including co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_reach = 11;
     */
    onTargetCoviewReach?: bigint;
    /**
     * Number of unique people reached including co-viewers. This includes
     * people that may fall outside the specified Targeting.
     *
     * @generated from protobuf field: optional int64 total_coview_reach = 12;
     */
    totalCoviewReach?: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting including
     * co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_impressions = 13;
     */
    onTargetCoviewImpressions?: bigint;
    /**
     * Total number of ad impressions including co-viewers. This includes
     * impressions that may fall outside the specified Targeting, due to
     * insufficient information on signed-in users.
     *
     * @generated from protobuf field: optional int64 total_coview_impressions = 14;
     */
    totalCoviewImpressions?: bigint;
}
/**
 * The forecasted allocation and traffic metrics for a specific product
 * at a point on the reach curve.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannedProductReachForecast
 */
export interface PlannedProductReachForecast {
    /**
     * Selected product for planning. The product codes returned are within the
     * set of the ones returned by ListPlannableProducts when using the same
     * location ID.
     *
     * @generated from protobuf field: string plannable_product_code = 1;
     */
    plannableProductCode: string;
    /**
     * The cost in micros. This may differ from the product's input allocation
     * if one or more planned products cannot fulfill the budget because of
     * limited inventory.
     *
     * @generated from protobuf field: int64 cost_micros = 2;
     */
    costMicros: bigint;
    /**
     * Forecasted traffic metrics for this product.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.PlannedProductForecast planned_product_forecast = 3;
     */
    plannedProductForecast?: PlannedProductForecast;
}
/**
 * Forecasted traffic metrics for a planned product.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannedProductForecast
 */
export interface PlannedProductForecast {
    /**
     * Number of unique people reached that exactly matches the Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the on_target_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 on_target_reach = 1;
     */
    onTargetReach: bigint;
    /**
     * Number of unique people reached. This includes people that may fall
     * outside the specified Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the total_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 total_reach = 2;
     */
    totalReach: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting.
     *
     * @generated from protobuf field: int64 on_target_impressions = 3;
     */
    onTargetImpressions: bigint;
    /**
     * Total number of ad impressions. This includes impressions that may fall
     * outside the specified Targeting, due to insufficient information on
     * signed-in users.
     *
     * @generated from protobuf field: int64 total_impressions = 4;
     */
    totalImpressions: bigint;
    /**
     * Number of times the ad's impressions were considered viewable.
     * See https://support.google.com/google-ads/answer/7029393 for
     * more information about what makes an ad viewable and how
     * viewability is measured.
     *
     * @generated from protobuf field: optional int64 viewable_impressions = 5;
     */
    viewableImpressions?: bigint;
    /**
     * Number of unique people reached that exactly matches the Targeting
     * including co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_reach = 6;
     */
    onTargetCoviewReach?: bigint;
    /**
     * Number of unique people reached including co-viewers. This includes
     * people that may fall outside the specified Targeting.
     *
     * @generated from protobuf field: optional int64 total_coview_reach = 7;
     */
    totalCoviewReach?: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting including
     * co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_impressions = 8;
     */
    onTargetCoviewImpressions?: bigint;
    /**
     * Total number of ad impressions including co-viewers. This includes
     * impressions that may fall outside the specified Targeting, due to
     * insufficient information on signed-in users.
     *
     * @generated from protobuf field: optional int64 total_coview_impressions = 9;
     */
    totalCoviewImpressions?: bigint;
}
/**
 * Audience metrics for the planned products.
 * These metrics consider the following targeting dimensions:
 *
 * - Location
 * - PlannableAgeRange
 * - Gender
 *
 * @generated from protobuf message google.ads.googleads.v11.services.OnTargetAudienceMetrics
 */
export interface OnTargetAudienceMetrics {
    /**
     * Reference audience size matching the considered targeting for YouTube.
     *
     * @generated from protobuf field: optional int64 youtube_audience_size = 3;
     */
    youtubeAudienceSize?: bigint;
    /**
     * Reference audience size matching the considered targeting for Census.
     *
     * @generated from protobuf field: optional int64 census_audience_size = 4;
     */
    censusAudienceSize?: bigint;
}
/**
 * A breakdown of the number of unique people reached at a given effective
 * frequency.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.EffectiveFrequencyBreakdown
 */
export interface EffectiveFrequencyBreakdown {
    /**
     * The effective frequency [1-10].
     *
     * @generated from protobuf field: int32 effective_frequency = 1;
     */
    effectiveFrequency: number;
    /**
     * The number of unique people reached at least effective_frequency times that
     * exactly matches the Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the on_target_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 on_target_reach = 2;
     */
    onTargetReach: bigint;
    /**
     * Total number of unique people reached at least effective_frequency times.
     * This includes people that may fall outside the specified Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the total_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 total_reach = 3;
     */
    totalReach: bigint;
    /**
     * The number of users (including co-viewing users) reached for the associated
     * effective_frequency value.
     *
     * @generated from protobuf field: optional int64 effective_coview_reach = 4;
     */
    effectiveCoviewReach?: bigint;
    /**
     * The number of users (including co-viewing users) reached for the associated
     * effective_frequency value within the specified plan demographic.
     *
     * @generated from protobuf field: optional int64 on_target_effective_coview_reach = 5;
     */
    onTargetEffectiveCoviewReach?: bigint;
}
/**
 * Controls forecast metrics to return.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ForecastMetricOptions
 */
export interface ForecastMetricOptions {
    /**
     * Indicates whether to include co-view metrics in the response forecast.
     *
     * @generated from protobuf field: bool include_coview = 1;
     */
    includeCoview: boolean;
}
/**
 * Audience targeting for reach forecast.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.AudienceTargeting
 */
export interface AudienceTargeting {
    /**
     * List of audiences based on user interests to be targeted.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.UserInterestInfo user_interest = 1;
     */
    userInterest: UserInterestInfo[];
}
/**
 * Advanced targeting settings for products.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.AdvancedProductTargeting
 */
export interface AdvancedProductTargeting {
    /**
     * @generated from protobuf oneof: advanced_targeting
     */
    advancedTargeting: {
        oneofKind: "youtubeSelectSettings";
        /**
         * Settings for YouTube Select targeting.
         *
         * @generated from protobuf field: google.ads.googleads.v11.services.YouTubeSelectSettings youtube_select_settings = 1;
         */
        youtubeSelectSettings: YouTubeSelectSettings;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Request settings for YouTube Select Lineups
 *
 * @generated from protobuf message google.ads.googleads.v11.services.YouTubeSelectSettings
 */
export interface YouTubeSelectSettings {
    /**
     * Lineup for YouTube Select Targeting.
     *
     * @generated from protobuf field: int64 lineup_id = 1;
     */
    lineupId: bigint;
}
/**
 * A Plannable YouTube Select Lineup for product targeting.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.YouTubeSelectLineUp
 */
export interface YouTubeSelectLineUp {
    /**
     * The ID of the YouTube Select Lineup.
     *
     * @generated from protobuf field: int64 lineup_id = 1;
     */
    lineupId: bigint;
    /**
     * The unique name of the YouTube Select Lineup.
     *
     * @generated from protobuf field: string lineup_name = 2;
     */
    lineupName: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class ListPlannableLocationsRequest$Type extends MessageType<ListPlannableLocationsRequest> {
    constructor() {
        super("google.ads.googleads.v11.services.ListPlannableLocationsRequest", []);
    }
    create(value?: PartialMessage<ListPlannableLocationsRequest>): ListPlannableLocationsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPlannableLocationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableLocationsRequest): ListPlannableLocationsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListPlannableLocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableLocationsRequest
 */
export const ListPlannableLocationsRequest = new ListPlannableLocationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPlannableLocationsResponse$Type extends MessageType<ListPlannableLocationsResponse> {
    constructor() {
        super("google.ads.googleads.v11.services.ListPlannableLocationsResponse", [
            { no: 1, name: "plannable_locations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlannableLocation }
        ]);
    }
    create(value?: PartialMessage<ListPlannableLocationsResponse>): ListPlannableLocationsResponse {
        const message = { plannableLocations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPlannableLocationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableLocationsResponse): ListPlannableLocationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.services.PlannableLocation plannable_locations */ 1:
                    message.plannableLocations.push(PlannableLocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPlannableLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.services.PlannableLocation plannable_locations = 1; */
        for (let i = 0; i < message.plannableLocations.length; i++)
            PlannableLocation.internalBinaryWrite(message.plannableLocations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableLocationsResponse
 */
export const ListPlannableLocationsResponse = new ListPlannableLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannableLocation$Type extends MessageType<PlannableLocation> {
    constructor() {
        super("google.ads.googleads.v11.services.PlannableLocation", [
            { no: 4, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "parent_country_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "location_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlannableLocation>): PlannableLocation {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlannableLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannableLocation): PlannableLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 4:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 5:
                    message.name = reader.string();
                    break;
                case /* optional int64 parent_country_id */ 6:
                    message.parentCountryId = reader.int64().toBigInt();
                    break;
                case /* optional string country_code */ 7:
                    message.countryCode = reader.string();
                    break;
                case /* optional string location_type */ 8:
                    message.locationType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannableLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 4; */
        if (message.id !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.id);
        /* optional string name = 5; */
        if (message.name !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* optional int64 parent_country_id = 6; */
        if (message.parentCountryId !== undefined)
            writer.tag(6, WireType.Varint).int64(message.parentCountryId);
        /* optional string country_code = 7; */
        if (message.countryCode !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.countryCode);
        /* optional string location_type = 8; */
        if (message.locationType !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.locationType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannableLocation
 */
export const PlannableLocation = new PlannableLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPlannableProductsRequest$Type extends MessageType<ListPlannableProductsRequest> {
    constructor() {
        super("google.ads.googleads.v11.services.ListPlannableProductsRequest", [
            { no: 2, name: "plannable_location_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<ListPlannableProductsRequest>): ListPlannableProductsRequest {
        const message = { plannableLocationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPlannableProductsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableProductsRequest): ListPlannableProductsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string plannable_location_id */ 2:
                    message.plannableLocationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPlannableProductsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string plannable_location_id = 2; */
        if (message.plannableLocationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.plannableLocationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableProductsRequest
 */
export const ListPlannableProductsRequest = new ListPlannableProductsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPlannableProductsResponse$Type extends MessageType<ListPlannableProductsResponse> {
    constructor() {
        super("google.ads.googleads.v11.services.ListPlannableProductsResponse", [
            { no: 1, name: "product_metadata", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProductMetadata }
        ]);
    }
    create(value?: PartialMessage<ListPlannableProductsResponse>): ListPlannableProductsResponse {
        const message = { productMetadata: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPlannableProductsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableProductsResponse): ListPlannableProductsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.services.ProductMetadata product_metadata */ 1:
                    message.productMetadata.push(ProductMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPlannableProductsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.services.ProductMetadata product_metadata = 1; */
        for (let i = 0; i < message.productMetadata.length; i++)
            ProductMetadata.internalBinaryWrite(message.productMetadata[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableProductsResponse
 */
export const ListPlannableProductsResponse = new ListPlannableProductsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductMetadata$Type extends MessageType<ProductMetadata> {
    constructor() {
        super("google.ads.googleads.v11.services.ProductMetadata", [
            { no: 4, name: "plannable_product_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "plannable_product_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "plannable_targeting", kind: "message", T: () => PlannableTargeting }
        ]);
    }
    create(value?: PartialMessage<ProductMetadata>): ProductMetadata {
        const message = { plannableProductName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductMetadata): ProductMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string plannable_product_code */ 4:
                    message.plannableProductCode = reader.string();
                    break;
                case /* string plannable_product_name */ 3:
                    message.plannableProductName = reader.string();
                    break;
                case /* google.ads.googleads.v11.services.PlannableTargeting plannable_targeting */ 2:
                    message.plannableTargeting = PlannableTargeting.internalBinaryRead(reader, reader.uint32(), options, message.plannableTargeting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string plannable_product_code = 4; */
        if (message.plannableProductCode !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.plannableProductCode);
        /* string plannable_product_name = 3; */
        if (message.plannableProductName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.plannableProductName);
        /* google.ads.googleads.v11.services.PlannableTargeting plannable_targeting = 2; */
        if (message.plannableTargeting)
            PlannableTargeting.internalBinaryWrite(message.plannableTargeting, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ProductMetadata
 */
export const ProductMetadata = new ProductMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannableTargeting$Type extends MessageType<PlannableTargeting> {
    constructor() {
        super("google.ads.googleads.v11.services.PlannableTargeting", [
            { no: 1, name: "age_ranges", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange", ReachPlanAgeRangeEnum_ReachPlanAgeRange] },
            { no: 2, name: "genders", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GenderInfo },
            { no: 3, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DeviceInfo },
            { no: 4, name: "networks", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork", ReachPlanNetworkEnum_ReachPlanNetwork] },
            { no: 5, name: "youtube_select_lineups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => YouTubeSelectLineUp }
        ]);
    }
    create(value?: PartialMessage<PlannableTargeting>): PlannableTargeting {
        const message = { ageRanges: [], genders: [], devices: [], networks: [], youtubeSelectLineups: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlannableTargeting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannableTargeting): PlannableTargeting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_ranges */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ageRanges.push(reader.int32());
                    else
                        message.ageRanges.push(reader.int32());
                    break;
                case /* repeated google.ads.googleads.v11.common.GenderInfo genders */ 2:
                    message.genders.push(GenderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.ads.googleads.v11.common.DeviceInfo devices */ 3:
                    message.devices.push(DeviceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork networks */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.networks.push(reader.int32());
                    else
                        message.networks.push(reader.int32());
                    break;
                case /* repeated google.ads.googleads.v11.services.YouTubeSelectLineUp youtube_select_lineups */ 5:
                    message.youtubeSelectLineups.push(YouTubeSelectLineUp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannableTargeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_ranges = 1; */
        if (message.ageRanges.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ageRanges.length; i++)
                writer.int32(message.ageRanges[i]);
            writer.join();
        }
        /* repeated google.ads.googleads.v11.common.GenderInfo genders = 2; */
        for (let i = 0; i < message.genders.length; i++)
            GenderInfo.internalBinaryWrite(message.genders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.common.DeviceInfo devices = 3; */
        for (let i = 0; i < message.devices.length; i++)
            DeviceInfo.internalBinaryWrite(message.devices[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork networks = 4; */
        if (message.networks.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.networks.length; i++)
                writer.int32(message.networks[i]);
            writer.join();
        }
        /* repeated google.ads.googleads.v11.services.YouTubeSelectLineUp youtube_select_lineups = 5; */
        for (let i = 0; i < message.youtubeSelectLineups.length; i++)
            YouTubeSelectLineUp.internalBinaryWrite(message.youtubeSelectLineups[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannableTargeting
 */
export const PlannableTargeting = new PlannableTargeting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateProductMixIdeasRequest$Type extends MessageType<GenerateProductMixIdeasRequest> {
    constructor() {
        super("google.ads.googleads.v11.services.GenerateProductMixIdeasRequest", [
            { no: 1, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 6, name: "plannable_location_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 7, name: "currency_code", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 8, name: "budget_micros", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 5, name: "preferences", kind: "message", T: () => Preferences }
        ]);
    }
    create(value?: PartialMessage<GenerateProductMixIdeasRequest>): GenerateProductMixIdeasRequest {
        const message = { customerId: "", plannableLocationId: "", currencyCode: "", budgetMicros: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateProductMixIdeasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateProductMixIdeasRequest): GenerateProductMixIdeasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string customer_id */ 1:
                    message.customerId = reader.string();
                    break;
                case /* string plannable_location_id */ 6:
                    message.plannableLocationId = reader.string();
                    break;
                case /* string currency_code */ 7:
                    message.currencyCode = reader.string();
                    break;
                case /* int64 budget_micros */ 8:
                    message.budgetMicros = reader.int64().toBigInt();
                    break;
                case /* google.ads.googleads.v11.services.Preferences preferences */ 5:
                    message.preferences = Preferences.internalBinaryRead(reader, reader.uint32(), options, message.preferences);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateProductMixIdeasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string customer_id = 1; */
        if (message.customerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.customerId);
        /* string plannable_location_id = 6; */
        if (message.plannableLocationId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.plannableLocationId);
        /* string currency_code = 7; */
        if (message.currencyCode !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.currencyCode);
        /* int64 budget_micros = 8; */
        if (message.budgetMicros !== 0n)
            writer.tag(8, WireType.Varint).int64(message.budgetMicros);
        /* google.ads.googleads.v11.services.Preferences preferences = 5; */
        if (message.preferences)
            Preferences.internalBinaryWrite(message.preferences, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasRequest
 */
export const GenerateProductMixIdeasRequest = new GenerateProductMixIdeasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Preferences$Type extends MessageType<Preferences> {
    constructor() {
        super("google.ads.googleads.v11.services.Preferences", [
            { no: 6, name: "is_skippable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "starts_with_sound", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "ad_length", kind: "enum", T: () => ["google.ads.googleads.v11.enums.ReachPlanAdLengthEnum.ReachPlanAdLength", ReachPlanAdLengthEnum_ReachPlanAdLength] },
            { no: 8, name: "top_content_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "has_guaranteed_price", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Preferences>): Preferences {
        const message = { adLength: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Preferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Preferences): Preferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_skippable */ 6:
                    message.isSkippable = reader.bool();
                    break;
                case /* optional bool starts_with_sound */ 7:
                    message.startsWithSound = reader.bool();
                    break;
                case /* google.ads.googleads.v11.enums.ReachPlanAdLengthEnum.ReachPlanAdLength ad_length */ 3:
                    message.adLength = reader.int32();
                    break;
                case /* optional bool top_content_only */ 8:
                    message.topContentOnly = reader.bool();
                    break;
                case /* optional bool has_guaranteed_price */ 9:
                    message.hasGuaranteedPrice = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Preferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_skippable = 6; */
        if (message.isSkippable !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isSkippable);
        /* optional bool starts_with_sound = 7; */
        if (message.startsWithSound !== undefined)
            writer.tag(7, WireType.Varint).bool(message.startsWithSound);
        /* google.ads.googleads.v11.enums.ReachPlanAdLengthEnum.ReachPlanAdLength ad_length = 3; */
        if (message.adLength !== 0)
            writer.tag(3, WireType.Varint).int32(message.adLength);
        /* optional bool top_content_only = 8; */
        if (message.topContentOnly !== undefined)
            writer.tag(8, WireType.Varint).bool(message.topContentOnly);
        /* optional bool has_guaranteed_price = 9; */
        if (message.hasGuaranteedPrice !== undefined)
            writer.tag(9, WireType.Varint).bool(message.hasGuaranteedPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.Preferences
 */
export const Preferences = new Preferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateProductMixIdeasResponse$Type extends MessageType<GenerateProductMixIdeasResponse> {
    constructor() {
        super("google.ads.googleads.v11.services.GenerateProductMixIdeasResponse", [
            { no: 1, name: "product_allocation", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProductAllocation }
        ]);
    }
    create(value?: PartialMessage<GenerateProductMixIdeasResponse>): GenerateProductMixIdeasResponse {
        const message = { productAllocation: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateProductMixIdeasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateProductMixIdeasResponse): GenerateProductMixIdeasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.services.ProductAllocation product_allocation */ 1:
                    message.productAllocation.push(ProductAllocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateProductMixIdeasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.services.ProductAllocation product_allocation = 1; */
        for (let i = 0; i < message.productAllocation.length; i++)
            ProductAllocation.internalBinaryWrite(message.productAllocation[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasResponse
 */
export const GenerateProductMixIdeasResponse = new GenerateProductMixIdeasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductAllocation$Type extends MessageType<ProductAllocation> {
    constructor() {
        super("google.ads.googleads.v11.services.ProductAllocation", [
            { no: 3, name: "plannable_product_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "budget_micros", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ProductAllocation>): ProductAllocation {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductAllocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductAllocation): ProductAllocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string plannable_product_code */ 3:
                    message.plannableProductCode = reader.string();
                    break;
                case /* optional int64 budget_micros */ 4:
                    message.budgetMicros = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductAllocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string plannable_product_code = 3; */
        if (message.plannableProductCode !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.plannableProductCode);
        /* optional int64 budget_micros = 4; */
        if (message.budgetMicros !== undefined)
            writer.tag(4, WireType.Varint).int64(message.budgetMicros);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ProductAllocation
 */
export const ProductAllocation = new ProductAllocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateReachForecastRequest$Type extends MessageType<GenerateReachForecastRequest> {
    constructor() {
        super("google.ads.googleads.v11.services.GenerateReachForecastRequest", [
            { no: 1, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 9, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "campaign_duration", kind: "message", T: () => CampaignDuration, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 10, name: "cookie_frequency_cap", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "cookie_frequency_cap_setting", kind: "message", T: () => FrequencyCap },
            { no: 11, name: "min_effective_frequency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "effective_frequency_limit", kind: "message", T: () => EffectiveFrequencyLimit },
            { no: 6, name: "targeting", kind: "message", T: () => Targeting },
            { no: 7, name: "planned_products", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlannedProduct, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 13, name: "forecast_metric_options", kind: "message", T: () => ForecastMetricOptions },
            { no: 14, name: "customer_reach_group", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GenerateReachForecastRequest>): GenerateReachForecastRequest {
        const message = { customerId: "", plannedProducts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateReachForecastRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateReachForecastRequest): GenerateReachForecastRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string customer_id */ 1:
                    message.customerId = reader.string();
                    break;
                case /* optional string currency_code */ 9:
                    message.currencyCode = reader.string();
                    break;
                case /* google.ads.googleads.v11.services.CampaignDuration campaign_duration */ 3:
                    message.campaignDuration = CampaignDuration.internalBinaryRead(reader, reader.uint32(), options, message.campaignDuration);
                    break;
                case /* optional int32 cookie_frequency_cap */ 10:
                    message.cookieFrequencyCap = reader.int32();
                    break;
                case /* google.ads.googleads.v11.services.FrequencyCap cookie_frequency_cap_setting */ 8:
                    message.cookieFrequencyCapSetting = FrequencyCap.internalBinaryRead(reader, reader.uint32(), options, message.cookieFrequencyCapSetting);
                    break;
                case /* optional int32 min_effective_frequency */ 11:
                    message.minEffectiveFrequency = reader.int32();
                    break;
                case /* optional google.ads.googleads.v11.services.EffectiveFrequencyLimit effective_frequency_limit */ 12:
                    message.effectiveFrequencyLimit = EffectiveFrequencyLimit.internalBinaryRead(reader, reader.uint32(), options, message.effectiveFrequencyLimit);
                    break;
                case /* google.ads.googleads.v11.services.Targeting targeting */ 6:
                    message.targeting = Targeting.internalBinaryRead(reader, reader.uint32(), options, message.targeting);
                    break;
                case /* repeated google.ads.googleads.v11.services.PlannedProduct planned_products */ 7:
                    message.plannedProducts.push(PlannedProduct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.ads.googleads.v11.services.ForecastMetricOptions forecast_metric_options */ 13:
                    message.forecastMetricOptions = ForecastMetricOptions.internalBinaryRead(reader, reader.uint32(), options, message.forecastMetricOptions);
                    break;
                case /* optional string customer_reach_group */ 14:
                    message.customerReachGroup = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateReachForecastRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string customer_id = 1; */
        if (message.customerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.customerId);
        /* optional string currency_code = 9; */
        if (message.currencyCode !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.currencyCode);
        /* google.ads.googleads.v11.services.CampaignDuration campaign_duration = 3; */
        if (message.campaignDuration)
            CampaignDuration.internalBinaryWrite(message.campaignDuration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 cookie_frequency_cap = 10; */
        if (message.cookieFrequencyCap !== undefined)
            writer.tag(10, WireType.Varint).int32(message.cookieFrequencyCap);
        /* google.ads.googleads.v11.services.FrequencyCap cookie_frequency_cap_setting = 8; */
        if (message.cookieFrequencyCapSetting)
            FrequencyCap.internalBinaryWrite(message.cookieFrequencyCapSetting, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 min_effective_frequency = 11; */
        if (message.minEffectiveFrequency !== undefined)
            writer.tag(11, WireType.Varint).int32(message.minEffectiveFrequency);
        /* optional google.ads.googleads.v11.services.EffectiveFrequencyLimit effective_frequency_limit = 12; */
        if (message.effectiveFrequencyLimit)
            EffectiveFrequencyLimit.internalBinaryWrite(message.effectiveFrequencyLimit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.ads.googleads.v11.services.Targeting targeting = 6; */
        if (message.targeting)
            Targeting.internalBinaryWrite(message.targeting, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.services.PlannedProduct planned_products = 7; */
        for (let i = 0; i < message.plannedProducts.length; i++)
            PlannedProduct.internalBinaryWrite(message.plannedProducts[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.ads.googleads.v11.services.ForecastMetricOptions forecast_metric_options = 13; */
        if (message.forecastMetricOptions)
            ForecastMetricOptions.internalBinaryWrite(message.forecastMetricOptions, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional string customer_reach_group = 14; */
        if (message.customerReachGroup !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.customerReachGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateReachForecastRequest
 */
export const GenerateReachForecastRequest = new GenerateReachForecastRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EffectiveFrequencyLimit$Type extends MessageType<EffectiveFrequencyLimit> {
    constructor() {
        super("google.ads.googleads.v11.services.EffectiveFrequencyLimit", [
            { no: 1, name: "effective_frequency_breakdown_limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EffectiveFrequencyLimit>): EffectiveFrequencyLimit {
        const message = { effectiveFrequencyBreakdownLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EffectiveFrequencyLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectiveFrequencyLimit): EffectiveFrequencyLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 effective_frequency_breakdown_limit */ 1:
                    message.effectiveFrequencyBreakdownLimit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EffectiveFrequencyLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 effective_frequency_breakdown_limit = 1; */
        if (message.effectiveFrequencyBreakdownLimit !== 0)
            writer.tag(1, WireType.Varint).int32(message.effectiveFrequencyBreakdownLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.EffectiveFrequencyLimit
 */
export const EffectiveFrequencyLimit = new EffectiveFrequencyLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrequencyCap$Type extends MessageType<FrequencyCap> {
    constructor() {
        super("google.ads.googleads.v11.services.FrequencyCap", [
            { no: 3, name: "impressions", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "time_unit", kind: "enum", T: () => ["google.ads.googleads.v11.enums.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit", FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit], options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<FrequencyCap>): FrequencyCap {
        const message = { impressions: 0, timeUnit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrequencyCap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrequencyCap): FrequencyCap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 impressions */ 3:
                    message.impressions = reader.int32();
                    break;
                case /* google.ads.googleads.v11.enums.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit time_unit */ 2:
                    message.timeUnit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrequencyCap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 impressions = 3; */
        if (message.impressions !== 0)
            writer.tag(3, WireType.Varint).int32(message.impressions);
        /* google.ads.googleads.v11.enums.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit time_unit = 2; */
        if (message.timeUnit !== 0)
            writer.tag(2, WireType.Varint).int32(message.timeUnit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.FrequencyCap
 */
export const FrequencyCap = new FrequencyCap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Targeting$Type extends MessageType<Targeting> {
    constructor() {
        super("google.ads.googleads.v11.services.Targeting", [
            { no: 6, name: "plannable_location_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "age_range", kind: "enum", T: () => ["google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange", ReachPlanAgeRangeEnum_ReachPlanAgeRange] },
            { no: 3, name: "genders", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GenderInfo },
            { no: 4, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DeviceInfo },
            { no: 5, name: "network", kind: "enum", T: () => ["google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork", ReachPlanNetworkEnum_ReachPlanNetwork] },
            { no: 7, name: "audience_targeting", kind: "message", T: () => AudienceTargeting }
        ]);
    }
    create(value?: PartialMessage<Targeting>): Targeting {
        const message = { ageRange: 0, genders: [], devices: [], network: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Targeting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Targeting): Targeting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string plannable_location_id */ 6:
                    message.plannableLocationId = reader.string();
                    break;
                case /* google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_range */ 2:
                    message.ageRange = reader.int32();
                    break;
                case /* repeated google.ads.googleads.v11.common.GenderInfo genders */ 3:
                    message.genders.push(GenderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.ads.googleads.v11.common.DeviceInfo devices */ 4:
                    message.devices.push(DeviceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork network */ 5:
                    message.network = reader.int32();
                    break;
                case /* google.ads.googleads.v11.services.AudienceTargeting audience_targeting */ 7:
                    message.audienceTargeting = AudienceTargeting.internalBinaryRead(reader, reader.uint32(), options, message.audienceTargeting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Targeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string plannable_location_id = 6; */
        if (message.plannableLocationId !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.plannableLocationId);
        /* google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_range = 2; */
        if (message.ageRange !== 0)
            writer.tag(2, WireType.Varint).int32(message.ageRange);
        /* repeated google.ads.googleads.v11.common.GenderInfo genders = 3; */
        for (let i = 0; i < message.genders.length; i++)
            GenderInfo.internalBinaryWrite(message.genders[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.common.DeviceInfo devices = 4; */
        for (let i = 0; i < message.devices.length; i++)
            DeviceInfo.internalBinaryWrite(message.devices[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork network = 5; */
        if (message.network !== 0)
            writer.tag(5, WireType.Varint).int32(message.network);
        /* google.ads.googleads.v11.services.AudienceTargeting audience_targeting = 7; */
        if (message.audienceTargeting)
            AudienceTargeting.internalBinaryWrite(message.audienceTargeting, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.Targeting
 */
export const Targeting = new Targeting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CampaignDuration$Type extends MessageType<CampaignDuration> {
    constructor() {
        super("google.ads.googleads.v11.services.CampaignDuration", [
            { no: 2, name: "duration_in_days", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "date_range", kind: "message", T: () => DateRange }
        ]);
    }
    create(value?: PartialMessage<CampaignDuration>): CampaignDuration {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CampaignDuration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CampaignDuration): CampaignDuration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 duration_in_days */ 2:
                    message.durationInDays = reader.int32();
                    break;
                case /* google.ads.googleads.v11.common.DateRange date_range */ 3:
                    message.dateRange = DateRange.internalBinaryRead(reader, reader.uint32(), options, message.dateRange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CampaignDuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 duration_in_days = 2; */
        if (message.durationInDays !== undefined)
            writer.tag(2, WireType.Varint).int32(message.durationInDays);
        /* google.ads.googleads.v11.common.DateRange date_range = 3; */
        if (message.dateRange)
            DateRange.internalBinaryWrite(message.dateRange, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.CampaignDuration
 */
export const CampaignDuration = new CampaignDuration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedProduct$Type extends MessageType<PlannedProduct> {
    constructor() {
        super("google.ads.googleads.v11.services.PlannedProduct", [
            { no: 3, name: "plannable_product_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "budget_micros", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "advanced_product_targeting", kind: "message", T: () => AdvancedProductTargeting }
        ]);
    }
    create(value?: PartialMessage<PlannedProduct>): PlannedProduct {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlannedProduct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedProduct): PlannedProduct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string plannable_product_code */ 3:
                    message.plannableProductCode = reader.string();
                    break;
                case /* optional int64 budget_micros */ 4:
                    message.budgetMicros = reader.int64().toBigInt();
                    break;
                case /* google.ads.googleads.v11.services.AdvancedProductTargeting advanced_product_targeting */ 5:
                    message.advancedProductTargeting = AdvancedProductTargeting.internalBinaryRead(reader, reader.uint32(), options, message.advancedProductTargeting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string plannable_product_code = 3; */
        if (message.plannableProductCode !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.plannableProductCode);
        /* optional int64 budget_micros = 4; */
        if (message.budgetMicros !== undefined)
            writer.tag(4, WireType.Varint).int64(message.budgetMicros);
        /* google.ads.googleads.v11.services.AdvancedProductTargeting advanced_product_targeting = 5; */
        if (message.advancedProductTargeting)
            AdvancedProductTargeting.internalBinaryWrite(message.advancedProductTargeting, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannedProduct
 */
export const PlannedProduct = new PlannedProduct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateReachForecastResponse$Type extends MessageType<GenerateReachForecastResponse> {
    constructor() {
        super("google.ads.googleads.v11.services.GenerateReachForecastResponse", [
            { no: 1, name: "on_target_audience_metrics", kind: "message", T: () => OnTargetAudienceMetrics },
            { no: 2, name: "reach_curve", kind: "message", T: () => ReachCurve }
        ]);
    }
    create(value?: PartialMessage<GenerateReachForecastResponse>): GenerateReachForecastResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateReachForecastResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateReachForecastResponse): GenerateReachForecastResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.ads.googleads.v11.services.OnTargetAudienceMetrics on_target_audience_metrics */ 1:
                    message.onTargetAudienceMetrics = OnTargetAudienceMetrics.internalBinaryRead(reader, reader.uint32(), options, message.onTargetAudienceMetrics);
                    break;
                case /* google.ads.googleads.v11.services.ReachCurve reach_curve */ 2:
                    message.reachCurve = ReachCurve.internalBinaryRead(reader, reader.uint32(), options, message.reachCurve);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateReachForecastResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.ads.googleads.v11.services.OnTargetAudienceMetrics on_target_audience_metrics = 1; */
        if (message.onTargetAudienceMetrics)
            OnTargetAudienceMetrics.internalBinaryWrite(message.onTargetAudienceMetrics, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.ads.googleads.v11.services.ReachCurve reach_curve = 2; */
        if (message.reachCurve)
            ReachCurve.internalBinaryWrite(message.reachCurve, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateReachForecastResponse
 */
export const GenerateReachForecastResponse = new GenerateReachForecastResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReachCurve$Type extends MessageType<ReachCurve> {
    constructor() {
        super("google.ads.googleads.v11.services.ReachCurve", [
            { no: 1, name: "reach_forecasts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReachForecast }
        ]);
    }
    create(value?: PartialMessage<ReachCurve>): ReachCurve {
        const message = { reachForecasts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReachCurve>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReachCurve): ReachCurve {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.services.ReachForecast reach_forecasts */ 1:
                    message.reachForecasts.push(ReachForecast.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReachCurve, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.services.ReachForecast reach_forecasts = 1; */
        for (let i = 0; i < message.reachForecasts.length; i++)
            ReachForecast.internalBinaryWrite(message.reachForecasts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ReachCurve
 */
export const ReachCurve = new ReachCurve$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReachForecast$Type extends MessageType<ReachForecast> {
    constructor() {
        super("google.ads.googleads.v11.services.ReachForecast", [
            { no: 5, name: "cost_micros", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "forecast", kind: "message", T: () => Forecast },
            { no: 4, name: "planned_product_reach_forecasts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlannedProductReachForecast }
        ]);
    }
    create(value?: PartialMessage<ReachForecast>): ReachForecast {
        const message = { costMicros: 0n, plannedProductReachForecasts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReachForecast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReachForecast): ReachForecast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 cost_micros */ 5:
                    message.costMicros = reader.int64().toBigInt();
                    break;
                case /* google.ads.googleads.v11.services.Forecast forecast */ 2:
                    message.forecast = Forecast.internalBinaryRead(reader, reader.uint32(), options, message.forecast);
                    break;
                case /* repeated google.ads.googleads.v11.services.PlannedProductReachForecast planned_product_reach_forecasts */ 4:
                    message.plannedProductReachForecasts.push(PlannedProductReachForecast.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReachForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 cost_micros = 5; */
        if (message.costMicros !== 0n)
            writer.tag(5, WireType.Varint).int64(message.costMicros);
        /* google.ads.googleads.v11.services.Forecast forecast = 2; */
        if (message.forecast)
            Forecast.internalBinaryWrite(message.forecast, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.services.PlannedProductReachForecast planned_product_reach_forecasts = 4; */
        for (let i = 0; i < message.plannedProductReachForecasts.length; i++)
            PlannedProductReachForecast.internalBinaryWrite(message.plannedProductReachForecasts[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ReachForecast
 */
export const ReachForecast = new ReachForecast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Forecast$Type extends MessageType<Forecast> {
    constructor() {
        super("google.ads.googleads.v11.services.Forecast", [
            { no: 5, name: "on_target_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "total_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "on_target_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "total_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "viewable_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "effective_frequency_breakdowns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EffectiveFrequencyBreakdown },
            { no: 11, name: "on_target_coview_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "total_coview_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "on_target_coview_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "total_coview_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Forecast>): Forecast {
        const message = { effectiveFrequencyBreakdowns: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Forecast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Forecast): Forecast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 on_target_reach */ 5:
                    message.onTargetReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 total_reach */ 6:
                    message.totalReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 on_target_impressions */ 7:
                    message.onTargetImpressions = reader.int64().toBigInt();
                    break;
                case /* optional int64 total_impressions */ 8:
                    message.totalImpressions = reader.int64().toBigInt();
                    break;
                case /* optional int64 viewable_impressions */ 9:
                    message.viewableImpressions = reader.int64().toBigInt();
                    break;
                case /* repeated google.ads.googleads.v11.services.EffectiveFrequencyBreakdown effective_frequency_breakdowns */ 10:
                    message.effectiveFrequencyBreakdowns.push(EffectiveFrequencyBreakdown.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int64 on_target_coview_reach */ 11:
                    message.onTargetCoviewReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 total_coview_reach */ 12:
                    message.totalCoviewReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 on_target_coview_impressions */ 13:
                    message.onTargetCoviewImpressions = reader.int64().toBigInt();
                    break;
                case /* optional int64 total_coview_impressions */ 14:
                    message.totalCoviewImpressions = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Forecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 on_target_reach = 5; */
        if (message.onTargetReach !== undefined)
            writer.tag(5, WireType.Varint).int64(message.onTargetReach);
        /* optional int64 total_reach = 6; */
        if (message.totalReach !== undefined)
            writer.tag(6, WireType.Varint).int64(message.totalReach);
        /* optional int64 on_target_impressions = 7; */
        if (message.onTargetImpressions !== undefined)
            writer.tag(7, WireType.Varint).int64(message.onTargetImpressions);
        /* optional int64 total_impressions = 8; */
        if (message.totalImpressions !== undefined)
            writer.tag(8, WireType.Varint).int64(message.totalImpressions);
        /* optional int64 viewable_impressions = 9; */
        if (message.viewableImpressions !== undefined)
            writer.tag(9, WireType.Varint).int64(message.viewableImpressions);
        /* repeated google.ads.googleads.v11.services.EffectiveFrequencyBreakdown effective_frequency_breakdowns = 10; */
        for (let i = 0; i < message.effectiveFrequencyBreakdowns.length; i++)
            EffectiveFrequencyBreakdown.internalBinaryWrite(message.effectiveFrequencyBreakdowns[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 on_target_coview_reach = 11; */
        if (message.onTargetCoviewReach !== undefined)
            writer.tag(11, WireType.Varint).int64(message.onTargetCoviewReach);
        /* optional int64 total_coview_reach = 12; */
        if (message.totalCoviewReach !== undefined)
            writer.tag(12, WireType.Varint).int64(message.totalCoviewReach);
        /* optional int64 on_target_coview_impressions = 13; */
        if (message.onTargetCoviewImpressions !== undefined)
            writer.tag(13, WireType.Varint).int64(message.onTargetCoviewImpressions);
        /* optional int64 total_coview_impressions = 14; */
        if (message.totalCoviewImpressions !== undefined)
            writer.tag(14, WireType.Varint).int64(message.totalCoviewImpressions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.Forecast
 */
export const Forecast = new Forecast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedProductReachForecast$Type extends MessageType<PlannedProductReachForecast> {
    constructor() {
        super("google.ads.googleads.v11.services.PlannedProductReachForecast", [
            { no: 1, name: "plannable_product_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cost_micros", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "planned_product_forecast", kind: "message", T: () => PlannedProductForecast }
        ]);
    }
    create(value?: PartialMessage<PlannedProductReachForecast>): PlannedProductReachForecast {
        const message = { plannableProductCode: "", costMicros: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlannedProductReachForecast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedProductReachForecast): PlannedProductReachForecast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string plannable_product_code */ 1:
                    message.plannableProductCode = reader.string();
                    break;
                case /* int64 cost_micros */ 2:
                    message.costMicros = reader.int64().toBigInt();
                    break;
                case /* google.ads.googleads.v11.services.PlannedProductForecast planned_product_forecast */ 3:
                    message.plannedProductForecast = PlannedProductForecast.internalBinaryRead(reader, reader.uint32(), options, message.plannedProductForecast);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedProductReachForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string plannable_product_code = 1; */
        if (message.plannableProductCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.plannableProductCode);
        /* int64 cost_micros = 2; */
        if (message.costMicros !== 0n)
            writer.tag(2, WireType.Varint).int64(message.costMicros);
        /* google.ads.googleads.v11.services.PlannedProductForecast planned_product_forecast = 3; */
        if (message.plannedProductForecast)
            PlannedProductForecast.internalBinaryWrite(message.plannedProductForecast, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannedProductReachForecast
 */
export const PlannedProductReachForecast = new PlannedProductReachForecast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedProductForecast$Type extends MessageType<PlannedProductForecast> {
    constructor() {
        super("google.ads.googleads.v11.services.PlannedProductForecast", [
            { no: 1, name: "on_target_reach", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "total_reach", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "on_target_impressions", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_impressions", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "viewable_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "on_target_coview_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "total_coview_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "on_target_coview_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "total_coview_impressions", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PlannedProductForecast>): PlannedProductForecast {
        const message = { onTargetReach: 0n, totalReach: 0n, onTargetImpressions: 0n, totalImpressions: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlannedProductForecast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedProductForecast): PlannedProductForecast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 on_target_reach */ 1:
                    message.onTargetReach = reader.int64().toBigInt();
                    break;
                case /* int64 total_reach */ 2:
                    message.totalReach = reader.int64().toBigInt();
                    break;
                case /* int64 on_target_impressions */ 3:
                    message.onTargetImpressions = reader.int64().toBigInt();
                    break;
                case /* int64 total_impressions */ 4:
                    message.totalImpressions = reader.int64().toBigInt();
                    break;
                case /* optional int64 viewable_impressions */ 5:
                    message.viewableImpressions = reader.int64().toBigInt();
                    break;
                case /* optional int64 on_target_coview_reach */ 6:
                    message.onTargetCoviewReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 total_coview_reach */ 7:
                    message.totalCoviewReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 on_target_coview_impressions */ 8:
                    message.onTargetCoviewImpressions = reader.int64().toBigInt();
                    break;
                case /* optional int64 total_coview_impressions */ 9:
                    message.totalCoviewImpressions = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedProductForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 on_target_reach = 1; */
        if (message.onTargetReach !== 0n)
            writer.tag(1, WireType.Varint).int64(message.onTargetReach);
        /* int64 total_reach = 2; */
        if (message.totalReach !== 0n)
            writer.tag(2, WireType.Varint).int64(message.totalReach);
        /* int64 on_target_impressions = 3; */
        if (message.onTargetImpressions !== 0n)
            writer.tag(3, WireType.Varint).int64(message.onTargetImpressions);
        /* int64 total_impressions = 4; */
        if (message.totalImpressions !== 0n)
            writer.tag(4, WireType.Varint).int64(message.totalImpressions);
        /* optional int64 viewable_impressions = 5; */
        if (message.viewableImpressions !== undefined)
            writer.tag(5, WireType.Varint).int64(message.viewableImpressions);
        /* optional int64 on_target_coview_reach = 6; */
        if (message.onTargetCoviewReach !== undefined)
            writer.tag(6, WireType.Varint).int64(message.onTargetCoviewReach);
        /* optional int64 total_coview_reach = 7; */
        if (message.totalCoviewReach !== undefined)
            writer.tag(7, WireType.Varint).int64(message.totalCoviewReach);
        /* optional int64 on_target_coview_impressions = 8; */
        if (message.onTargetCoviewImpressions !== undefined)
            writer.tag(8, WireType.Varint).int64(message.onTargetCoviewImpressions);
        /* optional int64 total_coview_impressions = 9; */
        if (message.totalCoviewImpressions !== undefined)
            writer.tag(9, WireType.Varint).int64(message.totalCoviewImpressions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannedProductForecast
 */
export const PlannedProductForecast = new PlannedProductForecast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OnTargetAudienceMetrics$Type extends MessageType<OnTargetAudienceMetrics> {
    constructor() {
        super("google.ads.googleads.v11.services.OnTargetAudienceMetrics", [
            { no: 3, name: "youtube_audience_size", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "census_audience_size", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OnTargetAudienceMetrics>): OnTargetAudienceMetrics {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OnTargetAudienceMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnTargetAudienceMetrics): OnTargetAudienceMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 youtube_audience_size */ 3:
                    message.youtubeAudienceSize = reader.int64().toBigInt();
                    break;
                case /* optional int64 census_audience_size */ 4:
                    message.censusAudienceSize = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OnTargetAudienceMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 youtube_audience_size = 3; */
        if (message.youtubeAudienceSize !== undefined)
            writer.tag(3, WireType.Varint).int64(message.youtubeAudienceSize);
        /* optional int64 census_audience_size = 4; */
        if (message.censusAudienceSize !== undefined)
            writer.tag(4, WireType.Varint).int64(message.censusAudienceSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.OnTargetAudienceMetrics
 */
export const OnTargetAudienceMetrics = new OnTargetAudienceMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EffectiveFrequencyBreakdown$Type extends MessageType<EffectiveFrequencyBreakdown> {
    constructor() {
        super("google.ads.googleads.v11.services.EffectiveFrequencyBreakdown", [
            { no: 1, name: "effective_frequency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "on_target_reach", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "total_reach", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "effective_coview_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "on_target_effective_coview_reach", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EffectiveFrequencyBreakdown>): EffectiveFrequencyBreakdown {
        const message = { effectiveFrequency: 0, onTargetReach: 0n, totalReach: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EffectiveFrequencyBreakdown>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectiveFrequencyBreakdown): EffectiveFrequencyBreakdown {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 effective_frequency */ 1:
                    message.effectiveFrequency = reader.int32();
                    break;
                case /* int64 on_target_reach */ 2:
                    message.onTargetReach = reader.int64().toBigInt();
                    break;
                case /* int64 total_reach */ 3:
                    message.totalReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 effective_coview_reach */ 4:
                    message.effectiveCoviewReach = reader.int64().toBigInt();
                    break;
                case /* optional int64 on_target_effective_coview_reach */ 5:
                    message.onTargetEffectiveCoviewReach = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EffectiveFrequencyBreakdown, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 effective_frequency = 1; */
        if (message.effectiveFrequency !== 0)
            writer.tag(1, WireType.Varint).int32(message.effectiveFrequency);
        /* int64 on_target_reach = 2; */
        if (message.onTargetReach !== 0n)
            writer.tag(2, WireType.Varint).int64(message.onTargetReach);
        /* int64 total_reach = 3; */
        if (message.totalReach !== 0n)
            writer.tag(3, WireType.Varint).int64(message.totalReach);
        /* optional int64 effective_coview_reach = 4; */
        if (message.effectiveCoviewReach !== undefined)
            writer.tag(4, WireType.Varint).int64(message.effectiveCoviewReach);
        /* optional int64 on_target_effective_coview_reach = 5; */
        if (message.onTargetEffectiveCoviewReach !== undefined)
            writer.tag(5, WireType.Varint).int64(message.onTargetEffectiveCoviewReach);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.EffectiveFrequencyBreakdown
 */
export const EffectiveFrequencyBreakdown = new EffectiveFrequencyBreakdown$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForecastMetricOptions$Type extends MessageType<ForecastMetricOptions> {
    constructor() {
        super("google.ads.googleads.v11.services.ForecastMetricOptions", [
            { no: 1, name: "include_coview", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ForecastMetricOptions>): ForecastMetricOptions {
        const message = { includeCoview: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForecastMetricOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForecastMetricOptions): ForecastMetricOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool include_coview */ 1:
                    message.includeCoview = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForecastMetricOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool include_coview = 1; */
        if (message.includeCoview !== false)
            writer.tag(1, WireType.Varint).bool(message.includeCoview);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ForecastMetricOptions
 */
export const ForecastMetricOptions = new ForecastMetricOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudienceTargeting$Type extends MessageType<AudienceTargeting> {
    constructor() {
        super("google.ads.googleads.v11.services.AudienceTargeting", [
            { no: 1, name: "user_interest", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserInterestInfo }
        ]);
    }
    create(value?: PartialMessage<AudienceTargeting>): AudienceTargeting {
        const message = { userInterest: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AudienceTargeting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudienceTargeting): AudienceTargeting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.ads.googleads.v11.common.UserInterestInfo user_interest */ 1:
                    message.userInterest.push(UserInterestInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudienceTargeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.ads.googleads.v11.common.UserInterestInfo user_interest = 1; */
        for (let i = 0; i < message.userInterest.length; i++)
            UserInterestInfo.internalBinaryWrite(message.userInterest[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.AudienceTargeting
 */
export const AudienceTargeting = new AudienceTargeting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdvancedProductTargeting$Type extends MessageType<AdvancedProductTargeting> {
    constructor() {
        super("google.ads.googleads.v11.services.AdvancedProductTargeting", [
            { no: 1, name: "youtube_select_settings", kind: "message", oneof: "advancedTargeting", T: () => YouTubeSelectSettings }
        ]);
    }
    create(value?: PartialMessage<AdvancedProductTargeting>): AdvancedProductTargeting {
        const message = { advancedTargeting: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdvancedProductTargeting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdvancedProductTargeting): AdvancedProductTargeting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.ads.googleads.v11.services.YouTubeSelectSettings youtube_select_settings */ 1:
                    message.advancedTargeting = {
                        oneofKind: "youtubeSelectSettings",
                        youtubeSelectSettings: YouTubeSelectSettings.internalBinaryRead(reader, reader.uint32(), options, (message.advancedTargeting as any).youtubeSelectSettings)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdvancedProductTargeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.ads.googleads.v11.services.YouTubeSelectSettings youtube_select_settings = 1; */
        if (message.advancedTargeting.oneofKind === "youtubeSelectSettings")
            YouTubeSelectSettings.internalBinaryWrite(message.advancedTargeting.youtubeSelectSettings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.AdvancedProductTargeting
 */
export const AdvancedProductTargeting = new AdvancedProductTargeting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class YouTubeSelectSettings$Type extends MessageType<YouTubeSelectSettings> {
    constructor() {
        super("google.ads.googleads.v11.services.YouTubeSelectSettings", [
            { no: 1, name: "lineup_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<YouTubeSelectSettings>): YouTubeSelectSettings {
        const message = { lineupId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<YouTubeSelectSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: YouTubeSelectSettings): YouTubeSelectSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 lineup_id */ 1:
                    message.lineupId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: YouTubeSelectSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 lineup_id = 1; */
        if (message.lineupId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.lineupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.YouTubeSelectSettings
 */
export const YouTubeSelectSettings = new YouTubeSelectSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class YouTubeSelectLineUp$Type extends MessageType<YouTubeSelectLineUp> {
    constructor() {
        super("google.ads.googleads.v11.services.YouTubeSelectLineUp", [
            { no: 1, name: "lineup_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lineup_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<YouTubeSelectLineUp>): YouTubeSelectLineUp {
        const message = { lineupId: 0n, lineupName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<YouTubeSelectLineUp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: YouTubeSelectLineUp): YouTubeSelectLineUp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 lineup_id */ 1:
                    message.lineupId = reader.int64().toBigInt();
                    break;
                case /* string lineup_name */ 2:
                    message.lineupName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: YouTubeSelectLineUp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 lineup_id = 1; */
        if (message.lineupId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.lineupId);
        /* string lineup_name = 2; */
        if (message.lineupName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lineupName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.YouTubeSelectLineUp
 */
export const YouTubeSelectLineUp = new YouTubeSelectLineUp$Type();
/**
 * @generated ServiceType for protobuf service google.ads.googleads.v11.services.ReachPlanService
 */
export const ReachPlanService = new ServiceType("google.ads.googleads.v11.services.ReachPlanService", [
    { name: "ListPlannableLocations", options: { "google.api.http": { post: "/v11:listPlannableLocations", body: "*" } }, I: ListPlannableLocationsRequest, O: ListPlannableLocationsResponse },
    { name: "ListPlannableProducts", options: { "google.api.http": { post: "/v11:listPlannableProducts", body: "*" }, "google.api.method_signature": ["plannable_location_id"] }, I: ListPlannableProductsRequest, O: ListPlannableProductsResponse },
    { name: "GenerateProductMixIdeas", options: { "google.api.http": { post: "/v11/customers/{customer_id=*}:generateProductMixIdeas", body: "*" }, "google.api.method_signature": ["customer_id,plannable_location_id,currency_code,budget_micros"] }, I: GenerateProductMixIdeasRequest, O: GenerateProductMixIdeasResponse },
    { name: "GenerateReachForecast", options: { "google.api.http": { post: "/v11/customers/{customer_id=*}:generateReachForecast", body: "*" }, "google.api.method_signature": ["customer_id,campaign_duration,planned_products"] }, I: GenerateReachForecastRequest, O: GenerateReachForecastResponse }
], { "google.api.default_host": "googleads.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/adwords" });
