// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "ads/services/conversion_adjustment_upload_service.proto" (package "google.ads.googleads.v11.services", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserIdentifier } from "../common/offline_user_data";
import { ConversionAdjustmentTypeEnum_ConversionAdjustmentType } from "../enums/conversion_adjustment_type";
import { Status } from "../../google/rpc/status";
/**
 * Request message for
 * [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v11.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.UploadConversionAdjustmentsRequest
 */
export interface UploadConversionAdjustmentsRequest {
    /**
     * Required. The ID of the customer performing the upload.
     *
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * Required. The conversion adjustments that are being uploaded.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ConversionAdjustment conversion_adjustments = 2;
     */
    conversionAdjustments: ConversionAdjustment[];
    /**
     * Required. If true, successful operations will be carried out and invalid
     * operations will return errors. If false, all operations will be carried out
     * in one transaction if and only if they are all valid. This should always be
     * set to true.
     * See
     * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
     * for more information about partial failure.
     *
     * @generated from protobuf field: bool partial_failure = 3;
     */
    partialFailure: boolean;
    /**
     * If true, the request is validated but not executed. Only errors are
     * returned, not results.
     *
     * @generated from protobuf field: bool validate_only = 4;
     */
    validateOnly: boolean;
}
/**
 * Response message for
 * [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v11.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.UploadConversionAdjustmentsResponse
 */
export interface UploadConversionAdjustmentsResponse {
    /**
     * Errors that pertain to conversion adjustment failures in the partial
     * failure mode. Returned when all errors occur inside the adjustments. If any
     * errors occur outside the adjustments (for example, auth errors), we return
     * an RPC level error. See
     * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
     * for more information about partial failure.
     *
     * @generated from protobuf field: google.rpc.Status partial_failure_error = 1;
     */
    partialFailureError?: Status;
    /**
     * Returned for successfully processed conversion adjustments. Proto will be
     * empty for rows that received an error. Results are not returned when
     * validate_only is true.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ConversionAdjustmentResult results = 2;
     */
    results: ConversionAdjustmentResult[];
}
/**
 * A conversion adjustment.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ConversionAdjustment
 */
export interface ConversionAdjustment {
    /**
     * For adjustments, uniquely identifies a conversion that was reported
     * without an order ID specified. If the adjustment_type is ENHANCEMENT, this
     * value is optional but may be set in addition to the order_id.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.GclidDateTimePair gclid_date_time_pair = 12;
     */
    gclidDateTimePair?: GclidDateTimePair;
    /**
     * The order ID of the conversion to be adjusted. If the conversion was
     * reported with an order ID specified, that order ID must be used as the
     * identifier here. The order ID is required for enhancements.
     *
     * @generated from protobuf field: optional string order_id = 13;
     */
    orderId?: string;
    /**
     * Resource name of the conversion action associated with this conversion
     * adjustment. Note: Although this resource name consists of a customer id and
     * a conversion action id, validation will ignore the customer id and use the
     * conversion action id as the sole identifier of the conversion action.
     *
     * @generated from protobuf field: optional string conversion_action = 8;
     */
    conversionAction?: string;
    /**
     * The date time at which the adjustment occurred. Must be after the
     * conversion_date_time. The timezone must be specified. The format is
     * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
     *
     * @generated from protobuf field: optional string adjustment_date_time = 9;
     */
    adjustmentDateTime?: string;
    /**
     * The adjustment type.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType adjustment_type = 5;
     */
    adjustmentType: ConversionAdjustmentTypeEnum_ConversionAdjustmentType;
    /**
     * Information needed to restate the conversion's value.
     * Required for restatements. Should not be supplied for retractions. An error
     * will be returned if provided for a retraction.
     * NOTE: If you want to upload a second restatement with a different adjusted
     * value, it must have a new, more recent, adjustment occurrence time.
     * Otherwise, it will be treated as a duplicate of the previous restatement
     * and ignored.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.RestatementValue restatement_value = 6;
     */
    restatementValue?: RestatementValue;
    /**
     * The user identifiers to enhance the original conversion.
     * ConversionAdjustmentUploadService only accepts user identifiers in
     * enhancements. The maximum number of user identifiers for each
     * enhancement is 5.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.UserIdentifier user_identifiers = 10;
     */
    userIdentifiers: UserIdentifier[];
    /**
     * The user agent to enhance the original conversion. This can be found in
     * your user's HTTP request header when they convert on your web page.
     * Example, "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X)". User
     * agent can only be specified in enhancements with user identifiers. This
     * should match the user agent of the request that sent the original
     * conversion so the conversion and its enhancement are either both attributed
     * as same-device or both attributed as cross-device.
     *
     * @generated from protobuf field: optional string user_agent = 11;
     */
    userAgent?: string;
}
/**
 * Contains information needed to restate a conversion's value.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.RestatementValue
 */
export interface RestatementValue {
    /**
     * The restated conversion value. This is the value of the conversion after
     * restatement. For example, to change the value of a conversion from 100 to
     * 70, an adjusted value of 70 should be reported.
     * NOTE: If you want to upload a second restatement with a different adjusted
     * value, it must have a new, more recent, adjustment occurrence time.
     * Otherwise, it will be treated as a duplicate of the previous restatement
     * and ignored.
     *
     * @generated from protobuf field: optional double adjusted_value = 3;
     */
    adjustedValue?: number;
    /**
     * The currency of the restated value. If not provided, then the default
     * currency from the conversion action is used, and if that is not set then
     * the account currency is used. This is the ISO 4217 3-character currency
     * code for example, USD or EUR.
     *
     * @generated from protobuf field: optional string currency_code = 4;
     */
    currencyCode?: string;
}
/**
 * Uniquely identifies a conversion that was reported without an order ID
 * specified.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GclidDateTimePair
 */
export interface GclidDateTimePair {
    /**
     * Google click ID (gclid) associated with the original conversion for this
     * adjustment.
     *
     * @generated from protobuf field: optional string gclid = 3;
     */
    gclid?: string;
    /**
     * The date time at which the original conversion for this adjustment
     * occurred. The timezone must be specified. The format is "yyyy-mm-dd
     * hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
     *
     * @generated from protobuf field: optional string conversion_date_time = 4;
     */
    conversionDateTime?: string;
}
/**
 * Information identifying a successfully processed ConversionAdjustment.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ConversionAdjustmentResult
 */
export interface ConversionAdjustmentResult {
    /**
     * The gclid and conversion date time of the conversion.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.GclidDateTimePair gclid_date_time_pair = 9;
     */
    gclidDateTimePair?: GclidDateTimePair;
    /**
     * The order ID of the conversion to be adjusted.
     *
     * @generated from protobuf field: string order_id = 10;
     */
    orderId: string;
    /**
     * Resource name of the conversion action associated with this conversion
     * adjustment.
     *
     * @generated from protobuf field: optional string conversion_action = 7;
     */
    conversionAction?: string;
    /**
     * The date time at which the adjustment occurred. The format is
     * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
     *
     * @generated from protobuf field: optional string adjustment_date_time = 8;
     */
    adjustmentDateTime?: string;
    /**
     * The adjustment type.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType adjustment_type = 5;
     */
    adjustmentType: ConversionAdjustmentTypeEnum_ConversionAdjustmentType;
}
// @generated message type with reflection information, may provide speed optimized methods
class UploadConversionAdjustmentsRequest$Type extends MessageType<UploadConversionAdjustmentsRequest> {
    constructor() {
        super("google.ads.googleads.v11.services.UploadConversionAdjustmentsRequest", [
            { no: 1, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "conversion_adjustments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConversionAdjustment, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "partial_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "validate_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UploadConversionAdjustmentsRequest>): UploadConversionAdjustmentsRequest {
        const message = { customerId: "", conversionAdjustments: [], partialFailure: false, validateOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UploadConversionAdjustmentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadConversionAdjustmentsRequest): UploadConversionAdjustmentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string customer_id */ 1:
                    message.customerId = reader.string();
                    break;
                case /* repeated google.ads.googleads.v11.services.ConversionAdjustment conversion_adjustments */ 2:
                    message.conversionAdjustments.push(ConversionAdjustment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool partial_failure */ 3:
                    message.partialFailure = reader.bool();
                    break;
                case /* bool validate_only */ 4:
                    message.validateOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadConversionAdjustmentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string customer_id = 1; */
        if (message.customerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.customerId);
        /* repeated google.ads.googleads.v11.services.ConversionAdjustment conversion_adjustments = 2; */
        for (let i = 0; i < message.conversionAdjustments.length; i++)
            ConversionAdjustment.internalBinaryWrite(message.conversionAdjustments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool partial_failure = 3; */
        if (message.partialFailure !== false)
            writer.tag(3, WireType.Varint).bool(message.partialFailure);
        /* bool validate_only = 4; */
        if (message.validateOnly !== false)
            writer.tag(4, WireType.Varint).bool(message.validateOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.UploadConversionAdjustmentsRequest
 */
export const UploadConversionAdjustmentsRequest = new UploadConversionAdjustmentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadConversionAdjustmentsResponse$Type extends MessageType<UploadConversionAdjustmentsResponse> {
    constructor() {
        super("google.ads.googleads.v11.services.UploadConversionAdjustmentsResponse", [
            { no: 1, name: "partial_failure_error", kind: "message", T: () => Status },
            { no: 2, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConversionAdjustmentResult }
        ]);
    }
    create(value?: PartialMessage<UploadConversionAdjustmentsResponse>): UploadConversionAdjustmentsResponse {
        const message = { results: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UploadConversionAdjustmentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadConversionAdjustmentsResponse): UploadConversionAdjustmentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status partial_failure_error */ 1:
                    message.partialFailureError = Status.internalBinaryRead(reader, reader.uint32(), options, message.partialFailureError);
                    break;
                case /* repeated google.ads.googleads.v11.services.ConversionAdjustmentResult results */ 2:
                    message.results.push(ConversionAdjustmentResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadConversionAdjustmentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status partial_failure_error = 1; */
        if (message.partialFailureError)
            Status.internalBinaryWrite(message.partialFailureError, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.services.ConversionAdjustmentResult results = 2; */
        for (let i = 0; i < message.results.length; i++)
            ConversionAdjustmentResult.internalBinaryWrite(message.results[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.UploadConversionAdjustmentsResponse
 */
export const UploadConversionAdjustmentsResponse = new UploadConversionAdjustmentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConversionAdjustment$Type extends MessageType<ConversionAdjustment> {
    constructor() {
        super("google.ads.googleads.v11.services.ConversionAdjustment", [
            { no: 12, name: "gclid_date_time_pair", kind: "message", T: () => GclidDateTimePair },
            { no: 13, name: "order_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "conversion_action", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "adjustment_date_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "adjustment_type", kind: "enum", T: () => ["google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType", ConversionAdjustmentTypeEnum_ConversionAdjustmentType] },
            { no: 6, name: "restatement_value", kind: "message", T: () => RestatementValue },
            { no: 10, name: "user_identifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserIdentifier },
            { no: 11, name: "user_agent", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConversionAdjustment>): ConversionAdjustment {
        const message = { adjustmentType: 0, userIdentifiers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConversionAdjustment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConversionAdjustment): ConversionAdjustment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.ads.googleads.v11.services.GclidDateTimePair gclid_date_time_pair */ 12:
                    message.gclidDateTimePair = GclidDateTimePair.internalBinaryRead(reader, reader.uint32(), options, message.gclidDateTimePair);
                    break;
                case /* optional string order_id */ 13:
                    message.orderId = reader.string();
                    break;
                case /* optional string conversion_action */ 8:
                    message.conversionAction = reader.string();
                    break;
                case /* optional string adjustment_date_time */ 9:
                    message.adjustmentDateTime = reader.string();
                    break;
                case /* google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType adjustment_type */ 5:
                    message.adjustmentType = reader.int32();
                    break;
                case /* google.ads.googleads.v11.services.RestatementValue restatement_value */ 6:
                    message.restatementValue = RestatementValue.internalBinaryRead(reader, reader.uint32(), options, message.restatementValue);
                    break;
                case /* repeated google.ads.googleads.v11.common.UserIdentifier user_identifiers */ 10:
                    message.userIdentifiers.push(UserIdentifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string user_agent */ 11:
                    message.userAgent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConversionAdjustment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.ads.googleads.v11.services.GclidDateTimePair gclid_date_time_pair = 12; */
        if (message.gclidDateTimePair)
            GclidDateTimePair.internalBinaryWrite(message.gclidDateTimePair, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional string order_id = 13; */
        if (message.orderId !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.orderId);
        /* optional string conversion_action = 8; */
        if (message.conversionAction !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.conversionAction);
        /* optional string adjustment_date_time = 9; */
        if (message.adjustmentDateTime !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.adjustmentDateTime);
        /* google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType adjustment_type = 5; */
        if (message.adjustmentType !== 0)
            writer.tag(5, WireType.Varint).int32(message.adjustmentType);
        /* google.ads.googleads.v11.services.RestatementValue restatement_value = 6; */
        if (message.restatementValue)
            RestatementValue.internalBinaryWrite(message.restatementValue, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.ads.googleads.v11.common.UserIdentifier user_identifiers = 10; */
        for (let i = 0; i < message.userIdentifiers.length; i++)
            UserIdentifier.internalBinaryWrite(message.userIdentifiers[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional string user_agent = 11; */
        if (message.userAgent !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.userAgent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ConversionAdjustment
 */
export const ConversionAdjustment = new ConversionAdjustment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestatementValue$Type extends MessageType<RestatementValue> {
    constructor() {
        super("google.ads.googleads.v11.services.RestatementValue", [
            { no: 3, name: "adjusted_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RestatementValue>): RestatementValue {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RestatementValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestatementValue): RestatementValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double adjusted_value */ 3:
                    message.adjustedValue = reader.double();
                    break;
                case /* optional string currency_code */ 4:
                    message.currencyCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestatementValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double adjusted_value = 3; */
        if (message.adjustedValue !== undefined)
            writer.tag(3, WireType.Bit64).double(message.adjustedValue);
        /* optional string currency_code = 4; */
        if (message.currencyCode !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.currencyCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.RestatementValue
 */
export const RestatementValue = new RestatementValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GclidDateTimePair$Type extends MessageType<GclidDateTimePair> {
    constructor() {
        super("google.ads.googleads.v11.services.GclidDateTimePair", [
            { no: 3, name: "gclid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "conversion_date_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GclidDateTimePair>): GclidDateTimePair {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GclidDateTimePair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GclidDateTimePair): GclidDateTimePair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string gclid */ 3:
                    message.gclid = reader.string();
                    break;
                case /* optional string conversion_date_time */ 4:
                    message.conversionDateTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GclidDateTimePair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string gclid = 3; */
        if (message.gclid !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.gclid);
        /* optional string conversion_date_time = 4; */
        if (message.conversionDateTime !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.conversionDateTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GclidDateTimePair
 */
export const GclidDateTimePair = new GclidDateTimePair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConversionAdjustmentResult$Type extends MessageType<ConversionAdjustmentResult> {
    constructor() {
        super("google.ads.googleads.v11.services.ConversionAdjustmentResult", [
            { no: 9, name: "gclid_date_time_pair", kind: "message", T: () => GclidDateTimePair },
            { no: 10, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "conversion_action", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "adjustment_date_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "adjustment_type", kind: "enum", T: () => ["google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType", ConversionAdjustmentTypeEnum_ConversionAdjustmentType] }
        ]);
    }
    create(value?: PartialMessage<ConversionAdjustmentResult>): ConversionAdjustmentResult {
        const message = { orderId: "", adjustmentType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConversionAdjustmentResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConversionAdjustmentResult): ConversionAdjustmentResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.ads.googleads.v11.services.GclidDateTimePair gclid_date_time_pair */ 9:
                    message.gclidDateTimePair = GclidDateTimePair.internalBinaryRead(reader, reader.uint32(), options, message.gclidDateTimePair);
                    break;
                case /* string order_id */ 10:
                    message.orderId = reader.string();
                    break;
                case /* optional string conversion_action */ 7:
                    message.conversionAction = reader.string();
                    break;
                case /* optional string adjustment_date_time */ 8:
                    message.adjustmentDateTime = reader.string();
                    break;
                case /* google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType adjustment_type */ 5:
                    message.adjustmentType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConversionAdjustmentResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.ads.googleads.v11.services.GclidDateTimePair gclid_date_time_pair = 9; */
        if (message.gclidDateTimePair)
            GclidDateTimePair.internalBinaryWrite(message.gclidDateTimePair, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string order_id = 10; */
        if (message.orderId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.orderId);
        /* optional string conversion_action = 7; */
        if (message.conversionAction !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.conversionAction);
        /* optional string adjustment_date_time = 8; */
        if (message.adjustmentDateTime !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.adjustmentDateTime);
        /* google.ads.googleads.v11.enums.ConversionAdjustmentTypeEnum.ConversionAdjustmentType adjustment_type = 5; */
        if (message.adjustmentType !== 0)
            writer.tag(5, WireType.Varint).int32(message.adjustmentType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ConversionAdjustmentResult
 */
export const ConversionAdjustmentResult = new ConversionAdjustmentResult$Type();
/**
 * @generated ServiceType for protobuf service google.ads.googleads.v11.services.ConversionAdjustmentUploadService
 */
export const ConversionAdjustmentUploadService = new ServiceType("google.ads.googleads.v11.services.ConversionAdjustmentUploadService", [
    { name: "UploadConversionAdjustments", options: { "google.api.http": { post: "/v11/customers/{customer_id=*}:uploadConversionAdjustments", body: "*" }, "google.api.method_signature": ["customer_id,conversion_adjustments,partial_failure"] }, I: UploadConversionAdjustmentsRequest, O: UploadConversionAdjustmentsResponse }
], { "google.api.default_host": "googleads.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/adwords" });
