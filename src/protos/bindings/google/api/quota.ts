// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/api/quota.proto" (package "google.api", syntax proto3)
// tslint:disable
//
// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Quota configuration helps to achieve fairness and budgeting in service
 * usage.
 *
 * The metric based quota configuration works this way:
 * - The service configuration defines a set of metrics.
 * - For API calls, the quota.metric_rules maps methods to metrics with
 *   corresponding costs.
 * - The quota.limits defines limits on the metrics, which will be used for
 *   quota checks at runtime.
 *
 * An example quota configuration in yaml format:
 *
 *    quota:
 *      limits:
 *
 *      - name: apiWriteQpsPerProject
 *        metric: library.googleapis.com/write_calls
 *        unit: "1/min/{project}"  # rate limit for consumer projects
 *        values:
 *          STANDARD: 10000
 *
 *
 *      # The metric rules bind all methods to the read_calls metric,
 *      # except for the UpdateBook and DeleteBook methods. These two methods
 *      # are mapped to the write_calls metric, with the UpdateBook method
 *      # consuming at twice rate as the DeleteBook method.
 *      metric_rules:
 *      - selector: "*"
 *        metric_costs:
 *          library.googleapis.com/read_calls: 1
 *      - selector: google.example.library.v1.LibraryService.UpdateBook
 *        metric_costs:
 *          library.googleapis.com/write_calls: 2
 *      - selector: google.example.library.v1.LibraryService.DeleteBook
 *        metric_costs:
 *          library.googleapis.com/write_calls: 1
 *
 *  Corresponding Metric definition:
 *
 *      metrics:
 *      - name: library.googleapis.com/read_calls
 *        display_name: Read requests
 *        metric_kind: DELTA
 *        value_type: INT64
 *
 *      - name: library.googleapis.com/write_calls
 *        display_name: Write requests
 *        metric_kind: DELTA
 *        value_type: INT64
 *
 *
 *
 * @generated from protobuf message google.api.Quota
 */
export interface Quota {
    /**
     * List of `QuotaLimit` definitions for the service.
     *
     * @generated from protobuf field: repeated google.api.QuotaLimit limits = 3;
     */
    limits: QuotaLimit[];
    /**
     * List of `MetricRule` definitions, each one mapping a selected method to one
     * or more metrics.
     *
     * @generated from protobuf field: repeated google.api.MetricRule metric_rules = 4;
     */
    metricRules: MetricRule[];
}
/**
 * Bind API methods to metrics. Binding a method to a metric causes that
 * metric's configured quota behaviors to apply to the method call.
 *
 * @generated from protobuf message google.api.MetricRule
 */
export interface MetricRule {
    /**
     * Selects the methods to which this rule applies.
     *
     * Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
     *
     * @generated from protobuf field: string selector = 1;
     */
    selector: string;
    /**
     * Metrics to update when the selected methods are called, and the associated
     * cost applied to each metric.
     *
     * The key of the map is the metric name, and the values are the amount
     * increased for the metric against which the quota limits are defined.
     * The value must not be negative.
     *
     * @generated from protobuf field: map<string, int64> metric_costs = 2;
     */
    metricCosts: {
        [key: string]: bigint;
    };
}
/**
 * `QuotaLimit` defines a specific limit that applies over a specified duration
 * for a limit type. There can be at most one limit for a duration and limit
 * type combination defined within a `QuotaGroup`.
 *
 * @generated from protobuf message google.api.QuotaLimit
 */
export interface QuotaLimit {
    /**
     * Name of the quota limit.
     *
     * The name must be provided, and it must be unique within the service. The
     * name can only include alphanumeric characters as well as '-'.
     *
     * The maximum length of the limit name is 64 characters.
     *
     * @generated from protobuf field: string name = 6;
     */
    name: string;
    /**
     * Optional. User-visible, extended description for this quota limit.
     * Should be used only when more context is needed to understand this limit
     * than provided by the limit's display name (see: `display_name`).
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * Default number of tokens that can be consumed during the specified
     * duration. This is the number of tokens assigned when a client
     * application developer activates the service for his/her project.
     *
     * Specifying a value of 0 will block all requests. This can be used if you
     * are provisioning quota to selected consumers and blocking others.
     * Similarly, a value of -1 will indicate an unlimited quota. No other
     * negative values are allowed.
     *
     * Used by group-based quotas only.
     *
     * @generated from protobuf field: int64 default_limit = 3;
     */
    defaultLimit: bigint;
    /**
     * Maximum number of tokens that can be consumed during the specified
     * duration. Client application developers can override the default limit up
     * to this maximum. If specified, this value cannot be set to a value less
     * than the default limit. If not specified, it is set to the default limit.
     *
     * To allow clients to apply overrides with no upper bound, set this to -1,
     * indicating unlimited maximum quota.
     *
     * Used by group-based quotas only.
     *
     * @generated from protobuf field: int64 max_limit = 4;
     */
    maxLimit: bigint;
    /**
     * Free tier value displayed in the Developers Console for this limit.
     * The free tier is the number of tokens that will be subtracted from the
     * billed amount when billing is enabled.
     * This field can only be set on a limit with duration "1d", in a billable
     * group; it is invalid on any other limit. If this field is not set, it
     * defaults to 0, indicating that there is no free tier for this service.
     *
     * Used by group-based quotas only.
     *
     * @generated from protobuf field: int64 free_tier = 7;
     */
    freeTier: bigint;
    /**
     * Duration of this limit in textual notation. Must be "100s" or "1d".
     *
     * Used by group-based quotas only.
     *
     * @generated from protobuf field: string duration = 5;
     */
    duration: string;
    /**
     * The name of the metric this quota limit applies to. The quota limits with
     * the same metric will be checked together during runtime. The metric must be
     * defined within the service config.
     *
     * @generated from protobuf field: string metric = 8;
     */
    metric: string;
    /**
     * Specify the unit of the quota limit. It uses the same syntax as
     * [Metric.unit][]. The supported unit kinds are determined by the quota
     * backend system.
     *
     * Here are some examples:
     * * "1/min/{project}" for quota per minute per project.
     *
     * Note: the order of unit components is insignificant.
     * The "1" at the beginning is required to follow the metric unit syntax.
     *
     * @generated from protobuf field: string unit = 9;
     */
    unit: string;
    /**
     * Tiered limit values. You must specify this as a key:value pair, with an
     * integer value that is the maximum number of requests allowed for the
     * specified unit. Currently only STANDARD is supported.
     *
     * @generated from protobuf field: map<string, int64> values = 10;
     */
    values: {
        [key: string]: bigint;
    };
    /**
     * User-visible display name for this limit.
     * Optional. If not set, the UI will provide a default display name based on
     * the quota configuration. This field can be used to override the default
     * display name generated from the configuration.
     *
     * @generated from protobuf field: string display_name = 12;
     */
    displayName: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Quota$Type extends MessageType<Quota> {
    constructor() {
        super("google.api.Quota", [
            { no: 3, name: "limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuotaLimit },
            { no: 4, name: "metric_rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetricRule }
        ]);
    }
    create(value?: PartialMessage<Quota>): Quota {
        const message = { limits: [], metricRules: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Quota>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quota): Quota {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.api.QuotaLimit limits */ 3:
                    message.limits.push(QuotaLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.api.MetricRule metric_rules */ 4:
                    message.metricRules.push(MetricRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quota, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.api.QuotaLimit limits = 3; */
        for (let i = 0; i < message.limits.length; i++)
            QuotaLimit.internalBinaryWrite(message.limits[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.MetricRule metric_rules = 4; */
        for (let i = 0; i < message.metricRules.length; i++)
            MetricRule.internalBinaryWrite(message.metricRules[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.Quota
 */
export const Quota = new Quota$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricRule$Type extends MessageType<MetricRule> {
    constructor() {
        super("google.api.MetricRule", [
            { no: 1, name: "selector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metric_costs", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<MetricRule>): MetricRule {
        const message = { selector: "", metricCosts: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MetricRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricRule): MetricRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string selector */ 1:
                    message.selector = reader.string();
                    break;
                case /* map<string, int64> metric_costs */ 2:
                    this.binaryReadMap2(message.metricCosts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: MetricRule["metricCosts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MetricRule["metricCosts"] | undefined, val: MetricRule["metricCosts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.MetricRule.metric_costs");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: MetricRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string selector = 1; */
        if (message.selector !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.selector);
        /* map<string, int64> metric_costs = 2; */
        for (let k of Object.keys(message.metricCosts))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.metricCosts[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.MetricRule
 */
export const MetricRule = new MetricRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaLimit$Type extends MessageType<QuotaLimit> {
    constructor() {
        super("google.api.QuotaLimit", [
            { no: 6, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "default_limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "max_limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "free_tier", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "duration", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "metric", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "values", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } },
            { no: 12, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuotaLimit>): QuotaLimit {
        const message = { name: "", description: "", defaultLimit: 0n, maxLimit: 0n, freeTier: 0n, duration: "", metric: "", unit: "", values: {}, displayName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuotaLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaLimit): QuotaLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 6:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* int64 default_limit */ 3:
                    message.defaultLimit = reader.int64().toBigInt();
                    break;
                case /* int64 max_limit */ 4:
                    message.maxLimit = reader.int64().toBigInt();
                    break;
                case /* int64 free_tier */ 7:
                    message.freeTier = reader.int64().toBigInt();
                    break;
                case /* string duration */ 5:
                    message.duration = reader.string();
                    break;
                case /* string metric */ 8:
                    message.metric = reader.string();
                    break;
                case /* string unit */ 9:
                    message.unit = reader.string();
                    break;
                case /* map<string, int64> values */ 10:
                    this.binaryReadMap10(message.values, reader, options);
                    break;
                case /* string display_name */ 12:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: QuotaLimit["values"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QuotaLimit["values"] | undefined, val: QuotaLimit["values"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.QuotaLimit.values");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: QuotaLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 6; */
        if (message.name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* int64 default_limit = 3; */
        if (message.defaultLimit !== 0n)
            writer.tag(3, WireType.Varint).int64(message.defaultLimit);
        /* int64 max_limit = 4; */
        if (message.maxLimit !== 0n)
            writer.tag(4, WireType.Varint).int64(message.maxLimit);
        /* int64 free_tier = 7; */
        if (message.freeTier !== 0n)
            writer.tag(7, WireType.Varint).int64(message.freeTier);
        /* string duration = 5; */
        if (message.duration !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.duration);
        /* string metric = 8; */
        if (message.metric !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.metric);
        /* string unit = 9; */
        if (message.unit !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.unit);
        /* map<string, int64> values = 10; */
        for (let k of Object.keys(message.values))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.values[k]).join();
        /* string display_name = 12; */
        if (message.displayName !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.QuotaLimit
 */
export const QuotaLimit = new QuotaLimit$Type();
