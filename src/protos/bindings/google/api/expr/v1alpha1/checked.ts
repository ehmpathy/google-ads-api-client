// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/api/expr/v1alpha1/checked.proto" (package "google.api.expr.v1alpha1", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Constant } from "./syntax";
import { NullValue } from "../../../protobuf/struct";
import { Empty } from "../../../protobuf/empty";
import { Expr } from "./syntax";
import { SourceInfo } from "./syntax";
// Protos for representing CEL declarations and typed checked expressions.

/**
 * A CEL expression which has been successfully type checked.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.CheckedExpr
 */
export interface CheckedExpr {
    /**
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     *
     * @generated from protobuf field: map<int64, google.api.expr.v1alpha1.Reference> reference_map = 2;
     */
    referenceMap: {
        [key: string]: Reference;
    };
    /**
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     *
     * @generated from protobuf field: map<int64, google.api.expr.v1alpha1.Type> type_map = 3;
     */
    typeMap: {
        [key: string]: Type;
    };
    /**
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.SourceInfo source_info = 5;
     */
    sourceInfo?: SourceInfo;
    /**
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     *
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     *
     * @generated from protobuf field: string expr_version = 6;
     */
    exprVersion: string;
    /**
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr expr = 4;
     */
    expr?: Expr;
}
/**
 * Represents a CEL type.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Type
 */
export interface Type {
    /**
     * @generated from protobuf oneof: type_kind
     */
    typeKind: {
        oneofKind: "dyn";
        /**
         * Dynamic type.
         *
         * @generated from protobuf field: google.protobuf.Empty dyn = 1;
         */
        dyn: Empty;
    } | {
        oneofKind: "null";
        /**
         * Null value.
         *
         * @generated from protobuf field: google.protobuf.NullValue null = 2;
         */
        null: NullValue;
    } | {
        oneofKind: "primitive";
        /**
         * Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.PrimitiveType primitive = 3;
         */
        primitive: Type_PrimitiveType;
    } | {
        oneofKind: "wrapper";
        /**
         * Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.PrimitiveType wrapper = 4;
         */
        wrapper: Type_PrimitiveType;
    } | {
        oneofKind: "wellKnown";
        /**
         * Well-known protobuf type such as `google.protobuf.Timestamp`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.WellKnownType well_known = 5;
         */
        wellKnown: Type_WellKnownType;
    } | {
        oneofKind: "listType";
        /**
         * Parameterized list with elements of `list_type`, e.g. `list<timestamp>`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.ListType list_type = 6;
         */
        listType: Type_ListType;
    } | {
        oneofKind: "mapType";
        /**
         * Parameterized map with typed keys and values.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.MapType map_type = 7;
         */
        mapType: Type_MapType;
    } | {
        oneofKind: "function";
        /**
         * Function type.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.FunctionType function = 8;
         */
        function: Type_FunctionType;
    } | {
        oneofKind: "messageType";
        /**
         * Protocol buffer message type.
         *
         * The `message_type` string specifies the qualified message type name. For
         * example, `google.plus.Profile`.
         *
         * @generated from protobuf field: string message_type = 9;
         */
        messageType: string;
    } | {
        oneofKind: "typeParam";
        /**
         * Type param type.
         *
         * The `type_param` string specifies the type parameter name, e.g. `list<E>`
         * would be a `list_type` whose element type was a `type_param` type
         * named `E`.
         *
         * @generated from protobuf field: string type_param = 10;
         */
        typeParam: string;
    } | {
        oneofKind: "type";
        /**
         * Type type.
         *
         * The `type` value specifies the target type. e.g. int is type with a
         * target type of `Primitive.INT`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type type = 11;
         */
        type: Type;
    } | {
        oneofKind: "error";
        /**
         * Error type.
         *
         * During type-checking if an expression is an error, its type is propagated
         * as the `ERROR` type. This permits the type-checker to discover other
         * errors present in the expression.
         *
         * @generated from protobuf field: google.protobuf.Empty error = 12;
         */
        error: Empty;
    } | {
        oneofKind: "abstractType";
        /**
         * Abstract, application defined type.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Type.AbstractType abstract_type = 14;
         */
        abstractType: Type_AbstractType;
    } | {
        oneofKind: undefined;
    };
}
/**
 * List type with typed elements, e.g. `list<example.proto.MyMessage>`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Type.ListType
 */
export interface Type_ListType {
    /**
     * The element type.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Type elem_type = 1;
     */
    elemType?: Type;
}
/**
 * Map type with parameterized key and value types, e.g. `map<string, int>`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Type.MapType
 */
export interface Type_MapType {
    /**
     * The type of the key.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Type key_type = 1;
     */
    keyType?: Type;
    /**
     * The type of the value.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Type value_type = 2;
     */
    valueType?: Type;
}
/**
 * Function type with result and arg types.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Type.FunctionType
 */
export interface Type_FunctionType {
    /**
     * Result type of the function.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Type result_type = 1;
     */
    resultType?: Type;
    /**
     * Argument types of the function.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Type arg_types = 2;
     */
    argTypes: Type[];
}
/**
 * Application defined abstract type.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Type.AbstractType
 */
export interface Type_AbstractType {
    /**
     * The fully qualified name of this abstract type.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Parameter types for this abstract type.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Type parameter_types = 2;
     */
    parameterTypes: Type[];
}
/**
 * CEL primitive types.
 *
 * @generated from protobuf enum google.api.expr.v1alpha1.Type.PrimitiveType
 */
export enum Type_PrimitiveType {
    /**
     * Unspecified type.
     *
     * @generated from protobuf enum value: PRIMITIVE_TYPE_UNSPECIFIED = 0;
     */
    PRIMITIVE_TYPE_UNSPECIFIED = 0,
    /**
     * Boolean type.
     *
     * @generated from protobuf enum value: BOOL = 1;
     */
    BOOL = 1,
    /**
     * Int64 type.
     *
     * Proto-based integer values are widened to int64.
     *
     * @generated from protobuf enum value: INT64 = 2;
     */
    INT64 = 2,
    /**
     * Uint64 type.
     *
     * Proto-based unsigned integer values are widened to uint64.
     *
     * @generated from protobuf enum value: UINT64 = 3;
     */
    UINT64 = 3,
    /**
     * Double type.
     *
     * Proto-based float values are widened to double values.
     *
     * @generated from protobuf enum value: DOUBLE = 4;
     */
    DOUBLE = 4,
    /**
     * String type.
     *
     * @generated from protobuf enum value: STRING = 5;
     */
    STRING = 5,
    /**
     * Bytes type.
     *
     * @generated from protobuf enum value: BYTES = 6;
     */
    BYTES = 6
}
/**
 * Well-known protobuf types treated with first-class support in CEL.
 *
 * @generated from protobuf enum google.api.expr.v1alpha1.Type.WellKnownType
 */
export enum Type_WellKnownType {
    /**
     * Unspecified type.
     *
     * @generated from protobuf enum value: WELL_KNOWN_TYPE_UNSPECIFIED = 0;
     */
    WELL_KNOWN_TYPE_UNSPECIFIED = 0,
    /**
     * Well-known protobuf.Any type.
     *
     * Any types are a polymorphic message type. During type-checking they are
     * treated like `DYN` types, but at runtime they are resolved to a specific
     * message type specified at evaluation time.
     *
     * @generated from protobuf enum value: ANY = 1;
     */
    ANY = 1,
    /**
     * Well-known protobuf.Timestamp type, internally referenced as `timestamp`.
     *
     * @generated from protobuf enum value: TIMESTAMP = 2;
     */
    TIMESTAMP = 2,
    /**
     * Well-known protobuf.Duration type, internally referenced as `duration`.
     *
     * @generated from protobuf enum value: DURATION = 3;
     */
    DURATION = 3
}
/**
 * Represents a declaration of a named value or function.
 *
 * A declaration is part of the contract between the expression, the agent
 * evaluating that expression, and the caller requesting evaluation.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Decl
 */
export interface Decl {
    /**
     * The fully qualified name of the declaration.
     *
     * Declarations are organized in containers and this represents the full path
     * to the declaration in its container, as in `google.api.expr.Decl`.
     *
     * Declarations used as
     * [FunctionDecl.Overload][google.api.expr.v1alpha1.Decl.FunctionDecl.Overload]
     * parameters may or may not have a name depending on whether the overload is
     * function declaration or a function definition containing a result
     * [Expr][google.api.expr.v1alpha1.Expr].
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: decl_kind
     */
    declKind: {
        oneofKind: "ident";
        /**
         * Identifier declaration.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Decl.IdentDecl ident = 2;
         */
        ident: Decl_IdentDecl;
    } | {
        oneofKind: "function";
        /**
         * Function declaration.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Decl.FunctionDecl function = 3;
         */
        function: Decl_FunctionDecl;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Identifier declaration which specifies its type and optional `Expr` value.
 *
 * An identifier without a value is a declaration that must be provided at
 * evaluation time. An identifier with a value should resolve to a constant,
 * but may be used in conjunction with other identifiers bound at evaluation
 * time.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Decl.IdentDecl
 */
export interface Decl_IdentDecl {
    /**
     * Required. The type of the identifier.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Type type = 1;
     */
    type?: Type;
    /**
     * The constant value of the identifier. If not specified, the identifier
     * must be supplied at evaluation time.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Constant value = 2;
     */
    value?: Constant;
    /**
     * Documentation string for the identifier.
     *
     * @generated from protobuf field: string doc = 3;
     */
    doc: string;
}
/**
 * Function declaration specifies one or more overloads which indicate the
 * function's parameter types and return type.
 *
 * Functions have no observable side-effects (there may be side-effects like
 * logging which are not observable from CEL).
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Decl.FunctionDecl
 */
export interface Decl_FunctionDecl {
    /**
     * Required. List of function overloads, must contain at least one overload.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Decl.FunctionDecl.Overload overloads = 1;
     */
    overloads: Decl_FunctionDecl_Overload[];
}
/**
 * An overload indicates a function's parameter types and return type, and
 * may optionally include a function body described in terms of
 * [Expr][google.api.expr.v1alpha1.Expr] values.
 *
 * Functions overloads are declared in either a function or method
 * call-style. For methods, the `params[0]` is the expected type of the
 * target receiver.
 *
 * Overloads must have non-overlapping argument types after erasure of all
 * parameterized type variables (similar as type erasure in Java).
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Decl.FunctionDecl.Overload
 */
export interface Decl_FunctionDecl_Overload {
    /**
     * Required. Globally unique overload name of the function which reflects
     * the function name and argument types.
     *
     * This will be used by a [Reference][google.api.expr.v1alpha1.Reference]
     * to indicate the `overload_id` that was resolved for the function
     * `name`.
     *
     * @generated from protobuf field: string overload_id = 1;
     */
    overloadId: string;
    /**
     * List of function parameter [Type][google.api.expr.v1alpha1.Type]
     * values.
     *
     * Param types are disjoint after generic type parameters have been
     * replaced with the type `DYN`. Since the `DYN` type is compatible with
     * any other type, this means that if `A` is a type parameter, the
     * function types `int<A>` and `int<int>` are not disjoint. Likewise,
     * `map<string, string>` is not disjoint from `map<K, V>`.
     *
     * When the `result_type` of a function is a generic type param, the
     * type param name also appears as the `type` of on at least one params.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Type params = 2;
     */
    params: Type[];
    /**
     * The type param names associated with the function declaration.
     *
     * For example, `function ex<K,V>(K key, map<K, V> map) : V` would yield
     * the type params of `K, V`.
     *
     * @generated from protobuf field: repeated string type_params = 3;
     */
    typeParams: string[];
    /**
     * Required. The result type of the function. For example, the operator
     * `string.isEmpty()` would have `result_type` of `kind: BOOL`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Type result_type = 4;
     */
    resultType?: Type;
    /**
     * Whether the function is to be used in a method call-style `x.f(...)`
     * or a function call-style `f(x, ...)`.
     *
     * For methods, the first parameter declaration, `params[0]` is the
     * expected type of the target receiver.
     *
     * @generated from protobuf field: bool is_instance_function = 5;
     */
    isInstanceFunction: boolean;
    /**
     * Documentation string for the overload.
     *
     * @generated from protobuf field: string doc = 6;
     */
    doc: string;
}
/**
 * Describes a resolved reference to a declaration.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Reference
 */
export interface Reference {
    /**
     * The fully qualified name of the declaration.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * For references to functions, this is a list of `Overload.overload_id`
     * values which match according to typing rules.
     *
     * If the list has more than one element, overload resolution among the
     * presented candidates must happen at runtime because of dynamic types. The
     * type checker attempts to narrow down this list as much as possible.
     *
     * Empty if this is not a reference to a
     * [Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl].
     *
     * @generated from protobuf field: repeated string overload_id = 3;
     */
    overloadId: string[];
    /**
     * For references to constants, this may contain the value of the
     * constant if known at compile time.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Constant value = 4;
     */
    value?: Constant;
}
// @generated message type with reflection information, may provide speed optimized methods
class CheckedExpr$Type extends MessageType<CheckedExpr> {
    constructor() {
        super("google.api.expr.v1alpha1.CheckedExpr", [
            { no: 2, name: "reference_map", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => Reference } },
            { no: 3, name: "type_map", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => Type } },
            { no: 5, name: "source_info", kind: "message", T: () => SourceInfo },
            { no: 6, name: "expr_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expr", kind: "message", T: () => Expr }
        ]);
    }
    create(value?: PartialMessage<CheckedExpr>): CheckedExpr {
        const message = { referenceMap: {}, typeMap: {}, exprVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckedExpr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckedExpr): CheckedExpr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int64, google.api.expr.v1alpha1.Reference> reference_map */ 2:
                    this.binaryReadMap2(message.referenceMap, reader, options);
                    break;
                case /* map<int64, google.api.expr.v1alpha1.Type> type_map */ 3:
                    this.binaryReadMap3(message.typeMap, reader, options);
                    break;
                case /* google.api.expr.v1alpha1.SourceInfo source_info */ 5:
                    message.sourceInfo = SourceInfo.internalBinaryRead(reader, reader.uint32(), options, message.sourceInfo);
                    break;
                case /* string expr_version */ 6:
                    message.exprVersion = reader.string();
                    break;
                case /* google.api.expr.v1alpha1.Expr expr */ 4:
                    message.expr = Expr.internalBinaryRead(reader, reader.uint32(), options, message.expr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: CheckedExpr["referenceMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CheckedExpr["referenceMap"] | undefined, val: CheckedExpr["referenceMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = Reference.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.expr.v1alpha1.CheckedExpr.reference_map");
            }
        }
        map[key ?? "0"] = val ?? Reference.create();
    }
    private binaryReadMap3(map: CheckedExpr["typeMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CheckedExpr["typeMap"] | undefined, val: CheckedExpr["typeMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = Type.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.expr.v1alpha1.CheckedExpr.type_map");
            }
        }
        map[key ?? "0"] = val ?? Type.create();
    }
    internalBinaryWrite(message: CheckedExpr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int64, google.api.expr.v1alpha1.Reference> reference_map = 2; */
        for (let k of Object.keys(message.referenceMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Reference.internalBinaryWrite(message.referenceMap[k], writer, options);
            writer.join().join();
        }
        /* map<int64, google.api.expr.v1alpha1.Type> type_map = 3; */
        for (let k of Object.keys(message.typeMap)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Type.internalBinaryWrite(message.typeMap[k], writer, options);
            writer.join().join();
        }
        /* google.api.expr.v1alpha1.SourceInfo source_info = 5; */
        if (message.sourceInfo)
            SourceInfo.internalBinaryWrite(message.sourceInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string expr_version = 6; */
        if (message.exprVersion !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.exprVersion);
        /* google.api.expr.v1alpha1.Expr expr = 4; */
        if (message.expr)
            Expr.internalBinaryWrite(message.expr, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.CheckedExpr
 */
export const CheckedExpr = new CheckedExpr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type$Type extends MessageType<Type> {
    constructor() {
        super("google.api.expr.v1alpha1.Type", [
            { no: 1, name: "dyn", kind: "message", oneof: "typeKind", T: () => Empty },
            { no: 2, name: "null", kind: "enum", oneof: "typeKind", T: () => ["google.protobuf.NullValue", NullValue] },
            { no: 3, name: "primitive", kind: "enum", oneof: "typeKind", T: () => ["google.api.expr.v1alpha1.Type.PrimitiveType", Type_PrimitiveType] },
            { no: 4, name: "wrapper", kind: "enum", oneof: "typeKind", T: () => ["google.api.expr.v1alpha1.Type.PrimitiveType", Type_PrimitiveType] },
            { no: 5, name: "well_known", kind: "enum", oneof: "typeKind", T: () => ["google.api.expr.v1alpha1.Type.WellKnownType", Type_WellKnownType] },
            { no: 6, name: "list_type", kind: "message", oneof: "typeKind", T: () => Type_ListType },
            { no: 7, name: "map_type", kind: "message", oneof: "typeKind", T: () => Type_MapType },
            { no: 8, name: "function", kind: "message", oneof: "typeKind", T: () => Type_FunctionType },
            { no: 9, name: "message_type", kind: "scalar", oneof: "typeKind", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "type_param", kind: "scalar", oneof: "typeKind", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "type", kind: "message", oneof: "typeKind", T: () => Type },
            { no: 12, name: "error", kind: "message", oneof: "typeKind", T: () => Empty },
            { no: 14, name: "abstract_type", kind: "message", oneof: "typeKind", T: () => Type_AbstractType }
        ]);
    }
    create(value?: PartialMessage<Type>): Type {
        const message = { typeKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type): Type {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Empty dyn */ 1:
                    message.typeKind = {
                        oneofKind: "dyn",
                        dyn: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).dyn)
                    };
                    break;
                case /* google.protobuf.NullValue null */ 2:
                    message.typeKind = {
                        oneofKind: "null",
                        null: reader.int32()
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.PrimitiveType primitive */ 3:
                    message.typeKind = {
                        oneofKind: "primitive",
                        primitive: reader.int32()
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.PrimitiveType wrapper */ 4:
                    message.typeKind = {
                        oneofKind: "wrapper",
                        wrapper: reader.int32()
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.WellKnownType well_known */ 5:
                    message.typeKind = {
                        oneofKind: "wellKnown",
                        wellKnown: reader.int32()
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.ListType list_type */ 6:
                    message.typeKind = {
                        oneofKind: "listType",
                        listType: Type_ListType.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).listType)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.MapType map_type */ 7:
                    message.typeKind = {
                        oneofKind: "mapType",
                        mapType: Type_MapType.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).mapType)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.FunctionType function */ 8:
                    message.typeKind = {
                        oneofKind: "function",
                        function: Type_FunctionType.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).function)
                    };
                    break;
                case /* string message_type */ 9:
                    message.typeKind = {
                        oneofKind: "messageType",
                        messageType: reader.string()
                    };
                    break;
                case /* string type_param */ 10:
                    message.typeKind = {
                        oneofKind: "typeParam",
                        typeParam: reader.string()
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type type */ 11:
                    message.typeKind = {
                        oneofKind: "type",
                        type: Type.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).type)
                    };
                    break;
                case /* google.protobuf.Empty error */ 12:
                    message.typeKind = {
                        oneofKind: "error",
                        error: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).error)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Type.AbstractType abstract_type */ 14:
                    message.typeKind = {
                        oneofKind: "abstractType",
                        abstractType: Type_AbstractType.internalBinaryRead(reader, reader.uint32(), options, (message.typeKind as any).abstractType)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Empty dyn = 1; */
        if (message.typeKind.oneofKind === "dyn")
            Empty.internalBinaryWrite(message.typeKind.dyn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.NullValue null = 2; */
        if (message.typeKind.oneofKind === "null")
            writer.tag(2, WireType.Varint).int32(message.typeKind.null);
        /* google.api.expr.v1alpha1.Type.PrimitiveType primitive = 3; */
        if (message.typeKind.oneofKind === "primitive")
            writer.tag(3, WireType.Varint).int32(message.typeKind.primitive);
        /* google.api.expr.v1alpha1.Type.PrimitiveType wrapper = 4; */
        if (message.typeKind.oneofKind === "wrapper")
            writer.tag(4, WireType.Varint).int32(message.typeKind.wrapper);
        /* google.api.expr.v1alpha1.Type.WellKnownType well_known = 5; */
        if (message.typeKind.oneofKind === "wellKnown")
            writer.tag(5, WireType.Varint).int32(message.typeKind.wellKnown);
        /* google.api.expr.v1alpha1.Type.ListType list_type = 6; */
        if (message.typeKind.oneofKind === "listType")
            Type_ListType.internalBinaryWrite(message.typeKind.listType, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Type.MapType map_type = 7; */
        if (message.typeKind.oneofKind === "mapType")
            Type_MapType.internalBinaryWrite(message.typeKind.mapType, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Type.FunctionType function = 8; */
        if (message.typeKind.oneofKind === "function")
            Type_FunctionType.internalBinaryWrite(message.typeKind.function, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string message_type = 9; */
        if (message.typeKind.oneofKind === "messageType")
            writer.tag(9, WireType.LengthDelimited).string(message.typeKind.messageType);
        /* string type_param = 10; */
        if (message.typeKind.oneofKind === "typeParam")
            writer.tag(10, WireType.LengthDelimited).string(message.typeKind.typeParam);
        /* google.api.expr.v1alpha1.Type type = 11; */
        if (message.typeKind.oneofKind === "type")
            Type.internalBinaryWrite(message.typeKind.type, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Empty error = 12; */
        if (message.typeKind.oneofKind === "error")
            Empty.internalBinaryWrite(message.typeKind.error, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Type.AbstractType abstract_type = 14; */
        if (message.typeKind.oneofKind === "abstractType")
            Type_AbstractType.internalBinaryWrite(message.typeKind.abstractType, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Type
 */
export const Type = new Type$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_ListType$Type extends MessageType<Type_ListType> {
    constructor() {
        super("google.api.expr.v1alpha1.Type.ListType", [
            { no: 1, name: "elem_type", kind: "message", T: () => Type }
        ]);
    }
    create(value?: PartialMessage<Type_ListType>): Type_ListType {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_ListType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_ListType): Type_ListType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Type elem_type */ 1:
                    message.elemType = Type.internalBinaryRead(reader, reader.uint32(), options, message.elemType);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_ListType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Type elem_type = 1; */
        if (message.elemType)
            Type.internalBinaryWrite(message.elemType, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Type.ListType
 */
export const Type_ListType = new Type_ListType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_MapType$Type extends MessageType<Type_MapType> {
    constructor() {
        super("google.api.expr.v1alpha1.Type.MapType", [
            { no: 1, name: "key_type", kind: "message", T: () => Type },
            { no: 2, name: "value_type", kind: "message", T: () => Type }
        ]);
    }
    create(value?: PartialMessage<Type_MapType>): Type_MapType {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_MapType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_MapType): Type_MapType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Type key_type */ 1:
                    message.keyType = Type.internalBinaryRead(reader, reader.uint32(), options, message.keyType);
                    break;
                case /* google.api.expr.v1alpha1.Type value_type */ 2:
                    message.valueType = Type.internalBinaryRead(reader, reader.uint32(), options, message.valueType);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_MapType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Type key_type = 1; */
        if (message.keyType)
            Type.internalBinaryWrite(message.keyType, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Type value_type = 2; */
        if (message.valueType)
            Type.internalBinaryWrite(message.valueType, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Type.MapType
 */
export const Type_MapType = new Type_MapType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_FunctionType$Type extends MessageType<Type_FunctionType> {
    constructor() {
        super("google.api.expr.v1alpha1.Type.FunctionType", [
            { no: 1, name: "result_type", kind: "message", T: () => Type },
            { no: 2, name: "arg_types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Type }
        ]);
    }
    create(value?: PartialMessage<Type_FunctionType>): Type_FunctionType {
        const message = { argTypes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_FunctionType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_FunctionType): Type_FunctionType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Type result_type */ 1:
                    message.resultType = Type.internalBinaryRead(reader, reader.uint32(), options, message.resultType);
                    break;
                case /* repeated google.api.expr.v1alpha1.Type arg_types */ 2:
                    message.argTypes.push(Type.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_FunctionType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Type result_type = 1; */
        if (message.resultType)
            Type.internalBinaryWrite(message.resultType, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.expr.v1alpha1.Type arg_types = 2; */
        for (let i = 0; i < message.argTypes.length; i++)
            Type.internalBinaryWrite(message.argTypes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Type.FunctionType
 */
export const Type_FunctionType = new Type_FunctionType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_AbstractType$Type extends MessageType<Type_AbstractType> {
    constructor() {
        super("google.api.expr.v1alpha1.Type.AbstractType", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameter_types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Type }
        ]);
    }
    create(value?: PartialMessage<Type_AbstractType>): Type_AbstractType {
        const message = { name: "", parameterTypes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_AbstractType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_AbstractType): Type_AbstractType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated google.api.expr.v1alpha1.Type parameter_types */ 2:
                    message.parameterTypes.push(Type.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_AbstractType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated google.api.expr.v1alpha1.Type parameter_types = 2; */
        for (let i = 0; i < message.parameterTypes.length; i++)
            Type.internalBinaryWrite(message.parameterTypes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Type.AbstractType
 */
export const Type_AbstractType = new Type_AbstractType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decl$Type extends MessageType<Decl> {
    constructor() {
        super("google.api.expr.v1alpha1.Decl", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ident", kind: "message", oneof: "declKind", T: () => Decl_IdentDecl },
            { no: 3, name: "function", kind: "message", oneof: "declKind", T: () => Decl_FunctionDecl }
        ]);
    }
    create(value?: PartialMessage<Decl>): Decl {
        const message = { name: "", declKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decl): Decl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.api.expr.v1alpha1.Decl.IdentDecl ident */ 2:
                    message.declKind = {
                        oneofKind: "ident",
                        ident: Decl_IdentDecl.internalBinaryRead(reader, reader.uint32(), options, (message.declKind as any).ident)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Decl.FunctionDecl function */ 3:
                    message.declKind = {
                        oneofKind: "function",
                        function: Decl_FunctionDecl.internalBinaryRead(reader, reader.uint32(), options, (message.declKind as any).function)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.api.expr.v1alpha1.Decl.IdentDecl ident = 2; */
        if (message.declKind.oneofKind === "ident")
            Decl_IdentDecl.internalBinaryWrite(message.declKind.ident, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Decl.FunctionDecl function = 3; */
        if (message.declKind.oneofKind === "function")
            Decl_FunctionDecl.internalBinaryWrite(message.declKind.function, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Decl
 */
export const Decl = new Decl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decl_IdentDecl$Type extends MessageType<Decl_IdentDecl> {
    constructor() {
        super("google.api.expr.v1alpha1.Decl.IdentDecl", [
            { no: 1, name: "type", kind: "message", T: () => Type },
            { no: 2, name: "value", kind: "message", T: () => Constant },
            { no: 3, name: "doc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Decl_IdentDecl>): Decl_IdentDecl {
        const message = { doc: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decl_IdentDecl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decl_IdentDecl): Decl_IdentDecl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Type type */ 1:
                    message.type = Type.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* google.api.expr.v1alpha1.Constant value */ 2:
                    message.value = Constant.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* string doc */ 3:
                    message.doc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decl_IdentDecl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Type type = 1; */
        if (message.type)
            Type.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Constant value = 2; */
        if (message.value)
            Constant.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string doc = 3; */
        if (message.doc !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.doc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Decl.IdentDecl
 */
export const Decl_IdentDecl = new Decl_IdentDecl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decl_FunctionDecl$Type extends MessageType<Decl_FunctionDecl> {
    constructor() {
        super("google.api.expr.v1alpha1.Decl.FunctionDecl", [
            { no: 1, name: "overloads", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Decl_FunctionDecl_Overload }
        ]);
    }
    create(value?: PartialMessage<Decl_FunctionDecl>): Decl_FunctionDecl {
        const message = { overloads: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decl_FunctionDecl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decl_FunctionDecl): Decl_FunctionDecl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.api.expr.v1alpha1.Decl.FunctionDecl.Overload overloads */ 1:
                    message.overloads.push(Decl_FunctionDecl_Overload.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decl_FunctionDecl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.api.expr.v1alpha1.Decl.FunctionDecl.Overload overloads = 1; */
        for (let i = 0; i < message.overloads.length; i++)
            Decl_FunctionDecl_Overload.internalBinaryWrite(message.overloads[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Decl.FunctionDecl
 */
export const Decl_FunctionDecl = new Decl_FunctionDecl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decl_FunctionDecl_Overload$Type extends MessageType<Decl_FunctionDecl_Overload> {
    constructor() {
        super("google.api.expr.v1alpha1.Decl.FunctionDecl.Overload", [
            { no: 1, name: "overload_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Type },
            { no: 3, name: "type_params", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result_type", kind: "message", T: () => Type },
            { no: 5, name: "is_instance_function", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "doc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Decl_FunctionDecl_Overload>): Decl_FunctionDecl_Overload {
        const message = { overloadId: "", params: [], typeParams: [], isInstanceFunction: false, doc: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decl_FunctionDecl_Overload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decl_FunctionDecl_Overload): Decl_FunctionDecl_Overload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string overload_id */ 1:
                    message.overloadId = reader.string();
                    break;
                case /* repeated google.api.expr.v1alpha1.Type params */ 2:
                    message.params.push(Type.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string type_params */ 3:
                    message.typeParams.push(reader.string());
                    break;
                case /* google.api.expr.v1alpha1.Type result_type */ 4:
                    message.resultType = Type.internalBinaryRead(reader, reader.uint32(), options, message.resultType);
                    break;
                case /* bool is_instance_function */ 5:
                    message.isInstanceFunction = reader.bool();
                    break;
                case /* string doc */ 6:
                    message.doc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decl_FunctionDecl_Overload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string overload_id = 1; */
        if (message.overloadId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.overloadId);
        /* repeated google.api.expr.v1alpha1.Type params = 2; */
        for (let i = 0; i < message.params.length; i++)
            Type.internalBinaryWrite(message.params[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string type_params = 3; */
        for (let i = 0; i < message.typeParams.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.typeParams[i]);
        /* google.api.expr.v1alpha1.Type result_type = 4; */
        if (message.resultType)
            Type.internalBinaryWrite(message.resultType, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_instance_function = 5; */
        if (message.isInstanceFunction !== false)
            writer.tag(5, WireType.Varint).bool(message.isInstanceFunction);
        /* string doc = 6; */
        if (message.doc !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.doc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Decl.FunctionDecl.Overload
 */
export const Decl_FunctionDecl_Overload = new Decl_FunctionDecl_Overload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reference$Type extends MessageType<Reference> {
    constructor() {
        super("google.api.expr.v1alpha1.Reference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "overload_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "message", T: () => Constant }
        ]);
    }
    create(value?: PartialMessage<Reference>): Reference {
        const message = { name: "", overloadId: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Reference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reference): Reference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string overload_id */ 3:
                    message.overloadId.push(reader.string());
                    break;
                case /* google.api.expr.v1alpha1.Constant value */ 4:
                    message.value = Constant.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string overload_id = 3; */
        for (let i = 0; i < message.overloadId.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.overloadId[i]);
        /* google.api.expr.v1alpha1.Constant value = 4; */
        if (message.value)
            Constant.internalBinaryWrite(message.value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Reference
 */
export const Reference = new Reference$Type();
