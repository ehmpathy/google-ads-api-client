// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/api/expr/v1alpha1/eval.proto" (package "google.api.expr.v1alpha1", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Status } from "../../../rpc/status";
import { Value } from "./value";
/**
 * The state of an evaluation.
 *
 * Can represent an inital, partial, or completed state of evaluation.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.EvalState
 */
export interface EvalState {
    /**
     * The unique values referenced in this message.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.ExprValue values = 1;
     */
    values: ExprValue[];
    /**
     * An ordered list of results.
     *
     * Tracks the flow of evaluation through the expression.
     * May be sparse.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.EvalState.Result results = 3;
     */
    results: EvalState_Result[];
}
/**
 * A single evalution result.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.EvalState.Result
 */
export interface EvalState_Result {
    /**
     * The id of the expression this result if for.
     *
     * @generated from protobuf field: int64 expr = 1;
     */
    expr: bigint;
    /**
     * The index in `values` of the resulting value.
     *
     * @generated from protobuf field: int64 value = 2;
     */
    value: bigint;
}
/**
 * The value of an evaluated expression.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.ExprValue
 */
export interface ExprValue {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "value";
        /**
         * A concrete value.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Value value = 1;
         */
        value: Value;
    } | {
        oneofKind: "error";
        /**
         * The set of errors in the critical path of evalution.
         *
         * Only errors in the critical path are included. For example,
         * `(<error1> || true) && <error2>` will only result in `<error2>`,
         * while `<error1> || <error2>` will result in both `<error1>` and
         * `<error2>`.
         *
         * Errors cause by the presence of other errors are not included in the
         * set. For example `<error1>.foo`, `foo(<error1>)`, and `<error1> + 1` will
         * only result in `<error1>`.
         *
         * Multiple errors *might* be included when evaluation could result
         * in different errors. For example `<error1> + <error2>` and
         * `foo(<error1>, <error2>)` may result in `<error1>`, `<error2>` or both.
         * The exact subset of errors included for this case is unspecified and
         * depends on the implementation details of the evaluator.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.ErrorSet error = 2;
         */
        error: ErrorSet;
    } | {
        oneofKind: "unknown";
        /**
         * The set of unknowns in the critical path of evaluation.
         *
         * Unknown behaves identically to Error with regards to propagation.
         * Specifically, only unknowns in the critical path are included, unknowns
         * caused by the presence of other unknowns are not included, and multiple
         * unknowns *might* be included included when evaluation could result in
         * different unknowns. For example:
         *
         *     (<unknown[1]> || true) && <unknown[2]> -> <unknown[2]>
         *     <unknown[1]> || <unknown[2]> -> <unknown[1,2]>
         *     <unknown[1]>.foo -> <unknown[1]>
         *     foo(<unknown[1]>) -> <unknown[1]>
         *     <unknown[1]> + <unknown[2]> -> <unknown[1]> or <unknown[2[>
         *
         * Unknown takes precidence over Error in cases where a `Value` can short
         * circuit the result:
         *
         *     <error> || <unknown> -> <unknown>
         *     <error> && <unknown> -> <unknown>
         *
         * Errors take precidence in all other cases:
         *
         *     <unknown> + <error> -> <error>
         *     foo(<unknown>, <error>) -> <error>
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.UnknownSet unknown = 3;
         */
        unknown: UnknownSet;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A set of errors.
 *
 * The errors included depend on the context. See `ExprValue.error`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.ErrorSet
 */
export interface ErrorSet {
    /**
     * The errors in the set.
     *
     * @generated from protobuf field: repeated google.rpc.Status errors = 1;
     */
    errors: Status[];
}
/**
 * A set of expressions for which the value is unknown.
 *
 * The unknowns included depend on the context. See `ExprValue.unknown`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.UnknownSet
 */
export interface UnknownSet {
    /**
     * The ids of the expressions with unknown values.
     *
     * @generated from protobuf field: repeated int64 exprs = 1;
     */
    exprs: bigint[];
}
// @generated message type with reflection information, may provide speed optimized methods
class EvalState$Type extends MessageType<EvalState> {
    constructor() {
        super("google.api.expr.v1alpha1.EvalState", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExprValue },
            { no: 3, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EvalState_Result }
        ]);
    }
    create(value?: PartialMessage<EvalState>): EvalState {
        const message = { values: [], results: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvalState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvalState): EvalState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.api.expr.v1alpha1.ExprValue values */ 1:
                    message.values.push(ExprValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.api.expr.v1alpha1.EvalState.Result results */ 3:
                    message.results.push(EvalState_Result.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvalState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.api.expr.v1alpha1.ExprValue values = 1; */
        for (let i = 0; i < message.values.length; i++)
            ExprValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.expr.v1alpha1.EvalState.Result results = 3; */
        for (let i = 0; i < message.results.length; i++)
            EvalState_Result.internalBinaryWrite(message.results[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.EvalState
 */
export const EvalState = new EvalState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvalState_Result$Type extends MessageType<EvalState_Result> {
    constructor() {
        super("google.api.expr.v1alpha1.EvalState.Result", [
            { no: 1, name: "expr", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EvalState_Result>): EvalState_Result {
        const message = { expr: 0n, value: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvalState_Result>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvalState_Result): EvalState_Result {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 expr */ 1:
                    message.expr = reader.int64().toBigInt();
                    break;
                case /* int64 value */ 2:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvalState_Result, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 expr = 1; */
        if (message.expr !== 0n)
            writer.tag(1, WireType.Varint).int64(message.expr);
        /* int64 value = 2; */
        if (message.value !== 0n)
            writer.tag(2, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.EvalState.Result
 */
export const EvalState_Result = new EvalState_Result$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExprValue$Type extends MessageType<ExprValue> {
    constructor() {
        super("google.api.expr.v1alpha1.ExprValue", [
            { no: 1, name: "value", kind: "message", oneof: "kind", T: () => Value },
            { no: 2, name: "error", kind: "message", oneof: "kind", T: () => ErrorSet },
            { no: 3, name: "unknown", kind: "message", oneof: "kind", T: () => UnknownSet }
        ]);
    }
    create(value?: PartialMessage<ExprValue>): ExprValue {
        const message = { kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExprValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExprValue): ExprValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Value value */ 1:
                    message.kind = {
                        oneofKind: "value",
                        value: Value.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).value)
                    };
                    break;
                case /* google.api.expr.v1alpha1.ErrorSet error */ 2:
                    message.kind = {
                        oneofKind: "error",
                        error: ErrorSet.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).error)
                    };
                    break;
                case /* google.api.expr.v1alpha1.UnknownSet unknown */ 3:
                    message.kind = {
                        oneofKind: "unknown",
                        unknown: UnknownSet.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).unknown)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExprValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Value value = 1; */
        if (message.kind.oneofKind === "value")
            Value.internalBinaryWrite(message.kind.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.ErrorSet error = 2; */
        if (message.kind.oneofKind === "error")
            ErrorSet.internalBinaryWrite(message.kind.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.UnknownSet unknown = 3; */
        if (message.kind.oneofKind === "unknown")
            UnknownSet.internalBinaryWrite(message.kind.unknown, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.ExprValue
 */
export const ExprValue = new ExprValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorSet$Type extends MessageType<ErrorSet> {
    constructor() {
        super("google.api.expr.v1alpha1.ErrorSet", [
            { no: 1, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<ErrorSet>): ErrorSet {
        const message = { errors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ErrorSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorSet): ErrorSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.rpc.Status errors */ 1:
                    message.errors.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.rpc.Status errors = 1; */
        for (let i = 0; i < message.errors.length; i++)
            Status.internalBinaryWrite(message.errors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.ErrorSet
 */
export const ErrorSet = new ErrorSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnknownSet$Type extends MessageType<UnknownSet> {
    constructor() {
        super("google.api.expr.v1alpha1.UnknownSet", [
            { no: 1, name: "exprs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UnknownSet>): UnknownSet {
        const message = { exprs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnknownSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnknownSet): UnknownSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 exprs */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.exprs.push(reader.int64().toBigInt());
                    else
                        message.exprs.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnknownSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 exprs = 1; */
        if (message.exprs.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.exprs.length; i++)
                writer.int64(message.exprs[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.UnknownSet
 */
export const UnknownSet = new UnknownSet$Type();
