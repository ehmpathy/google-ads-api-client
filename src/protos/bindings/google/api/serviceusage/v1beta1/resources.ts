// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/api/serviceusage/v1beta1/resources.proto" (package "google.api.serviceusage.v1beta1", syntax proto3)
// tslint:disable
//
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Monitoring } from "../../monitoring";
import { MonitoredResourceDescriptor } from "../../monitored_resource";
import { Endpoint } from "../../endpoint";
import { Usage } from "../../usage";
import { Authentication } from "../../auth";
import { Quota } from "../../quota";
import { Documentation } from "../../documentation";
import { Api } from "../../../protobuf/api";
/**
 * A service that is available for use by the consumer.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.Service
 */
export interface Service {
    /**
     * The resource name of the consumer and service.
     *
     * A valid name would be:
     * - `projects/123/services/serviceusage.googleapis.com`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The resource name of the consumer.
     *
     * A valid name would be:
     * - `projects/123`
     *
     * @generated from protobuf field: string parent = 5;
     */
    parent: string;
    /**
     * The service configuration of the available service.
     * Some fields may be filtered out of the configuration in responses to
     * the `ListServices` method. These fields are present only in responses to
     * the `GetService` method.
     *
     * @generated from protobuf field: google.api.serviceusage.v1beta1.ServiceConfig config = 2;
     */
    config?: ServiceConfig;
    /**
     * Whether or not the service has been enabled for use by the consumer.
     *
     * @generated from protobuf field: google.api.serviceusage.v1beta1.State state = 4;
     */
    state: State;
}
/**
 * The configuration of the service.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.ServiceConfig
 */
export interface ServiceConfig {
    /**
     * The DNS address at which this service is available.
     *
     * An example DNS address would be:
     * `calendar.googleapis.com`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The product title for this service.
     *
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * A list of API interfaces exported by this service. Contains only the names,
     * versions, and method names of the interfaces.
     *
     * @generated from protobuf field: repeated google.protobuf.Api apis = 3;
     */
    apis: Api[];
    /**
     * Additional API documentation. Contains only the summary and the
     * documentation URL.
     *
     * @generated from protobuf field: google.api.Documentation documentation = 6;
     */
    documentation?: Documentation;
    /**
     * Quota configuration.
     *
     * @generated from protobuf field: google.api.Quota quota = 10;
     */
    quota?: Quota;
    /**
     * Auth configuration. Contains only the OAuth rules.
     *
     * @generated from protobuf field: google.api.Authentication authentication = 11;
     */
    authentication?: Authentication;
    /**
     * Configuration controlling usage of this service.
     *
     * @generated from protobuf field: google.api.Usage usage = 15;
     */
    usage?: Usage;
    /**
     * Configuration for network endpoints. Contains only the names and aliases
     * of the endpoints.
     *
     * @generated from protobuf field: repeated google.api.Endpoint endpoints = 18;
     */
    endpoints: Endpoint[];
    /**
     * Defines the monitored resources used by this service. This is required
     * by the [Service.monitoring][google.api.Service.monitoring] and [Service.logging][google.api.Service.logging] configurations.
     *
     * @generated from protobuf field: repeated google.api.MonitoredResourceDescriptor monitored_resources = 25;
     */
    monitoredResources: MonitoredResourceDescriptor[];
    /**
     * Monitoring configuration.
     * This should not include the 'producer_destinations' field.
     *
     * @generated from protobuf field: google.api.Monitoring monitoring = 28;
     */
    monitoring?: Monitoring;
}
/**
 * The operation metadata returned for the batchend services operation.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.OperationMetadata
 */
export interface OperationMetadata {
    /**
     * The full name of the resources that this operation is directly
     * associated with.
     *
     * @generated from protobuf field: repeated string resource_names = 2;
     */
    resourceNames: string[];
}
/**
 * Consumer quota settings for a quota metric.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.ConsumerQuotaMetric
 */
export interface ConsumerQuotaMetric {
    /**
     * The resource name of the quota settings on this metric for this consumer.
     *
     * An example name would be:
     * `projects/123/services/compute.googleapis.com/consumerQuotaMetrics/compute.googleapis.com%2Fcpus`
     *
     * The resource name is intended to be opaque and should not be parsed for
     * its component strings, since its representation could change in the future.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The name of the metric.
     *
     * An example name would be:
     * `compute.googleapis.com/cpus`
     *
     * @generated from protobuf field: string metric = 4;
     */
    metric: string;
    /**
     * The display name of the metric.
     *
     * An example name would be:
     * `CPUs`
     *
     * @generated from protobuf field: string display_name = 2;
     */
    displayName: string;
    /**
     * The consumer quota for each quota limit defined on the metric.
     *
     * @generated from protobuf field: repeated google.api.serviceusage.v1beta1.ConsumerQuotaLimit consumer_quota_limits = 3;
     */
    consumerQuotaLimits: ConsumerQuotaLimit[];
    /**
     * The quota limits targeting the descendant containers of the
     * consumer in request.
     *
     * If the consumer in request is of type `organizations`
     * or `folders`, the field will list per-project limits in the metric; if the
     * consumer in request is of type `project`, the field will be empty.
     *
     * The `quota_buckets` field of each descendant consumer quota limit will not
     * be populated.
     *
     * @generated from protobuf field: repeated google.api.serviceusage.v1beta1.ConsumerQuotaLimit descendant_consumer_quota_limits = 6;
     */
    descendantConsumerQuotaLimits: ConsumerQuotaLimit[];
    /**
     * The units in which the metric value is reported.
     *
     * @generated from protobuf field: string unit = 5;
     */
    unit: string;
}
/**
 * Consumer quota settings for a quota limit.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.ConsumerQuotaLimit
 */
export interface ConsumerQuotaLimit {
    /**
     * The resource name of the quota limit.
     *
     * An example name would be:
     * `projects/123/services/compute.googleapis.com/consumerQuotaMetrics/compute.googleapis.com%2Fcpus/limits/%2Fproject%2Fregion`
     *
     * The resource name is intended to be opaque and should not be parsed for
     * its component strings, since its representation could change in the future.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The name of the parent metric of this limit.
     *
     * An example name would be:
     * `compute.googleapis.com/cpus`
     *
     * @generated from protobuf field: string metric = 8;
     */
    metric: string;
    /**
     * The limit unit.
     *
     * An example unit would be
     * `1/{project}/{region}`
     * Note that `{project}` and `{region}` are not placeholders in this example;
     * the literal characters `{` and `}` occur in the string.
     *
     * @generated from protobuf field: string unit = 2;
     */
    unit: string;
    /**
     * Whether this limit is precise or imprecise.
     *
     * @generated from protobuf field: bool is_precise = 3;
     */
    isPrecise: boolean;
    /**
     * Whether admin overrides are allowed on this limit
     *
     * @generated from protobuf field: bool allows_admin_overrides = 7;
     */
    allowsAdminOverrides: boolean;
    /**
     * Summary of the enforced quota buckets, organized by quota dimension,
     * ordered from least specific to most specific (for example, the global
     * default bucket, with no quota dimensions, will always appear first).
     *
     * @generated from protobuf field: repeated google.api.serviceusage.v1beta1.QuotaBucket quota_buckets = 9;
     */
    quotaBuckets: QuotaBucket[];
}
/**
 * A quota bucket is a quota provisioning unit for a specific set of dimensions.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.QuotaBucket
 */
export interface QuotaBucket {
    /**
     * The effective limit of this quota bucket. Equal to default_limit if there
     * are no overrides.
     *
     * @generated from protobuf field: int64 effective_limit = 1;
     */
    effectiveLimit: bigint;
    /**
     * The default limit of this quota bucket, as specified by the service
     * configuration.
     *
     * @generated from protobuf field: int64 default_limit = 2;
     */
    defaultLimit: bigint;
    /**
     * Producer override on this quota bucket.
     *
     * @generated from protobuf field: google.api.serviceusage.v1beta1.QuotaOverride producer_override = 3;
     */
    producerOverride?: QuotaOverride;
    /**
     * Consumer override on this quota bucket.
     *
     * @generated from protobuf field: google.api.serviceusage.v1beta1.QuotaOverride consumer_override = 4;
     */
    consumerOverride?: QuotaOverride;
    /**
     * Admin override on this quota bucket.
     *
     * @generated from protobuf field: google.api.serviceusage.v1beta1.QuotaOverride admin_override = 5;
     */
    adminOverride?: QuotaOverride;
    /**
     * The dimensions of this quota bucket.
     *
     * If this map is empty, this is the global bucket, which is the default quota
     * value applied to all requests that do not have a more specific override.
     *
     * If this map is nonempty, the default limit, effective limit, and quota
     * overrides apply only to requests that have the dimensions given in the map.
     *
     * For example, if the map has key `region` and value `us-east-1`, then the
     * specified effective limit is only effective in that region, and the
     * specified overrides apply only in that region.
     *
     * @generated from protobuf field: map<string, string> dimensions = 6;
     */
    dimensions: {
        [key: string]: string;
    };
}
/**
 * A quota override
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.QuotaOverride
 */
export interface QuotaOverride {
    /**
     * The resource name of the override.
     * This name is generated by the server when the override is created.
     *
     * Example names would be:
     * `projects/123/services/compute.googleapis.com/consumerQuotaMetrics/compute.googleapis.com%2Fcpus/limits/%2Fproject%2Fregion/adminOverrides/4a3f2c1d`
     * `projects/123/services/compute.googleapis.com/consumerQuotaMetrics/compute.googleapis.com%2Fcpus/limits/%2Fproject%2Fregion/consumerOverrides/4a3f2c1d`
     *
     * The resource name is intended to be opaque and should not be parsed for
     * its component strings, since its representation could change in the future.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The overriding quota limit value.
     * Can be any nonnegative integer, or -1 (unlimited quota).
     *
     * @generated from protobuf field: int64 override_value = 2;
     */
    overrideValue: bigint;
    /**
     * If this map is nonempty, then this override applies only to specific values
     * for dimensions defined in the limit unit.
     *
     * For example, an override on a limit with the unit `1/{project}/{region}`
     * could contain an entry with the key `region` and the value `us-east-1`;
     * the override is only applied to quota consumed in that region.
     *
     * This map has the following restrictions:
     *
     * *   Keys that are not defined in the limit's unit are not valid keys.
     *     Any string appearing in `{brackets}` in the unit (besides `{project}`
     *     or
     *     `{user}`) is a defined key.
     * *   `project` is not a valid key; the project is already specified in
     *     the parent resource name.
     * *   `user` is not a valid key; the API does not support quota overrides
     *     that apply only to a specific user.
     * *   If `region` appears as a key, its value must be a valid Cloud region.
     * *   If `zone` appears as a key, its value must be a valid Cloud zone.
     * *   If any valid key other than `region` or `zone` appears in the map, then
     *     all valid keys other than `region` or `zone` must also appear in the
     *     map.
     *
     * @generated from protobuf field: map<string, string> dimensions = 3;
     */
    dimensions: {
        [key: string]: string;
    };
    /**
     * The name of the metric to which this override applies.
     *
     * An example name would be:
     * `compute.googleapis.com/cpus`
     *
     * @generated from protobuf field: string metric = 4;
     */
    metric: string;
    /**
     * The limit unit of the limit to which this override applies.
     *
     * An example unit would be:
     * `1/{project}/{region}`
     * Note that `{project}` and `{region}` are not placeholders in this example;
     * the literal characters `{` and `}` occur in the string.
     *
     * @generated from protobuf field: string unit = 5;
     */
    unit: string;
    /**
     * The resource name of the ancestor that requested the override. For example:
     * `organizations/12345` or `folders/67890`.
     * Used by admin overrides only.
     *
     * @generated from protobuf field: string admin_override_ancestor = 6;
     */
    adminOverrideAncestor: string;
}
/**
 * Import data embedded in the request message
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.OverrideInlineSource
 */
export interface OverrideInlineSource {
    /**
     * The overrides to create.
     * Each override must have a value for 'metric' and 'unit', to specify
     * which metric and which limit the override should be applied to.
     * The 'name' field of the override does not need to be set; it is ignored.
     *
     * @generated from protobuf field: repeated google.api.serviceusage.v1beta1.QuotaOverride overrides = 1;
     */
    overrides: QuotaOverride[];
}
/**
 * Quota policy created by quota administrator.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.AdminQuotaPolicy
 */
export interface AdminQuotaPolicy {
    /**
     * The resource name of the policy.
     * This name is generated by the server when the policy is created.
     *
     * Example names would be:
     * `organizations/123/services/compute.googleapis.com/consumerQuotaMetrics/compute.googleapis.com%2Fcpus/limits/%2Fproject%2Fregion/adminQuotaPolicies/4a3f2c1d`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The quota policy value.
     * Can be any nonnegative integer, or -1 (unlimited quota).
     *
     * @generated from protobuf field: int64 policy_value = 2;
     */
    policyValue: bigint;
    /**
     *
     * If this map is nonempty, then this policy applies only to specific values
     * for dimensions defined in the limit unit.
     *
     * For example, an policy on a limit with the unit `1/{project}/{region}`
     * could contain an entry with the key `region` and the value `us-east-1`;
     * the policy is only applied to quota consumed in that region.
     *
     * This map has the following restrictions:
     *
     * *   If `region` appears as a key, its value must be a valid Cloud region.
     * *   If `zone` appears as a key, its value must be a valid Cloud zone.
     * *   Keys other than `region` or `zone` are not valid.
     *
     * @generated from protobuf field: map<string, string> dimensions = 3;
     */
    dimensions: {
        [key: string]: string;
    };
    /**
     * The name of the metric to which this policy applies.
     *
     * An example name would be:
     * `compute.googleapis.com/cpus`
     *
     * @generated from protobuf field: string metric = 4;
     */
    metric: string;
    /**
     * The limit unit of the limit to which this policy applies.
     *
     * An example unit would be:
     * `1/{project}/{region}`
     * Note that `{project}` and `{region}` are not placeholders in this example;
     * the literal characters `{` and `}` occur in the string.
     *
     * @generated from protobuf field: string unit = 5;
     */
    unit: string;
    /**
     * The cloud resource container at which the quota policy is created. The
     * format is `{container_type}/{container_number}`
     *
     * @generated from protobuf field: string container = 6;
     */
    container: string;
}
/**
 * Service identity for a service. This is the identity that service producer
 * should use to access consumer resources.
 *
 * @generated from protobuf message google.api.serviceusage.v1beta1.ServiceIdentity
 */
export interface ServiceIdentity {
    /**
     * The email address of the service account that a service producer would use
     * to access consumer resources.
     *
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * The unique and stable id of the service account.
     * https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts#ServiceAccount
     *
     * @generated from protobuf field: string unique_id = 2;
     */
    uniqueId: string;
}
/**
 * Whether or not a service has been enabled for use by a consumer.
 *
 * @generated from protobuf enum google.api.serviceusage.v1beta1.State
 */
export enum State {
    /**
     * The default value, which indicates that the enabled state of the service
     * is unspecified or not meaningful. Currently, all consumers other than
     * projects (such as folders and organizations) are always in this state.
     *
     * @generated from protobuf enum value: STATE_UNSPECIFIED = 0;
     */
    STATE_UNSPECIFIED = 0,
    /**
     * The service cannot be used by this consumer. It has either been explicitly
     * disabled, or has never been enabled.
     *
     * @generated from protobuf enum value: DISABLED = 1;
     */
    DISABLED = 1,
    /**
     * The service has been explicitly enabled for use by this consumer.
     *
     * @generated from protobuf enum value: ENABLED = 2;
     */
    ENABLED = 2
}
/**
 * Selected view of quota. Can be used to request more detailed quota
 * information when retrieving quota metrics and limits.
 *
 * @generated from protobuf enum google.api.serviceusage.v1beta1.QuotaView
 */
export enum QuotaView {
    /**
     * No quota view specified. Requests that do not specify a quota view will
     * typically default to the BASIC view.
     *
     * @generated from protobuf enum value: QUOTA_VIEW_UNSPECIFIED = 0;
     */
    QUOTA_VIEW_UNSPECIFIED = 0,
    /**
     * Only buckets with overrides are shown in the response.
     *
     * @generated from protobuf enum value: BASIC = 1;
     */
    BASIC = 1,
    /**
     * Include per-location buckets even if they do not have overrides.
     * When the view is FULL, and a limit has regional or zonal quota, the limit
     * will include buckets for all regions or zones that could support
     * overrides, even if none are currently present. In some cases this will
     * cause the response to become very large; callers that do not need this
     * extra information should use the BASIC view instead.
     *
     * @generated from protobuf enum value: FULL = 2;
     */
    FULL = 2
}
/**
 * Enumerations of quota safety checks.
 *
 * @generated from protobuf enum google.api.serviceusage.v1beta1.QuotaSafetyCheck
 */
export enum QuotaSafetyCheck {
    /**
     * Unspecified quota safety check.
     *
     * @generated from protobuf enum value: QUOTA_SAFETY_CHECK_UNSPECIFIED = 0;
     */
    QUOTA_SAFETY_CHECK_UNSPECIFIED = 0,
    /**
     * Validates that a quota mutation would not cause the consumer's effective
     * limit to be lower than the consumer's quota usage.
     *
     * @generated from protobuf enum value: LIMIT_DECREASE_BELOW_USAGE = 1;
     */
    LIMIT_DECREASE_BELOW_USAGE = 1,
    /**
     * Validates that a quota mutation would not cause the consumer's effective
     * limit to decrease by more than 10 percent.
     *
     * @generated from protobuf enum value: LIMIT_DECREASE_PERCENTAGE_TOO_HIGH = 2;
     */
    LIMIT_DECREASE_PERCENTAGE_TOO_HIGH = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Service$Type extends MessageType<Service> {
    constructor() {
        super("google.api.serviceusage.v1beta1.Service", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config", kind: "message", T: () => ServiceConfig },
            { no: 4, name: "state", kind: "enum", T: () => ["google.api.serviceusage.v1beta1.State", State] }
        ]);
    }
    create(value?: PartialMessage<Service>): Service {
        const message = { name: "", parent: "", state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Service>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Service): Service {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string parent */ 5:
                    message.parent = reader.string();
                    break;
                case /* google.api.serviceusage.v1beta1.ServiceConfig config */ 2:
                    message.config = ServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* google.api.serviceusage.v1beta1.State state */ 4:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Service, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string parent = 5; */
        if (message.parent !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.parent);
        /* google.api.serviceusage.v1beta1.ServiceConfig config = 2; */
        if (message.config)
            ServiceConfig.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.api.serviceusage.v1beta1.State state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.Service
 */
export const Service = new Service$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceConfig$Type extends MessageType<ServiceConfig> {
    constructor() {
        super("google.api.serviceusage.v1beta1.ServiceConfig", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "apis", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Api },
            { no: 6, name: "documentation", kind: "message", T: () => Documentation },
            { no: 10, name: "quota", kind: "message", T: () => Quota },
            { no: 11, name: "authentication", kind: "message", T: () => Authentication },
            { no: 15, name: "usage", kind: "message", T: () => Usage },
            { no: 18, name: "endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint },
            { no: 25, name: "monitored_resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MonitoredResourceDescriptor },
            { no: 28, name: "monitoring", kind: "message", T: () => Monitoring }
        ]);
    }
    create(value?: PartialMessage<ServiceConfig>): ServiceConfig {
        const message = { name: "", title: "", apis: [], endpoints: [], monitoredResources: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceConfig): ServiceConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* repeated google.protobuf.Api apis */ 3:
                    message.apis.push(Api.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.api.Documentation documentation */ 6:
                    message.documentation = Documentation.internalBinaryRead(reader, reader.uint32(), options, message.documentation);
                    break;
                case /* google.api.Quota quota */ 10:
                    message.quota = Quota.internalBinaryRead(reader, reader.uint32(), options, message.quota);
                    break;
                case /* google.api.Authentication authentication */ 11:
                    message.authentication = Authentication.internalBinaryRead(reader, reader.uint32(), options, message.authentication);
                    break;
                case /* google.api.Usage usage */ 15:
                    message.usage = Usage.internalBinaryRead(reader, reader.uint32(), options, message.usage);
                    break;
                case /* repeated google.api.Endpoint endpoints */ 18:
                    message.endpoints.push(Endpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.api.MonitoredResourceDescriptor monitored_resources */ 25:
                    message.monitoredResources.push(MonitoredResourceDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.api.Monitoring monitoring */ 28:
                    message.monitoring = Monitoring.internalBinaryRead(reader, reader.uint32(), options, message.monitoring);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* repeated google.protobuf.Api apis = 3; */
        for (let i = 0; i < message.apis.length; i++)
            Api.internalBinaryWrite(message.apis[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.api.Documentation documentation = 6; */
        if (message.documentation)
            Documentation.internalBinaryWrite(message.documentation, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.api.Quota quota = 10; */
        if (message.quota)
            Quota.internalBinaryWrite(message.quota, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.api.Authentication authentication = 11; */
        if (message.authentication)
            Authentication.internalBinaryWrite(message.authentication, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.api.Usage usage = 15; */
        if (message.usage)
            Usage.internalBinaryWrite(message.usage, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.Endpoint endpoints = 18; */
        for (let i = 0; i < message.endpoints.length; i++)
            Endpoint.internalBinaryWrite(message.endpoints[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.MonitoredResourceDescriptor monitored_resources = 25; */
        for (let i = 0; i < message.monitoredResources.length; i++)
            MonitoredResourceDescriptor.internalBinaryWrite(message.monitoredResources[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* google.api.Monitoring monitoring = 28; */
        if (message.monitoring)
            Monitoring.internalBinaryWrite(message.monitoring, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.ServiceConfig
 */
export const ServiceConfig = new ServiceConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationMetadata$Type extends MessageType<OperationMetadata> {
    constructor() {
        super("google.api.serviceusage.v1beta1.OperationMetadata", [
            { no: 2, name: "resource_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OperationMetadata>): OperationMetadata {
        const message = { resourceNames: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationMetadata): OperationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string resource_names */ 2:
                    message.resourceNames.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string resource_names = 2; */
        for (let i = 0; i < message.resourceNames.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.resourceNames[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.OperationMetadata
 */
export const OperationMetadata = new OperationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsumerQuotaMetric$Type extends MessageType<ConsumerQuotaMetric> {
    constructor() {
        super("google.api.serviceusage.v1beta1.ConsumerQuotaMetric", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metric", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consumer_quota_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConsumerQuotaLimit },
            { no: 6, name: "descendant_consumer_quota_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConsumerQuotaLimit },
            { no: 5, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConsumerQuotaMetric>): ConsumerQuotaMetric {
        const message = { name: "", metric: "", displayName: "", consumerQuotaLimits: [], descendantConsumerQuotaLimits: [], unit: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsumerQuotaMetric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsumerQuotaMetric): ConsumerQuotaMetric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string metric */ 4:
                    message.metric = reader.string();
                    break;
                case /* string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* repeated google.api.serviceusage.v1beta1.ConsumerQuotaLimit consumer_quota_limits */ 3:
                    message.consumerQuotaLimits.push(ConsumerQuotaLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.api.serviceusage.v1beta1.ConsumerQuotaLimit descendant_consumer_quota_limits */ 6:
                    message.descendantConsumerQuotaLimits.push(ConsumerQuotaLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string unit */ 5:
                    message.unit = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsumerQuotaMetric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string metric = 4; */
        if (message.metric !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.metric);
        /* string display_name = 2; */
        if (message.displayName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* repeated google.api.serviceusage.v1beta1.ConsumerQuotaLimit consumer_quota_limits = 3; */
        for (let i = 0; i < message.consumerQuotaLimits.length; i++)
            ConsumerQuotaLimit.internalBinaryWrite(message.consumerQuotaLimits[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.serviceusage.v1beta1.ConsumerQuotaLimit descendant_consumer_quota_limits = 6; */
        for (let i = 0; i < message.descendantConsumerQuotaLimits.length; i++)
            ConsumerQuotaLimit.internalBinaryWrite(message.descendantConsumerQuotaLimits[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string unit = 5; */
        if (message.unit !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.unit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.ConsumerQuotaMetric
 */
export const ConsumerQuotaMetric = new ConsumerQuotaMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsumerQuotaLimit$Type extends MessageType<ConsumerQuotaLimit> {
    constructor() {
        super("google.api.serviceusage.v1beta1.ConsumerQuotaLimit", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "metric", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_precise", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "allows_admin_overrides", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "quota_buckets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuotaBucket }
        ]);
    }
    create(value?: PartialMessage<ConsumerQuotaLimit>): ConsumerQuotaLimit {
        const message = { name: "", metric: "", unit: "", isPrecise: false, allowsAdminOverrides: false, quotaBuckets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsumerQuotaLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsumerQuotaLimit): ConsumerQuotaLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string metric */ 8:
                    message.metric = reader.string();
                    break;
                case /* string unit */ 2:
                    message.unit = reader.string();
                    break;
                case /* bool is_precise */ 3:
                    message.isPrecise = reader.bool();
                    break;
                case /* bool allows_admin_overrides */ 7:
                    message.allowsAdminOverrides = reader.bool();
                    break;
                case /* repeated google.api.serviceusage.v1beta1.QuotaBucket quota_buckets */ 9:
                    message.quotaBuckets.push(QuotaBucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsumerQuotaLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string metric = 8; */
        if (message.metric !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.metric);
        /* string unit = 2; */
        if (message.unit !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.unit);
        /* bool is_precise = 3; */
        if (message.isPrecise !== false)
            writer.tag(3, WireType.Varint).bool(message.isPrecise);
        /* bool allows_admin_overrides = 7; */
        if (message.allowsAdminOverrides !== false)
            writer.tag(7, WireType.Varint).bool(message.allowsAdminOverrides);
        /* repeated google.api.serviceusage.v1beta1.QuotaBucket quota_buckets = 9; */
        for (let i = 0; i < message.quotaBuckets.length; i++)
            QuotaBucket.internalBinaryWrite(message.quotaBuckets[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.ConsumerQuotaLimit
 */
export const ConsumerQuotaLimit = new ConsumerQuotaLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaBucket$Type extends MessageType<QuotaBucket> {
    constructor() {
        super("google.api.serviceusage.v1beta1.QuotaBucket", [
            { no: 1, name: "effective_limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "default_limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "producer_override", kind: "message", T: () => QuotaOverride },
            { no: 4, name: "consumer_override", kind: "message", T: () => QuotaOverride },
            { no: 5, name: "admin_override", kind: "message", T: () => QuotaOverride },
            { no: 6, name: "dimensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<QuotaBucket>): QuotaBucket {
        const message = { effectiveLimit: 0n, defaultLimit: 0n, dimensions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuotaBucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaBucket): QuotaBucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 effective_limit */ 1:
                    message.effectiveLimit = reader.int64().toBigInt();
                    break;
                case /* int64 default_limit */ 2:
                    message.defaultLimit = reader.int64().toBigInt();
                    break;
                case /* google.api.serviceusage.v1beta1.QuotaOverride producer_override */ 3:
                    message.producerOverride = QuotaOverride.internalBinaryRead(reader, reader.uint32(), options, message.producerOverride);
                    break;
                case /* google.api.serviceusage.v1beta1.QuotaOverride consumer_override */ 4:
                    message.consumerOverride = QuotaOverride.internalBinaryRead(reader, reader.uint32(), options, message.consumerOverride);
                    break;
                case /* google.api.serviceusage.v1beta1.QuotaOverride admin_override */ 5:
                    message.adminOverride = QuotaOverride.internalBinaryRead(reader, reader.uint32(), options, message.adminOverride);
                    break;
                case /* map<string, string> dimensions */ 6:
                    this.binaryReadMap6(message.dimensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: QuotaBucket["dimensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QuotaBucket["dimensions"] | undefined, val: QuotaBucket["dimensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.serviceusage.v1beta1.QuotaBucket.dimensions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: QuotaBucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 effective_limit = 1; */
        if (message.effectiveLimit !== 0n)
            writer.tag(1, WireType.Varint).int64(message.effectiveLimit);
        /* int64 default_limit = 2; */
        if (message.defaultLimit !== 0n)
            writer.tag(2, WireType.Varint).int64(message.defaultLimit);
        /* google.api.serviceusage.v1beta1.QuotaOverride producer_override = 3; */
        if (message.producerOverride)
            QuotaOverride.internalBinaryWrite(message.producerOverride, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.api.serviceusage.v1beta1.QuotaOverride consumer_override = 4; */
        if (message.consumerOverride)
            QuotaOverride.internalBinaryWrite(message.consumerOverride, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.api.serviceusage.v1beta1.QuotaOverride admin_override = 5; */
        if (message.adminOverride)
            QuotaOverride.internalBinaryWrite(message.adminOverride, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> dimensions = 6; */
        for (let k of Object.keys(message.dimensions))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.dimensions[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.QuotaBucket
 */
export const QuotaBucket = new QuotaBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaOverride$Type extends MessageType<QuotaOverride> {
    constructor() {
        super("google.api.serviceusage.v1beta1.QuotaOverride", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "override_value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "dimensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "metric", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "admin_override_ancestor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuotaOverride>): QuotaOverride {
        const message = { name: "", overrideValue: 0n, dimensions: {}, metric: "", unit: "", adminOverrideAncestor: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuotaOverride>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaOverride): QuotaOverride {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 override_value */ 2:
                    message.overrideValue = reader.int64().toBigInt();
                    break;
                case /* map<string, string> dimensions */ 3:
                    this.binaryReadMap3(message.dimensions, reader, options);
                    break;
                case /* string metric */ 4:
                    message.metric = reader.string();
                    break;
                case /* string unit */ 5:
                    message.unit = reader.string();
                    break;
                case /* string admin_override_ancestor */ 6:
                    message.adminOverrideAncestor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: QuotaOverride["dimensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QuotaOverride["dimensions"] | undefined, val: QuotaOverride["dimensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.serviceusage.v1beta1.QuotaOverride.dimensions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: QuotaOverride, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 override_value = 2; */
        if (message.overrideValue !== 0n)
            writer.tag(2, WireType.Varint).int64(message.overrideValue);
        /* map<string, string> dimensions = 3; */
        for (let k of Object.keys(message.dimensions))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.dimensions[k]).join();
        /* string metric = 4; */
        if (message.metric !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.metric);
        /* string unit = 5; */
        if (message.unit !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.unit);
        /* string admin_override_ancestor = 6; */
        if (message.adminOverrideAncestor !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.adminOverrideAncestor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.QuotaOverride
 */
export const QuotaOverride = new QuotaOverride$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OverrideInlineSource$Type extends MessageType<OverrideInlineSource> {
    constructor() {
        super("google.api.serviceusage.v1beta1.OverrideInlineSource", [
            { no: 1, name: "overrides", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuotaOverride }
        ]);
    }
    create(value?: PartialMessage<OverrideInlineSource>): OverrideInlineSource {
        const message = { overrides: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OverrideInlineSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OverrideInlineSource): OverrideInlineSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.api.serviceusage.v1beta1.QuotaOverride overrides */ 1:
                    message.overrides.push(QuotaOverride.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OverrideInlineSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.api.serviceusage.v1beta1.QuotaOverride overrides = 1; */
        for (let i = 0; i < message.overrides.length; i++)
            QuotaOverride.internalBinaryWrite(message.overrides[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.OverrideInlineSource
 */
export const OverrideInlineSource = new OverrideInlineSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdminQuotaPolicy$Type extends MessageType<AdminQuotaPolicy> {
    constructor() {
        super("google.api.serviceusage.v1beta1.AdminQuotaPolicy", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "policy_value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "dimensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "metric", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "container", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AdminQuotaPolicy>): AdminQuotaPolicy {
        const message = { name: "", policyValue: 0n, dimensions: {}, metric: "", unit: "", container: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdminQuotaPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdminQuotaPolicy): AdminQuotaPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 policy_value */ 2:
                    message.policyValue = reader.int64().toBigInt();
                    break;
                case /* map<string, string> dimensions */ 3:
                    this.binaryReadMap3(message.dimensions, reader, options);
                    break;
                case /* string metric */ 4:
                    message.metric = reader.string();
                    break;
                case /* string unit */ 5:
                    message.unit = reader.string();
                    break;
                case /* string container */ 6:
                    message.container = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AdminQuotaPolicy["dimensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AdminQuotaPolicy["dimensions"] | undefined, val: AdminQuotaPolicy["dimensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.serviceusage.v1beta1.AdminQuotaPolicy.dimensions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AdminQuotaPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 policy_value = 2; */
        if (message.policyValue !== 0n)
            writer.tag(2, WireType.Varint).int64(message.policyValue);
        /* map<string, string> dimensions = 3; */
        for (let k of Object.keys(message.dimensions))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.dimensions[k]).join();
        /* string metric = 4; */
        if (message.metric !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.metric);
        /* string unit = 5; */
        if (message.unit !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.unit);
        /* string container = 6; */
        if (message.container !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.container);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.AdminQuotaPolicy
 */
export const AdminQuotaPolicy = new AdminQuotaPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceIdentity$Type extends MessageType<ServiceIdentity> {
    constructor() {
        super("google.api.serviceusage.v1beta1.ServiceIdentity", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceIdentity>): ServiceIdentity {
        const message = { email: "", uniqueId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceIdentity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceIdentity): ServiceIdentity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string unique_id */ 2:
                    message.uniqueId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceIdentity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string unique_id = 2; */
        if (message.uniqueId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uniqueId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.serviceusage.v1beta1.ServiceIdentity
 */
export const ServiceIdentity = new ServiceIdentity$Type();
