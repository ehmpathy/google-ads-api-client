// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/api/servicemanagement/v1/resources.proto" (package "google.api.servicemanagement.v1", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ConfigChange } from "../../config_change";
import { Timestamp } from "../../../protobuf/timestamp";
/**
 * The full representation of a Service that is managed by
 * Google Service Management.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.ManagedService
 */
export interface ManagedService {
    /**
     * The name of the service. See the
     * [overview](https://cloud.google.com/service-infrastructure/docs/overview)
     * for naming requirements.
     *
     * @generated from protobuf field: string service_name = 2;
     */
    serviceName: string;
    /**
     * ID of the project that produces and owns this service.
     *
     * @generated from protobuf field: string producer_project_id = 3;
     */
    producerProjectId: string;
}
/**
 * The metadata associated with a long running operation resource.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.OperationMetadata
 */
export interface OperationMetadata {
    /**
     * The full name of the resources that this operation is directly
     * associated with.
     *
     * @generated from protobuf field: repeated string resource_names = 1;
     */
    resourceNames: string[];
    /**
     * Detailed status information for each step. The order is undetermined.
     *
     * @generated from protobuf field: repeated google.api.servicemanagement.v1.OperationMetadata.Step steps = 2;
     */
    steps: OperationMetadata_Step[];
    /**
     * Percentage of completion of this operation, ranging from 0 to 100.
     *
     * @generated from protobuf field: int32 progress_percentage = 3;
     */
    progressPercentage: number;
    /**
     * The start time of the operation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 4;
     */
    startTime?: Timestamp;
}
/**
 * Represents the status of one operation step.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.OperationMetadata.Step
 */
export interface OperationMetadata_Step {
    /**
     * The short description of the step.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * The status code.
     *
     * @generated from protobuf field: google.api.servicemanagement.v1.OperationMetadata.Status status = 4;
     */
    status: OperationMetadata_Status;
}
/**
 * Code describes the status of the operation (or one of its steps).
 *
 * @generated from protobuf enum google.api.servicemanagement.v1.OperationMetadata.Status
 */
export enum OperationMetadata_Status {
    /**
     * Unspecifed code.
     *
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    STATUS_UNSPECIFIED = 0,
    /**
     * The operation or step has completed without errors.
     *
     * @generated from protobuf enum value: DONE = 1;
     */
    DONE = 1,
    /**
     * The operation or step has not started yet.
     *
     * @generated from protobuf enum value: NOT_STARTED = 2;
     */
    NOT_STARTED = 2,
    /**
     * The operation or step is in progress.
     *
     * @generated from protobuf enum value: IN_PROGRESS = 3;
     */
    IN_PROGRESS = 3,
    /**
     * The operation or step has completed with errors. If the operation is
     * rollbackable, the rollback completed with errors too.
     *
     * @generated from protobuf enum value: FAILED = 4;
     */
    FAILED = 4,
    /**
     * The operation or step has completed with cancellation.
     *
     * @generated from protobuf enum value: CANCELLED = 5;
     */
    CANCELLED = 5
}
/**
 * Represents a diagnostic message (error or warning)
 *
 * @generated from protobuf message google.api.servicemanagement.v1.Diagnostic
 */
export interface Diagnostic {
    /**
     * File name and line number of the error or warning.
     *
     * @generated from protobuf field: string location = 1;
     */
    location: string;
    /**
     * The kind of diagnostic information provided.
     *
     * @generated from protobuf field: google.api.servicemanagement.v1.Diagnostic.Kind kind = 2;
     */
    kind: Diagnostic_Kind;
    /**
     * Message describing the error or warning.
     *
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * The kind of diagnostic information possible.
 *
 * @generated from protobuf enum google.api.servicemanagement.v1.Diagnostic.Kind
 */
export enum Diagnostic_Kind {
    /**
     * Warnings and errors
     *
     * @generated from protobuf enum value: WARNING = 0;
     */
    WARNING = 0,
    /**
     * Only errors
     *
     * @generated from protobuf enum value: ERROR = 1;
     */
    ERROR = 1
}
/**
 * Represents a source file which is used to generate the service configuration
 * defined by `google.api.Service`.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.ConfigSource
 */
export interface ConfigSource {
    /**
     * A unique ID for a specific instance of this message, typically assigned
     * by the client for tracking purpose. If empty, the server may choose to
     * generate one instead.
     *
     * @generated from protobuf field: string id = 5;
     */
    id: string;
    /**
     * Set of source configuration files that are used to generate a service
     * configuration (`google.api.Service`).
     *
     * @generated from protobuf field: repeated google.api.servicemanagement.v1.ConfigFile files = 2;
     */
    files: ConfigFile[];
}
/**
 * Generic specification of a source configuration file
 *
 * @generated from protobuf message google.api.servicemanagement.v1.ConfigFile
 */
export interface ConfigFile {
    /**
     * The file name of the configuration file (full or relative path).
     *
     * @generated from protobuf field: string file_path = 1;
     */
    filePath: string;
    /**
     * The bytes that constitute the file.
     *
     * @generated from protobuf field: bytes file_contents = 3;
     */
    fileContents: Uint8Array;
    /**
     * The type of configuration file this represents.
     *
     * @generated from protobuf field: google.api.servicemanagement.v1.ConfigFile.FileType file_type = 4;
     */
    fileType: ConfigFile_FileType;
}
/**
 * @generated from protobuf enum google.api.servicemanagement.v1.ConfigFile.FileType
 */
export enum ConfigFile_FileType {
    /**
     * Unknown file type.
     *
     * @generated from protobuf enum value: FILE_TYPE_UNSPECIFIED = 0;
     */
    FILE_TYPE_UNSPECIFIED = 0,
    /**
     * YAML-specification of service.
     *
     * @generated from protobuf enum value: SERVICE_CONFIG_YAML = 1;
     */
    SERVICE_CONFIG_YAML = 1,
    /**
     * OpenAPI specification, serialized in JSON.
     *
     * @generated from protobuf enum value: OPEN_API_JSON = 2;
     */
    OPEN_API_JSON = 2,
    /**
     * OpenAPI specification, serialized in YAML.
     *
     * @generated from protobuf enum value: OPEN_API_YAML = 3;
     */
    OPEN_API_YAML = 3,
    /**
     * FileDescriptorSet, generated by protoc.
     *
     * To generate, use protoc with imports and source info included.
     * For an example test.proto file, the following command would put the value
     * in a new file named out.pb.
     *
     * $protoc --include_imports --include_source_info test.proto -o out.pb
     *
     * @generated from protobuf enum value: FILE_DESCRIPTOR_SET_PROTO = 4;
     */
    FILE_DESCRIPTOR_SET_PROTO = 4,
    /**
     * Uncompiled Proto file. Used for storage and display purposes only,
     * currently server-side compilation is not supported. Should match the
     * inputs to 'protoc' command used to generated FILE_DESCRIPTOR_SET_PROTO. A
     * file of this type can only be included if at least one file of type
     * FILE_DESCRIPTOR_SET_PROTO is included.
     *
     * @generated from protobuf enum value: PROTO_FILE = 6;
     */
    PROTO_FILE = 6
}
/**
 * Represents a service configuration with its name and id.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.ConfigRef
 */
export interface ConfigRef {
    /**
     * Resource name of a service config. It must have the following
     * format: "services/{service name}/configs/{config id}".
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * Change report associated with a particular service configuration.
 *
 * It contains a list of ConfigChanges based on the comparison between
 * two service configurations.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.ChangeReport
 */
export interface ChangeReport {
    /**
     * List of changes between two service configurations.
     * The changes will be alphabetically sorted based on the identifier
     * of each change.
     * A ConfigChange identifier is a dot separated path to the configuration.
     * Example: visibility.rules[selector='LibraryService.CreateBook'].restriction
     *
     * @generated from protobuf field: repeated google.api.ConfigChange config_changes = 1;
     */
    configChanges: ConfigChange[];
}
/**
 * A rollout resource that defines how service configuration versions are pushed
 * to control plane systems. Typically, you create a new version of the
 * service config, and then create a Rollout to push the service config.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.Rollout
 */
export interface Rollout {
    /**
     * Optional. Unique identifier of this Rollout. Must be no longer than 63
     * characters and only lower case letters, digits, '.', '_' and '-' are
     * allowed.
     *
     * If not specified by client, the server will generate one. The generated id
     * will have the form of <date><revision number>, where "date" is the create
     * date in ISO 8601 format.  "revision number" is a monotonically increasing
     * positive number that is reset every day for each service.
     * An example of the generated rollout_id is '2016-02-16r1'
     *
     * @generated from protobuf field: string rollout_id = 1;
     */
    rolloutId: string;
    /**
     * Creation time of the rollout. Readonly.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 2;
     */
    createTime?: Timestamp;
    /**
     * The user who created the Rollout. Readonly.
     *
     * @generated from protobuf field: string created_by = 3;
     */
    createdBy: string;
    /**
     * The status of this rollout. Readonly. In case of a failed rollout,
     * the system will automatically rollback to the current Rollout
     * version. Readonly.
     *
     * @generated from protobuf field: google.api.servicemanagement.v1.Rollout.RolloutStatus status = 4;
     */
    status: Rollout_RolloutStatus;
    /**
     * @generated from protobuf oneof: strategy
     */
    strategy: {
        oneofKind: "trafficPercentStrategy";
        /**
         * Google Service Control selects service configurations based on
         * traffic percentage.
         *
         * @generated from protobuf field: google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy = 5;
         */
        trafficPercentStrategy: Rollout_TrafficPercentStrategy;
    } | {
        oneofKind: "deleteServiceStrategy";
        /**
         * The strategy associated with a rollout to delete a `ManagedService`.
         * Readonly.
         *
         * @generated from protobuf field: google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy = 200;
         */
        deleteServiceStrategy: Rollout_DeleteServiceStrategy;
    } | {
        oneofKind: undefined;
    };
    /**
     * The name of the service associated with this Rollout.
     *
     * @generated from protobuf field: string service_name = 8;
     */
    serviceName: string;
}
/**
 * Strategy that specifies how clients of Google Service Controller want to
 * send traffic to use different config versions. This is generally
 * used by API proxy to split traffic based on your configured percentage for
 * each config version.
 *
 * One example of how to gradually rollout a new service configuration using
 * this
 * strategy:
 * Day 1
 *
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160206"
 *       traffic_percent_strategy {
 *         percentages: {
 *           "example.googleapis.com/20160201": 70.00
 *           "example.googleapis.com/20160206": 30.00
 *         }
 *       }
 *     }
 *
 * Day 2
 *
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160207"
 *       traffic_percent_strategy: {
 *         percentages: {
 *           "example.googleapis.com/20160206": 100.00
 *         }
 *       }
 *     }
 *
 * @generated from protobuf message google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy
 */
export interface Rollout_TrafficPercentStrategy {
    /**
     * Maps service configuration IDs to their corresponding traffic percentage.
     * Key is the service configuration ID, Value is the traffic percentage
     * which must be greater than 0.0 and the sum must equal to 100.0.
     *
     * @generated from protobuf field: map<string, double> percentages = 1;
     */
    percentages: {
        [key: string]: number;
    };
}
/**
 * Strategy used to delete a service. This strategy is a placeholder only
 * used by the system generated rollout to delete a service.
 *
 * @generated from protobuf message google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy
 */
export interface Rollout_DeleteServiceStrategy {
}
/**
 * Status of a Rollout.
 *
 * @generated from protobuf enum google.api.servicemanagement.v1.Rollout.RolloutStatus
 */
export enum Rollout_RolloutStatus {
    /**
     * No status specified.
     *
     * @generated from protobuf enum value: ROLLOUT_STATUS_UNSPECIFIED = 0;
     */
    ROLLOUT_STATUS_UNSPECIFIED = 0,
    /**
     * The Rollout is in progress.
     *
     * @generated from protobuf enum value: IN_PROGRESS = 1;
     */
    IN_PROGRESS = 1,
    /**
     * The Rollout has completed successfully.
     *
     * @generated from protobuf enum value: SUCCESS = 2;
     */
    SUCCESS = 2,
    /**
     * The Rollout has been cancelled. This can happen if you have overlapping
     * Rollout pushes, and the previous ones will be cancelled.
     *
     * @generated from protobuf enum value: CANCELLED = 3;
     */
    CANCELLED = 3,
    /**
     * The Rollout has failed and the rollback attempt has failed too.
     *
     * @generated from protobuf enum value: FAILED = 4;
     */
    FAILED = 4,
    /**
     * The Rollout has not started yet and is pending for execution.
     *
     * @generated from protobuf enum value: PENDING = 5;
     */
    PENDING = 5,
    /**
     * The Rollout has failed and rolled back to the previous successful
     * Rollout.
     *
     * @generated from protobuf enum value: FAILED_ROLLED_BACK = 6;
     */
    FAILED_ROLLED_BACK = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class ManagedService$Type extends MessageType<ManagedService> {
    constructor() {
        super("google.api.servicemanagement.v1.ManagedService", [
            { no: 2, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "producer_project_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ManagedService>): ManagedService {
        const message = { serviceName: "", producerProjectId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ManagedService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManagedService): ManagedService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_name */ 2:
                    message.serviceName = reader.string();
                    break;
                case /* string producer_project_id */ 3:
                    message.producerProjectId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManagedService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_name = 2; */
        if (message.serviceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceName);
        /* string producer_project_id = 3; */
        if (message.producerProjectId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.producerProjectId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.ManagedService
 */
export const ManagedService = new ManagedService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationMetadata$Type extends MessageType<OperationMetadata> {
    constructor() {
        super("google.api.servicemanagement.v1.OperationMetadata", [
            { no: 1, name: "resource_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "steps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OperationMetadata_Step },
            { no: 3, name: "progress_percentage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "start_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<OperationMetadata>): OperationMetadata {
        const message = { resourceNames: [], steps: [], progressPercentage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationMetadata): OperationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string resource_names */ 1:
                    message.resourceNames.push(reader.string());
                    break;
                case /* repeated google.api.servicemanagement.v1.OperationMetadata.Step steps */ 2:
                    message.steps.push(OperationMetadata_Step.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 progress_percentage */ 3:
                    message.progressPercentage = reader.int32();
                    break;
                case /* google.protobuf.Timestamp start_time */ 4:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string resource_names = 1; */
        for (let i = 0; i < message.resourceNames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.resourceNames[i]);
        /* repeated google.api.servicemanagement.v1.OperationMetadata.Step steps = 2; */
        for (let i = 0; i < message.steps.length; i++)
            OperationMetadata_Step.internalBinaryWrite(message.steps[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 progress_percentage = 3; */
        if (message.progressPercentage !== 0)
            writer.tag(3, WireType.Varint).int32(message.progressPercentage);
        /* google.protobuf.Timestamp start_time = 4; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.OperationMetadata
 */
export const OperationMetadata = new OperationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationMetadata_Step$Type extends MessageType<OperationMetadata_Step> {
    constructor() {
        super("google.api.servicemanagement.v1.OperationMetadata.Step", [
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "enum", T: () => ["google.api.servicemanagement.v1.OperationMetadata.Status", OperationMetadata_Status] }
        ]);
    }
    create(value?: PartialMessage<OperationMetadata_Step>): OperationMetadata_Step {
        const message = { description: "", status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationMetadata_Step>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationMetadata_Step): OperationMetadata_Step {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* google.api.servicemanagement.v1.OperationMetadata.Status status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationMetadata_Step, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* google.api.servicemanagement.v1.OperationMetadata.Status status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.OperationMetadata.Step
 */
export const OperationMetadata_Step = new OperationMetadata_Step$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Diagnostic$Type extends MessageType<Diagnostic> {
    constructor() {
        super("google.api.servicemanagement.v1.Diagnostic", [
            { no: 1, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "enum", T: () => ["google.api.servicemanagement.v1.Diagnostic.Kind", Diagnostic_Kind] },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Diagnostic>): Diagnostic {
        const message = { location: "", kind: 0, message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Diagnostic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Diagnostic): Diagnostic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location */ 1:
                    message.location = reader.string();
                    break;
                case /* google.api.servicemanagement.v1.Diagnostic.Kind kind */ 2:
                    message.kind = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Diagnostic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location = 1; */
        if (message.location !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.location);
        /* google.api.servicemanagement.v1.Diagnostic.Kind kind = 2; */
        if (message.kind !== 0)
            writer.tag(2, WireType.Varint).int32(message.kind);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.Diagnostic
 */
export const Diagnostic = new Diagnostic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigSource$Type extends MessageType<ConfigSource> {
    constructor() {
        super("google.api.servicemanagement.v1.ConfigSource", [
            { no: 5, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "files", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConfigFile }
        ]);
    }
    create(value?: PartialMessage<ConfigSource>): ConfigSource {
        const message = { id: "", files: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigSource): ConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 5:
                    message.id = reader.string();
                    break;
                case /* repeated google.api.servicemanagement.v1.ConfigFile files */ 2:
                    message.files.push(ConfigFile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 5; */
        if (message.id !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.id);
        /* repeated google.api.servicemanagement.v1.ConfigFile files = 2; */
        for (let i = 0; i < message.files.length; i++)
            ConfigFile.internalBinaryWrite(message.files[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.ConfigSource
 */
export const ConfigSource = new ConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigFile$Type extends MessageType<ConfigFile> {
    constructor() {
        super("google.api.servicemanagement.v1.ConfigFile", [
            { no: 1, name: "file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file_contents", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "file_type", kind: "enum", T: () => ["google.api.servicemanagement.v1.ConfigFile.FileType", ConfigFile_FileType] }
        ]);
    }
    create(value?: PartialMessage<ConfigFile>): ConfigFile {
        const message = { filePath: "", fileContents: new Uint8Array(0), fileType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigFile): ConfigFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_path */ 1:
                    message.filePath = reader.string();
                    break;
                case /* bytes file_contents */ 3:
                    message.fileContents = reader.bytes();
                    break;
                case /* google.api.servicemanagement.v1.ConfigFile.FileType file_type */ 4:
                    message.fileType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_path = 1; */
        if (message.filePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filePath);
        /* bytes file_contents = 3; */
        if (message.fileContents.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.fileContents);
        /* google.api.servicemanagement.v1.ConfigFile.FileType file_type = 4; */
        if (message.fileType !== 0)
            writer.tag(4, WireType.Varint).int32(message.fileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.ConfigFile
 */
export const ConfigFile = new ConfigFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigRef$Type extends MessageType<ConfigRef> {
    constructor() {
        super("google.api.servicemanagement.v1.ConfigRef", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigRef>): ConfigRef {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigRef): ConfigRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.ConfigRef
 */
export const ConfigRef = new ConfigRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeReport$Type extends MessageType<ChangeReport> {
    constructor() {
        super("google.api.servicemanagement.v1.ChangeReport", [
            { no: 1, name: "config_changes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConfigChange }
        ]);
    }
    create(value?: PartialMessage<ChangeReport>): ChangeReport {
        const message = { configChanges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeReport): ChangeReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.api.ConfigChange config_changes */ 1:
                    message.configChanges.push(ConfigChange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.api.ConfigChange config_changes = 1; */
        for (let i = 0; i < message.configChanges.length; i++)
            ConfigChange.internalBinaryWrite(message.configChanges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.ChangeReport
 */
export const ChangeReport = new ChangeReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rollout$Type extends MessageType<Rollout> {
    constructor() {
        super("google.api.servicemanagement.v1.Rollout", [
            { no: 1, name: "rollout_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 2, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 3, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "enum", T: () => ["google.api.servicemanagement.v1.Rollout.RolloutStatus", Rollout_RolloutStatus] },
            { no: 5, name: "traffic_percent_strategy", kind: "message", oneof: "strategy", T: () => Rollout_TrafficPercentStrategy },
            { no: 200, name: "delete_service_strategy", kind: "message", oneof: "strategy", T: () => Rollout_DeleteServiceStrategy },
            { no: 8, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Rollout>): Rollout {
        const message = { rolloutId: "", createdBy: "", status: 0, strategy: { oneofKind: undefined }, serviceName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Rollout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rollout): Rollout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rollout_id */ 1:
                    message.rolloutId = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 2:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 3:
                    message.createdBy = reader.string();
                    break;
                case /* google.api.servicemanagement.v1.Rollout.RolloutStatus status */ 4:
                    message.status = reader.int32();
                    break;
                case /* google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy */ 5:
                    message.strategy = {
                        oneofKind: "trafficPercentStrategy",
                        trafficPercentStrategy: Rollout_TrafficPercentStrategy.internalBinaryRead(reader, reader.uint32(), options, (message.strategy as any).trafficPercentStrategy)
                    };
                    break;
                case /* google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy */ 200:
                    message.strategy = {
                        oneofKind: "deleteServiceStrategy",
                        deleteServiceStrategy: Rollout_DeleteServiceStrategy.internalBinaryRead(reader, reader.uint32(), options, (message.strategy as any).deleteServiceStrategy)
                    };
                    break;
                case /* string service_name */ 8:
                    message.serviceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rollout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rollout_id = 1; */
        if (message.rolloutId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rolloutId);
        /* google.protobuf.Timestamp create_time = 2; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 3; */
        if (message.createdBy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.createdBy);
        /* google.api.servicemanagement.v1.Rollout.RolloutStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy = 5; */
        if (message.strategy.oneofKind === "trafficPercentStrategy")
            Rollout_TrafficPercentStrategy.internalBinaryWrite(message.strategy.trafficPercentStrategy, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy = 200; */
        if (message.strategy.oneofKind === "deleteServiceStrategy")
            Rollout_DeleteServiceStrategy.internalBinaryWrite(message.strategy.deleteServiceStrategy, writer.tag(200, WireType.LengthDelimited).fork(), options).join();
        /* string service_name = 8; */
        if (message.serviceName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.serviceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.Rollout
 */
export const Rollout = new Rollout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rollout_TrafficPercentStrategy$Type extends MessageType<Rollout_TrafficPercentStrategy> {
    constructor() {
        super("google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy", [
            { no: 1, name: "percentages", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } }
        ]);
    }
    create(value?: PartialMessage<Rollout_TrafficPercentStrategy>): Rollout_TrafficPercentStrategy {
        const message = { percentages: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Rollout_TrafficPercentStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rollout_TrafficPercentStrategy): Rollout_TrafficPercentStrategy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, double> percentages */ 1:
                    this.binaryReadMap1(message.percentages, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Rollout_TrafficPercentStrategy["percentages"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Rollout_TrafficPercentStrategy["percentages"] | undefined, val: Rollout_TrafficPercentStrategy["percentages"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.percentages");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Rollout_TrafficPercentStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, double> percentages = 1; */
        for (let k of Object.keys(message.percentages))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit64).double(message.percentages[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy
 */
export const Rollout_TrafficPercentStrategy = new Rollout_TrafficPercentStrategy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rollout_DeleteServiceStrategy$Type extends MessageType<Rollout_DeleteServiceStrategy> {
    constructor() {
        super("google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy", []);
    }
    create(value?: PartialMessage<Rollout_DeleteServiceStrategy>): Rollout_DeleteServiceStrategy {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Rollout_DeleteServiceStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rollout_DeleteServiceStrategy): Rollout_DeleteServiceStrategy {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Rollout_DeleteServiceStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy
 */
export const Rollout_DeleteServiceStrategy = new Rollout_DeleteServiceStrategy$Type();
