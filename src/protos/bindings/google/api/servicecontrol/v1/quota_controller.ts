// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/api/servicecontrol/v1/quota_controller.proto" (package "google.api.servicecontrol.v1", syntax proto3)
// tslint:disable
//
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Status } from "../../../rpc/status";
import { MetricValueSet } from "./metric_value";
/**
 * Request message for the AllocateQuota method.
 *
 * @generated from protobuf message google.api.servicecontrol.v1.AllocateQuotaRequest
 */
export interface AllocateQuotaRequest {
    /**
     * Name of the service as specified in the service configuration. For example,
     * `"pubsub.googleapis.com"`.
     *
     * See [google.api.Service][google.api.Service] for the definition of a service name.
     *
     * @generated from protobuf field: string service_name = 1;
     */
    serviceName: string;
    /**
     * Operation that describes the quota allocation.
     *
     * @generated from protobuf field: google.api.servicecontrol.v1.QuotaOperation allocate_operation = 2;
     */
    allocateOperation?: QuotaOperation;
    /**
     * Specifies which version of service configuration should be used to process
     * the request. If unspecified or no matching version can be found, the latest
     * one will be used.
     *
     * @generated from protobuf field: string service_config_id = 4;
     */
    serviceConfigId: string;
}
/**
 * Represents information regarding a quota operation.
 *
 * @generated from protobuf message google.api.servicecontrol.v1.QuotaOperation
 */
export interface QuotaOperation {
    /**
     * Identity of the operation. This is expected to be unique within the scope
     * of the service that generated the operation, and guarantees idempotency in
     * case of retries.
     *
     * In order to ensure best performance and latency in the Quota backends,
     * operation_ids are optimally associated with time, so that related
     * operations can be accessed fast in storage. For this reason, the
     * recommended token for services that intend to operate at a high QPS is
     * Unix time in nanos + UUID
     *
     * @generated from protobuf field: string operation_id = 1;
     */
    operationId: string;
    /**
     * Fully qualified name of the API method for which this quota operation is
     * requested. This name is used for matching quota rules or metric rules and
     * billing status rules defined in service configuration.
     *
     * This field should not be set if any of the following is true:
     * (1) the quota operation is performed on non-API resources.
     * (2) quota_metrics is set because the caller is doing quota override.
     *
     *
     * Example of an RPC method name:
     *     google.example.library.v1.LibraryService.CreateShelf
     *
     * @generated from protobuf field: string method_name = 2;
     */
    methodName: string;
    /**
     * Identity of the consumer for whom this quota operation is being performed.
     *
     * This can be in one of the following formats:
     *   project:<project_id>,
     *   project_number:<project_number>,
     *   api_key:<api_key>.
     *
     * @generated from protobuf field: string consumer_id = 3;
     */
    consumerId: string;
    /**
     * Labels describing the operation.
     *
     * @generated from protobuf field: map<string, string> labels = 4;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     *
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     *
     * This field is mutually exclusive with method_name.
     *
     * @generated from protobuf field: repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 5;
     */
    quotaMetrics: MetricValueSet[];
    /**
     * Quota mode for this operation.
     *
     * @generated from protobuf field: google.api.servicecontrol.v1.QuotaOperation.QuotaMode quota_mode = 6;
     */
    quotaMode: QuotaOperation_QuotaMode;
}
/**
 * Supported quota modes.
 *
 * @generated from protobuf enum google.api.servicecontrol.v1.QuotaOperation.QuotaMode
 */
export enum QuotaOperation_QuotaMode {
    /**
     * Guard against implicit default. Must not be used.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * For AllocateQuota request, allocates quota for the amount specified in
     * the service configuration or specified using the quota metrics. If the
     * amount is higher than the available quota, allocation error will be
     * returned and no quota will be allocated.
     * If multiple quotas are part of the request, and one fails, none of the
     * quotas are allocated or released.
     *
     * @generated from protobuf enum value: NORMAL = 1;
     */
    NORMAL = 1,
    /**
     * The operation allocates quota for the amount specified in the service
     * configuration or specified using the quota metrics. If the amount is
     * higher than the available quota, request does not fail but all available
     * quota will be allocated.
     * For rate quota, BEST_EFFORT will continue to deduct from other groups
     * even if one does not have enough quota. For allocation, it will find the
     * minimum available amount across all groups and deduct that amount from
     * all the affected groups.
     *
     * @generated from protobuf enum value: BEST_EFFORT = 2;
     */
    BEST_EFFORT = 2,
    /**
     * For AllocateQuota request, only checks if there is enough quota
     * available and does not change the available quota. No lock is placed on
     * the available quota either.
     *
     * @generated from protobuf enum value: CHECK_ONLY = 3;
     */
    CHECK_ONLY = 3,
    /**
     * Unimplemented. When used in AllocateQuotaRequest, this returns the
     * effective quota limit(s) in the response, and no quota check will be
     * performed. Not supported for other requests, and even for
     * AllocateQuotaRequest, this is currently supported only for allowlisted
     * services.
     *
     * @generated from protobuf enum value: QUERY_ONLY = 4;
     */
    QUERY_ONLY = 4,
    /**
     * The operation allocates quota for the amount specified in the service
     * configuration or specified using the quota metrics. If the requested
     * amount is higher than the available quota, request does not fail and
     * remaining quota would become negative (going over the limit).
     * Not supported for Rate Quota.
     *
     * @generated from protobuf enum value: ADJUST_ONLY = 5;
     */
    ADJUST_ONLY = 5
}
/**
 * Response message for the AllocateQuota method.
 *
 * @generated from protobuf message google.api.servicecontrol.v1.AllocateQuotaResponse
 */
export interface AllocateQuotaResponse {
    /**
     * The same operation_id value used in the AllocateQuotaRequest. Used for
     * logging and diagnostics purposes.
     *
     * @generated from protobuf field: string operation_id = 1;
     */
    operationId: string;
    /**
     * Indicates the decision of the allocate.
     *
     * @generated from protobuf field: repeated google.api.servicecontrol.v1.QuotaError allocate_errors = 2;
     */
    allocateErrors: QuotaError[];
    /**
     * Quota metrics to indicate the result of allocation. Depending on the
     * request, one or more of the following metrics will be included:
     *
     * 1. Per quota group or per quota metric incremental usage will be specified
     * using the following delta metric :
     *   "serviceruntime.googleapis.com/api/consumer/quota_used_count"
     *
     * 2. The quota limit reached condition will be specified using the following
     * boolean metric :
     *   "serviceruntime.googleapis.com/quota/exceeded"
     *
     * @generated from protobuf field: repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 3;
     */
    quotaMetrics: MetricValueSet[];
    /**
     * ID of the actual config used to process the request.
     *
     * @generated from protobuf field: string service_config_id = 4;
     */
    serviceConfigId: string;
}
/**
 * Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
 *
 * @generated from protobuf message google.api.servicecontrol.v1.QuotaError
 */
export interface QuotaError {
    /**
     * Error code.
     *
     * @generated from protobuf field: google.api.servicecontrol.v1.QuotaError.Code code = 1;
     */
    code: QuotaError_Code;
    /**
     * Subject to whom this error applies. See the specific enum for more details
     * on this field. For example, "clientip:<ip address of client>" or
     * "project:<Google developer project id>".
     *
     * @generated from protobuf field: string subject = 2;
     */
    subject: string;
    /**
     * Free-form text that provides details on the cause of the error.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * Contains additional information about the quota error.
     * If available, `status.code` will be non zero.
     *
     * @generated from protobuf field: google.rpc.Status status = 4;
     */
    status?: Status;
}
/**
 * Error codes related to project config validations are deprecated since the
 * quota controller methods do not perform these validations. Instead services
 * have to call the Check method, without quota_properties field, to perform
 * these validations before calling the quota controller methods. These
 * methods check only for project deletion to be wipe out compliant.
 *
 * @generated from protobuf enum google.api.servicecontrol.v1.QuotaError.Code
 */
export enum QuotaError_Code {
    /**
     * This is never used.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Quota allocation failed.
     * Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
     *
     * @generated from protobuf enum value: RESOURCE_EXHAUSTED = 8;
     */
    RESOURCE_EXHAUSTED = 8,
    /**
     * Consumer cannot access the service because the service requires active
     * billing.
     *
     * @generated from protobuf enum value: BILLING_NOT_ACTIVE = 107;
     */
    BILLING_NOT_ACTIVE = 107,
    /**
     * Consumer's project has been marked as deleted (soft deletion).
     *
     * @generated from protobuf enum value: PROJECT_DELETED = 108;
     */
    PROJECT_DELETED = 108,
    /**
     * Specified API key is invalid.
     *
     * @generated from protobuf enum value: API_KEY_INVALID = 105;
     */
    API_KEY_INVALID = 105,
    /**
     * Specified API Key has expired.
     *
     * @generated from protobuf enum value: API_KEY_EXPIRED = 112;
     */
    API_KEY_EXPIRED = 112
}
// @generated message type with reflection information, may provide speed optimized methods
class AllocateQuotaRequest$Type extends MessageType<AllocateQuotaRequest> {
    constructor() {
        super("google.api.servicecontrol.v1.AllocateQuotaRequest", [
            { no: 1, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "allocate_operation", kind: "message", T: () => QuotaOperation },
            { no: 4, name: "service_config_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AllocateQuotaRequest>): AllocateQuotaRequest {
        const message = { serviceName: "", serviceConfigId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllocateQuotaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllocateQuotaRequest): AllocateQuotaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_name */ 1:
                    message.serviceName = reader.string();
                    break;
                case /* google.api.servicecontrol.v1.QuotaOperation allocate_operation */ 2:
                    message.allocateOperation = QuotaOperation.internalBinaryRead(reader, reader.uint32(), options, message.allocateOperation);
                    break;
                case /* string service_config_id */ 4:
                    message.serviceConfigId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllocateQuotaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_name = 1; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* google.api.servicecontrol.v1.QuotaOperation allocate_operation = 2; */
        if (message.allocateOperation)
            QuotaOperation.internalBinaryWrite(message.allocateOperation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string service_config_id = 4; */
        if (message.serviceConfigId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serviceConfigId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.AllocateQuotaRequest
 */
export const AllocateQuotaRequest = new AllocateQuotaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaOperation$Type extends MessageType<QuotaOperation> {
    constructor() {
        super("google.api.servicecontrol.v1.QuotaOperation", [
            { no: 1, name: "operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consumer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "quota_metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetricValueSet },
            { no: 6, name: "quota_mode", kind: "enum", T: () => ["google.api.servicecontrol.v1.QuotaOperation.QuotaMode", QuotaOperation_QuotaMode] }
        ]);
    }
    create(value?: PartialMessage<QuotaOperation>): QuotaOperation {
        const message = { operationId: "", methodName: "", consumerId: "", labels: {}, quotaMetrics: [], quotaMode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuotaOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaOperation): QuotaOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operation_id */ 1:
                    message.operationId = reader.string();
                    break;
                case /* string method_name */ 2:
                    message.methodName = reader.string();
                    break;
                case /* string consumer_id */ 3:
                    message.consumerId = reader.string();
                    break;
                case /* map<string, string> labels */ 4:
                    this.binaryReadMap4(message.labels, reader, options);
                    break;
                case /* repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics */ 5:
                    message.quotaMetrics.push(MetricValueSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.api.servicecontrol.v1.QuotaOperation.QuotaMode quota_mode */ 6:
                    message.quotaMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: QuotaOperation["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QuotaOperation["labels"] | undefined, val: QuotaOperation["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.servicecontrol.v1.QuotaOperation.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: QuotaOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string operation_id = 1; */
        if (message.operationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operationId);
        /* string method_name = 2; */
        if (message.methodName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.methodName);
        /* string consumer_id = 3; */
        if (message.consumerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.consumerId);
        /* map<string, string> labels = 4; */
        for (let k of Object.keys(message.labels))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 5; */
        for (let i = 0; i < message.quotaMetrics.length; i++)
            MetricValueSet.internalBinaryWrite(message.quotaMetrics[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.api.servicecontrol.v1.QuotaOperation.QuotaMode quota_mode = 6; */
        if (message.quotaMode !== 0)
            writer.tag(6, WireType.Varint).int32(message.quotaMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.QuotaOperation
 */
export const QuotaOperation = new QuotaOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllocateQuotaResponse$Type extends MessageType<AllocateQuotaResponse> {
    constructor() {
        super("google.api.servicecontrol.v1.AllocateQuotaResponse", [
            { no: 1, name: "operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "allocate_errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuotaError },
            { no: 3, name: "quota_metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetricValueSet },
            { no: 4, name: "service_config_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AllocateQuotaResponse>): AllocateQuotaResponse {
        const message = { operationId: "", allocateErrors: [], quotaMetrics: [], serviceConfigId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllocateQuotaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllocateQuotaResponse): AllocateQuotaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operation_id */ 1:
                    message.operationId = reader.string();
                    break;
                case /* repeated google.api.servicecontrol.v1.QuotaError allocate_errors */ 2:
                    message.allocateErrors.push(QuotaError.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics */ 3:
                    message.quotaMetrics.push(MetricValueSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string service_config_id */ 4:
                    message.serviceConfigId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllocateQuotaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string operation_id = 1; */
        if (message.operationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operationId);
        /* repeated google.api.servicecontrol.v1.QuotaError allocate_errors = 2; */
        for (let i = 0; i < message.allocateErrors.length; i++)
            QuotaError.internalBinaryWrite(message.allocateErrors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 3; */
        for (let i = 0; i < message.quotaMetrics.length; i++)
            MetricValueSet.internalBinaryWrite(message.quotaMetrics[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string service_config_id = 4; */
        if (message.serviceConfigId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serviceConfigId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.AllocateQuotaResponse
 */
export const AllocateQuotaResponse = new AllocateQuotaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaError$Type extends MessageType<QuotaError> {
    constructor() {
        super("google.api.servicecontrol.v1.QuotaError", [
            { no: 1, name: "code", kind: "enum", T: () => ["google.api.servicecontrol.v1.QuotaError.Code", QuotaError_Code] },
            { no: 2, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<QuotaError>): QuotaError {
        const message = { code: 0, subject: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuotaError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaError): QuotaError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.servicecontrol.v1.QuotaError.Code code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string subject */ 2:
                    message.subject = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* google.rpc.Status status */ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuotaError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.servicecontrol.v1.QuotaError.Code code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string subject = 2; */
        if (message.subject !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subject);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* google.rpc.Status status = 4; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.QuotaError
 */
export const QuotaError = new QuotaError$Type();
/**
 * @generated ServiceType for protobuf service google.api.servicecontrol.v1.QuotaController
 */
export const QuotaController = new ServiceType("google.api.servicecontrol.v1.QuotaController", [
    { name: "AllocateQuota", options: { "google.api.http": { post: "/v1/services/{service_name}:allocateQuota", body: "*" } }, I: AllocateQuotaRequest, O: AllocateQuotaResponse }
], { "google.api.default_host": "servicecontrol.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/servicecontrol" });
