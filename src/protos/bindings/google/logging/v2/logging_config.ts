// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/logging/v2/logging_config.proto" (package "google.logging.v2", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { Operation } from "../../longrunning/operations";
import { Empty } from "../../protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FieldMask } from "../../protobuf/field_mask";
import { Timestamp } from "../../protobuf/timestamp";
/**
 * Describes a repository in which log entries are stored.
 *
 * @generated from protobuf message google.logging.v2.LogBucket
 */
export interface LogBucket {
    /**
     * Output only. The resource name of the bucket.
     *
     * For example:
     *
     *   `projects/my-project/locations/global/buckets/my-bucket`
     *
     * For a list of supported locations, see [Supported
     * Regions](https://cloud.google.com/logging/docs/region-support)
     *
     * For the location of `global` it is unspecified where log entries are
     * actually stored.
     *
     * After a bucket has been created, the location cannot be changed.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Describes this bucket.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * Output only. The creation timestamp of the bucket. This is not set for any of the
     * default buckets.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 4;
     */
    createTime?: Timestamp;
    /**
     * Output only. The last update timestamp of the bucket.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 5;
     */
    updateTime?: Timestamp;
    /**
     * Logs will be retained by default for this amount of time, after which they
     * will automatically be deleted. The minimum retention period is 1 day. If
     * this value is set to zero at bucket creation time, the default time of 30
     * days will be used.
     *
     * @generated from protobuf field: int32 retention_days = 11;
     */
    retentionDays: number;
    /**
     * Whether the bucket is locked.
     *
     * The retention period on a locked bucket cannot be changed. Locked buckets
     * may only be deleted if they are empty.
     *
     * @generated from protobuf field: bool locked = 9;
     */
    locked: boolean;
    /**
     * Output only. The bucket lifecycle state.
     *
     * @generated from protobuf field: google.logging.v2.LifecycleState lifecycle_state = 12;
     */
    lifecycleState: LifecycleState;
    /**
     * Log entry field paths that are denied access in this bucket.
     *
     * The following fields and their children are eligible: `textPayload`,
     * `jsonPayload`, `protoPayload`, `httpRequest`, `labels`, `sourceLocation`.
     *
     * Restricting a repeated field will restrict all values. Adding a parent will
     * block all child fields. (e.g. `foo.bar` will block `foo.bar.baz`)
     *
     * @generated from protobuf field: repeated string restricted_fields = 15;
     */
    restrictedFields: string[];
    /**
     * The CMEK settings of the log bucket. If present, new log entries written to
     * this log bucket are encrypted using the CMEK key provided in this
     * configuration. If a log bucket has CMEK settings, the CMEK settings cannot
     * be disabled later by updating the log bucket. Changing the KMS key is
     * allowed.
     *
     * @generated from protobuf field: google.logging.v2.CmekSettings cmek_settings = 19;
     */
    cmekSettings?: CmekSettings;
}
/**
 * Describes a view over log entries in a bucket.
 *
 * @generated from protobuf message google.logging.v2.LogView
 */
export interface LogView {
    /**
     * The resource name of the view.
     *
     * For example:
     *
     *   `projects/my-project/locations/global/buckets/my-bucket/views/my-view`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Describes this view.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * Output only. The creation timestamp of the view.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 4;
     */
    createTime?: Timestamp;
    /**
     * Output only. The last update timestamp of the view.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 5;
     */
    updateTime?: Timestamp;
    /**
     * Filter that restricts which log entries in a bucket are visible in this
     * view.
     *
     * Filters are restricted to be a logical AND of ==/!= of any of the
     * following:
     *
     *   - originating project/folder/organization/billing account.
     *   - resource type
     *   - log id
     *
     * For example:
     *
     *   SOURCE("projects/myproject") AND resource.type = "gce_instance"
     *                                AND LOG_ID("stdout")
     *
     * @generated from protobuf field: string filter = 7;
     */
    filter: string;
}
/**
 * Describes a sink used to export log entries to one of the following
 * destinations in any project: a Cloud Storage bucket, a BigQuery dataset, a
 * Pub/Sub topic or a Cloud Logging log bucket. A logs filter controls which log
 * entries are exported. The sink must be created within a project,
 * organization, billing account, or folder.
 *
 * @generated from protobuf message google.logging.v2.LogSink
 */
export interface LogSink {
    /**
     * Required. The client-assigned sink identifier, unique within the project.
     *
     * For example: `"my-syslog-errors-to-pubsub"`. Sink identifiers are limited
     * to 100 characters and can include only the following characters: upper and
     * lower-case alphanumeric characters, underscores, hyphens, and periods.
     * First character has to be alphanumeric.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Required. The export destination:
     *
     *     "storage.googleapis.com/[GCS_BUCKET]"
     *     "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
     *     "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
     *
     * The sink's `writer_identity`, set when the sink is created, must have
     * permission to write to the destination or else the log entries are not
     * exported. For more information, see
     * [Exporting Logs with
     * Sinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
     *
     * @generated from protobuf field: string destination = 3;
     */
    destination: string;
    /**
     * Optional. An [advanced logs
     * filter](https://cloud.google.com/logging/docs/view/advanced-queries). The
     * only exported log entries are those that are in the resource owning the
     * sink and that match the filter.
     *
     * For example:
     *
     *   `logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR`
     *
     * @generated from protobuf field: string filter = 5;
     */
    filter: string;
    /**
     * Optional. A description of this sink.
     *
     * The maximum length of the description is 8000 characters.
     *
     * @generated from protobuf field: string description = 18;
     */
    description: string;
    /**
     * Optional. If set to true, then this sink is disabled and it does not export any log
     * entries.
     *
     * @generated from protobuf field: bool disabled = 19;
     */
    disabled: boolean;
    /**
     * Optional. Log entries that match any of these exclusion filters will not be exported.
     *
     * If a log entry is matched by both `filter` and one of `exclusion_filters`
     * it will not be exported.
     *
     * @generated from protobuf field: repeated google.logging.v2.LogExclusion exclusions = 16;
     */
    exclusions: LogExclusion[];
    /**
     * Deprecated. This field is unused.
     *
     * @deprecated
     * @generated from protobuf field: google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true];
     */
    outputVersionFormat: LogSink_VersionFormat;
    /**
     * Output only. An IAM identity&mdash;a service account or group&mdash;under which Cloud
     * Logging writes the exported log entries to the sink's destination. This
     * field is set by
     * [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink] and
     * [sinks.update][google.logging.v2.ConfigServiceV2.UpdateSink] based on the
     * value of `unique_writer_identity` in those methods.
     *
     * Until you grant this identity write-access to the destination, log entry
     * exports from this sink will fail. For more information, see [Granting
     * Access for a
     * Resource](https://cloud.google.com/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource).
     * Consult the destination service's documentation to determine the
     * appropriate IAM roles to assign to the identity.
     *
     * Sinks that have a destination that is a log bucket in the same project as
     * the sink do not have a writer_identity and no additional permissions are
     * required.
     *
     * @generated from protobuf field: string writer_identity = 8;
     */
    writerIdentity: string;
    /**
     * Optional. This field applies only to sinks owned by organizations and folders. If the
     * field is false, the default, only the logs owned by the sink's parent
     * resource are available for export. If the field is true, then log entries
     * from all the projects, folders, and billing accounts contained in the
     * sink's parent resource are also available for export. Whether a particular
     * log entry from the children is exported depends on the sink's filter
     * expression.
     *
     * For example, if this field is true, then the filter
     * `resource.type=gce_instance` would export all Compute Engine VM instance
     * log entries from all projects in the sink's parent.
     *
     * To only export entries from certain child projects, filter on the project
     * part of the log name:
     *
     *   logName:("projects/test-project1/" OR "projects/test-project2/") AND
     *   resource.type=gce_instance
     *
     * @generated from protobuf field: bool include_children = 9;
     */
    includeChildren: boolean;
    /**
     * @generated from protobuf oneof: options
     */
    options: {
        oneofKind: "bigqueryOptions";
        /**
         * Optional. Options that affect sinks exporting data to BigQuery.
         *
         * @generated from protobuf field: google.logging.v2.BigQueryOptions bigquery_options = 12;
         */
        bigqueryOptions: BigQueryOptions;
    } | {
        oneofKind: undefined;
    };
    /**
     * Output only. The creation timestamp of the sink.
     *
     * This field may not be present for older sinks.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 13;
     */
    createTime?: Timestamp;
    /**
     * Output only. The last update timestamp of the sink.
     *
     * This field may not be present for older sinks.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 14;
     */
    updateTime?: Timestamp;
}
/**
 * Deprecated. This is unused.
 *
 * @generated from protobuf enum google.logging.v2.LogSink.VersionFormat
 */
export enum LogSink_VersionFormat {
    /**
     * An unspecified format version that will default to V2.
     *
     * @generated from protobuf enum value: VERSION_FORMAT_UNSPECIFIED = 0;
     */
    VERSION_FORMAT_UNSPECIFIED = 0,
    /**
     * `LogEntry` version 2 format.
     *
     * @generated from protobuf enum value: V2 = 1;
     */
    V2 = 1,
    /**
     * `LogEntry` version 1 format.
     *
     * @generated from protobuf enum value: V1 = 2;
     */
    V1 = 2
}
/**
 * Options that change functionality of a sink exporting data to BigQuery.
 *
 * @generated from protobuf message google.logging.v2.BigQueryOptions
 */
export interface BigQueryOptions {
    /**
     * Optional. Whether to use [BigQuery's partition
     * tables](https://cloud.google.com/bigquery/docs/partitioned-tables). By
     * default, Cloud Logging creates dated tables based on the log entries'
     * timestamps, e.g. syslog_20170523. With partitioned tables the date suffix
     * is no longer present and [special query
     * syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
     * has to be used instead. In both cases, tables are sharded based on UTC
     * timezone.
     *
     * @generated from protobuf field: bool use_partitioned_tables = 1;
     */
    usePartitionedTables: boolean;
    /**
     * Output only. True if new timestamp column based partitioning is in use, false if legacy
     * ingestion-time partitioning is in use.
     *
     * All new sinks will have this field set true and will use timestamp column
     * based partitioning. If use_partitioned_tables is false, this value has no
     * meaning and will be false. Legacy sinks using partitioned tables will have
     * this field set to false.
     *
     * @generated from protobuf field: bool uses_timestamp_column_partitioning = 3;
     */
    usesTimestampColumnPartitioning: boolean;
}
/**
 * The parameters to `ListBuckets`.
 *
 * @generated from protobuf message google.logging.v2.ListBucketsRequest
 */
export interface ListBucketsRequest {
    /**
     * Required. The parent resource whose buckets are to be listed:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]"
     *
     * Note: The locations portion of the resource must be specified, but
     * supplying the character `-` in place of [LOCATION_ID] will return all
     * buckets.
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Optional. If present, then retrieve the next batch of results from the preceding call
     * to this method. `pageToken` must be the value of `nextPageToken` from the
     * previous response. The values of other method parameters should be
     * identical to those in the previous call.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * Optional. The maximum number of results to return from this request. Non-positive
     * values are ignored. The presence of `nextPageToken` in the response
     * indicates that more results might be available.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
}
/**
 * The response from ListBuckets.
 *
 * @generated from protobuf message google.logging.v2.ListBucketsResponse
 */
export interface ListBucketsResponse {
    /**
     * A list of buckets.
     *
     * @generated from protobuf field: repeated google.logging.v2.LogBucket buckets = 1;
     */
    buckets: LogBucket[];
    /**
     * If there might be more results than appear in this response, then
     * `nextPageToken` is included. To get the next set of results, call the same
     * method again using the value of `nextPageToken` as `pageToken`.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * The parameters to `CreateBucket`.
 *
 * @generated from protobuf message google.logging.v2.CreateBucketRequest
 */
export interface CreateBucketRequest {
    /**
     * Required. The resource in which to create the log bucket:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global"`
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Required. A client-assigned identifier such as `"my-bucket"`. Identifiers are limited
     * to 100 characters and can include only letters, digits, underscores,
     * hyphens, and periods.
     *
     * @generated from protobuf field: string bucket_id = 2;
     */
    bucketId: string;
    /**
     * Required. The new bucket. The region specified in the new bucket must be compliant
     * with any Location Restriction Org Policy. The name field in the bucket is
     * ignored.
     *
     * @generated from protobuf field: google.logging.v2.LogBucket bucket = 3;
     */
    bucket?: LogBucket;
}
/**
 * The parameters to `UpdateBucket`.
 *
 * @generated from protobuf message google.logging.v2.UpdateBucketRequest
 */
export interface UpdateBucketRequest {
    /**
     * Required. The full resource name of the bucket to update.
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Required. The updated bucket.
     *
     * @generated from protobuf field: google.logging.v2.LogBucket bucket = 2;
     */
    bucket?: LogBucket;
    /**
     * Required. Field mask that specifies the fields in `bucket` that need an update. A
     * bucket field will be overwritten if, and only if, it is in the update mask.
     * `name` and output only fields cannot be updated.
     *
     * For a detailed `FieldMask` definition, see:
     * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask
     *
     * For example: `updateMask=retention_days`
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 4;
     */
    updateMask?: FieldMask;
}
/**
 * The parameters to `GetBucket`.
 *
 * @generated from protobuf message google.logging.v2.GetBucketRequest
 */
export interface GetBucketRequest {
    /**
     * Required. The resource name of the bucket:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to `DeleteBucket`.
 *
 * @generated from protobuf message google.logging.v2.DeleteBucketRequest
 */
export interface DeleteBucketRequest {
    /**
     * Required. The full resource name of the bucket to delete.
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to `UndeleteBucket`.
 *
 * @generated from protobuf message google.logging.v2.UndeleteBucketRequest
 */
export interface UndeleteBucketRequest {
    /**
     * Required. The full resource name of the bucket to undelete.
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to `ListViews`.
 *
 * @generated from protobuf message google.logging.v2.ListViewsRequest
 */
export interface ListViewsRequest {
    /**
     * Required. The bucket whose views are to be listed:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Optional. If present, then retrieve the next batch of results from the preceding call
     * to this method. `pageToken` must be the value of `nextPageToken` from the
     * previous response. The values of other method parameters should be
     * identical to those in the previous call.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * Optional. The maximum number of results to return from this request.
     *
     * Non-positive values are ignored. The presence of `nextPageToken` in the
     * response indicates that more results might be available.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
}
/**
 * The response from ListViews.
 *
 * @generated from protobuf message google.logging.v2.ListViewsResponse
 */
export interface ListViewsResponse {
    /**
     * A list of views.
     *
     * @generated from protobuf field: repeated google.logging.v2.LogView views = 1;
     */
    views: LogView[];
    /**
     * If there might be more results than appear in this response, then
     * `nextPageToken` is included. To get the next set of results, call the same
     * method again using the value of `nextPageToken` as `pageToken`.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * The parameters to `CreateView`.
 *
 * @generated from protobuf message google.logging.v2.CreateViewRequest
 */
export interface CreateViewRequest {
    /**
     * Required. The bucket in which to create the view
     *
     *     `"projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"`
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket"`
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Required. The id to use for this view.
     *
     * @generated from protobuf field: string view_id = 2;
     */
    viewId: string;
    /**
     * Required. The new view.
     *
     * @generated from protobuf field: google.logging.v2.LogView view = 3;
     */
    view?: LogView;
}
/**
 * The parameters to `UpdateView`.
 *
 * @generated from protobuf message google.logging.v2.UpdateViewRequest
 */
export interface UpdateViewRequest {
    /**
     * Required. The full resource name of the view to update
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Required. The updated view.
     *
     * @generated from protobuf field: google.logging.v2.LogView view = 2;
     */
    view?: LogView;
    /**
     * Optional. Field mask that specifies the fields in `view` that need
     * an update. A field will be overwritten if, and only if, it is
     * in the update mask. `name` and output only fields cannot be updated.
     *
     * For a detailed `FieldMask` definition, see
     * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask
     *
     * For example: `updateMask=filter`
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 4;
     */
    updateMask?: FieldMask;
}
/**
 * The parameters to `GetView`.
 *
 * @generated from protobuf message google.logging.v2.GetViewRequest
 */
export interface GetViewRequest {
    /**
     * Required. The resource name of the policy:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to `DeleteView`.
 *
 * @generated from protobuf message google.logging.v2.DeleteViewRequest
 */
export interface DeleteViewRequest {
    /**
     * Required. The full resource name of the view to delete:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
     *
     * For example:
     *
     *    `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to `ListSinks`.
 *
 * @generated from protobuf message google.logging.v2.ListSinksRequest
 */
export interface ListSinksRequest {
    /**
     * Required. The parent resource whose sinks are to be listed:
     *
     *     "projects/[PROJECT_ID]"
     *     "organizations/[ORGANIZATION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]"
     *     "folders/[FOLDER_ID]"
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Optional. If present, then retrieve the next batch of results from the
     * preceding call to this method. `pageToken` must be the value of
     * `nextPageToken` from the previous response. The values of other method
     * parameters should be identical to those in the previous call.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * Optional. The maximum number of results to return from this request.
     * Non-positive values are ignored. The presence of `nextPageToken` in the
     * response indicates that more results might be available.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
}
/**
 * Result returned from `ListSinks`.
 *
 * @generated from protobuf message google.logging.v2.ListSinksResponse
 */
export interface ListSinksResponse {
    /**
     * A list of sinks.
     *
     * @generated from protobuf field: repeated google.logging.v2.LogSink sinks = 1;
     */
    sinks: LogSink[];
    /**
     * If there might be more results than appear in this response, then
     * `nextPageToken` is included. To get the next set of results, call the same
     * method again using the value of `nextPageToken` as `pageToken`.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * The parameters to `GetSink`.
 *
 * @generated from protobuf message google.logging.v2.GetSinkRequest
 */
export interface GetSinkRequest {
    /**
     * Required. The resource name of the sink:
     *
     *     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
     *     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
     *     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/sinks/my-sink"`
     *
     * @generated from protobuf field: string sink_name = 1;
     */
    sinkName: string;
}
/**
 * The parameters to `CreateSink`.
 *
 * @generated from protobuf message google.logging.v2.CreateSinkRequest
 */
export interface CreateSinkRequest {
    /**
     * Required. The resource in which to create the sink:
     *
     *     "projects/[PROJECT_ID]"
     *     "organizations/[ORGANIZATION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]"
     *     "folders/[FOLDER_ID]"
     *
     * For examples:
     *
     *   `"projects/my-project"`
     *   `"organizations/123456789"`
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Required. The new sink, whose `name` parameter is a sink identifier that
     * is not already in use.
     *
     * @generated from protobuf field: google.logging.v2.LogSink sink = 2;
     */
    sink?: LogSink;
    /**
     * Optional. Determines the kind of IAM identity returned as `writer_identity`
     * in the new sink. If this value is omitted or set to false, and if the
     * sink's parent is a project, then the value returned as `writer_identity` is
     * the same group or service account used by Cloud Logging before the addition
     * of writer identities to this API. The sink's destination must be in the
     * same project as the sink itself.
     *
     * If this field is set to true, or if the sink is owned by a non-project
     * resource such as an organization, then the value of `writer_identity` will
     * be a unique service account used only for exports from the new sink. For
     * more information, see `writer_identity` in [LogSink][google.logging.v2.LogSink].
     *
     * @generated from protobuf field: bool unique_writer_identity = 3;
     */
    uniqueWriterIdentity: boolean;
}
/**
 * The parameters to `UpdateSink`.
 *
 * @generated from protobuf message google.logging.v2.UpdateSinkRequest
 */
export interface UpdateSinkRequest {
    /**
     * Required. The full resource name of the sink to update, including the parent
     * resource and the sink identifier:
     *
     *     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
     *     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
     *     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/sinks/my-sink"`
     *
     * @generated from protobuf field: string sink_name = 1;
     */
    sinkName: string;
    /**
     * Required. The updated sink, whose name is the same identifier that appears as part
     * of `sink_name`.
     *
     * @generated from protobuf field: google.logging.v2.LogSink sink = 2;
     */
    sink?: LogSink;
    /**
     * Optional. See [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink]
     * for a description of this field. When updating a sink, the effect of this
     * field on the value of `writer_identity` in the updated sink depends on both
     * the old and new values of this field:
     *
     * +   If the old and new values of this field are both false or both true,
     *     then there is no change to the sink's `writer_identity`.
     * +   If the old value is false and the new value is true, then
     *     `writer_identity` is changed to a unique service account.
     * +   It is an error if the old value is true and the new value is
     *     set to false or defaulted to false.
     *
     * @generated from protobuf field: bool unique_writer_identity = 3;
     */
    uniqueWriterIdentity: boolean;
    /**
     * Optional. Field mask that specifies the fields in `sink` that need
     * an update. A sink field will be overwritten if, and only if, it is
     * in the update mask. `name` and output only fields cannot be updated.
     *
     * An empty `updateMask` is temporarily treated as using the following mask
     * for backwards compatibility purposes:
     *
     *   `destination,filter,includeChildren`
     *
     * At some point in the future, behavior will be removed and specifying an
     * empty `updateMask` will be an error.
     *
     * For a detailed `FieldMask` definition, see
     * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask
     *
     * For example: `updateMask=filter`
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 4;
     */
    updateMask?: FieldMask;
}
/**
 * The parameters to `DeleteSink`.
 *
 * @generated from protobuf message google.logging.v2.DeleteSinkRequest
 */
export interface DeleteSinkRequest {
    /**
     * Required. The full resource name of the sink to delete, including the parent
     * resource and the sink identifier:
     *
     *     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
     *     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
     *     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/sinks/my-sink"`
     *
     * @generated from protobuf field: string sink_name = 1;
     */
    sinkName: string;
}
/**
 * Specifies a set of log entries that are filtered out by a sink. If
 * your Google Cloud resource receives a large volume of log entries, you can
 * use exclusions to reduce your chargeable logs. Note that exclusions on
 * organization-level and folder-level sinks don't apply to child resources.
 * Note also that you cannot modify the _Required sink or exclude logs from it.
 *
 * @generated from protobuf message google.logging.v2.LogExclusion
 */
export interface LogExclusion {
    /**
     * Required. A client-assigned identifier, such as `"load-balancer-exclusion"`.
     * Identifiers are limited to 100 characters and can include only letters,
     * digits, underscores, hyphens, and periods. First character has to be
     * alphanumeric.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Optional. A description of this exclusion.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * Required. An [advanced logs
     * filter](https://cloud.google.com/logging/docs/view/advanced-queries) that
     * matches the log entries to be excluded. By using the [sample
     * function](https://cloud.google.com/logging/docs/view/advanced-queries#sample),
     * you can exclude less than 100% of the matching log entries.
     *
     * For example, the following query matches 99% of low-severity log entries
     * from Google Cloud Storage buckets:
     *
     *   `resource.type=gcs_bucket severity<ERROR sample(insertId, 0.99)`
     *
     * @generated from protobuf field: string filter = 3;
     */
    filter: string;
    /**
     * Optional. If set to True, then this exclusion is disabled and it does not
     * exclude any log entries. You can [update an
     * exclusion][google.logging.v2.ConfigServiceV2.UpdateExclusion] to change the
     * value of this field.
     *
     * @generated from protobuf field: bool disabled = 4;
     */
    disabled: boolean;
    /**
     * Output only. The creation timestamp of the exclusion.
     *
     * This field may not be present for older exclusions.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The last update timestamp of the exclusion.
     *
     * This field may not be present for older exclusions.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
}
/**
 * The parameters to `ListExclusions`.
 *
 * @generated from protobuf message google.logging.v2.ListExclusionsRequest
 */
export interface ListExclusionsRequest {
    /**
     * Required. The parent resource whose exclusions are to be listed.
     *
     *     "projects/[PROJECT_ID]"
     *     "organizations/[ORGANIZATION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]"
     *     "folders/[FOLDER_ID]"
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Optional. If present, then retrieve the next batch of results from the
     * preceding call to this method. `pageToken` must be the value of
     * `nextPageToken` from the previous response. The values of other method
     * parameters should be identical to those in the previous call.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * Optional. The maximum number of results to return from this request.
     * Non-positive values are ignored. The presence of `nextPageToken` in the
     * response indicates that more results might be available.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
}
/**
 * Result returned from `ListExclusions`.
 *
 * @generated from protobuf message google.logging.v2.ListExclusionsResponse
 */
export interface ListExclusionsResponse {
    /**
     * A list of exclusions.
     *
     * @generated from protobuf field: repeated google.logging.v2.LogExclusion exclusions = 1;
     */
    exclusions: LogExclusion[];
    /**
     * If there might be more results than appear in this response, then
     * `nextPageToken` is included. To get the next set of results, call the same
     * method again using the value of `nextPageToken` as `pageToken`.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * The parameters to `GetExclusion`.
 *
 * @generated from protobuf message google.logging.v2.GetExclusionRequest
 */
export interface GetExclusionRequest {
    /**
     * Required. The resource name of an existing exclusion:
     *
     *     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
     *     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
     *     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/exclusions/my-exclusion"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to `CreateExclusion`.
 *
 * @generated from protobuf message google.logging.v2.CreateExclusionRequest
 */
export interface CreateExclusionRequest {
    /**
     * Required. The parent resource in which to create the exclusion:
     *
     *     "projects/[PROJECT_ID]"
     *     "organizations/[ORGANIZATION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]"
     *     "folders/[FOLDER_ID]"
     *
     * For examples:
     *
     *   `"projects/my-logging-project"`
     *   `"organizations/123456789"`
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Required. The new exclusion, whose `name` parameter is an exclusion name
     * that is not already used in the parent resource.
     *
     * @generated from protobuf field: google.logging.v2.LogExclusion exclusion = 2;
     */
    exclusion?: LogExclusion;
}
/**
 * The parameters to `UpdateExclusion`.
 *
 * @generated from protobuf message google.logging.v2.UpdateExclusionRequest
 */
export interface UpdateExclusionRequest {
    /**
     * Required. The resource name of the exclusion to update:
     *
     *     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
     *     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
     *     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/exclusions/my-exclusion"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Required. New values for the existing exclusion. Only the fields specified in
     * `update_mask` are relevant.
     *
     * @generated from protobuf field: google.logging.v2.LogExclusion exclusion = 2;
     */
    exclusion?: LogExclusion;
    /**
     * Required. A non-empty list of fields to change in the existing exclusion. New values
     * for the fields are taken from the corresponding fields in the
     * [LogExclusion][google.logging.v2.LogExclusion] included in this request. Fields not mentioned in
     * `update_mask` are not changed and are ignored in the request.
     *
     * For example, to change the filter and description of an exclusion,
     * specify an `update_mask` of `"filter,description"`.
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 3;
     */
    updateMask?: FieldMask;
}
/**
 * The parameters to `DeleteExclusion`.
 *
 * @generated from protobuf message google.logging.v2.DeleteExclusionRequest
 */
export interface DeleteExclusionRequest {
    /**
     * Required. The resource name of an existing exclusion to delete:
     *
     *     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
     *     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
     *     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
     *
     * For example:
     *
     *   `"projects/my-project/exclusions/my-exclusion"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to
 * [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings].
 *
 * See [Enabling CMEK for Log
 * Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
 * more information.
 *
 * @generated from protobuf message google.logging.v2.GetCmekSettingsRequest
 */
export interface GetCmekSettingsRequest {
    /**
     * Required. The resource for which to retrieve CMEK settings.
     *
     *     "projects/[PROJECT_ID]/cmekSettings"
     *     "organizations/[ORGANIZATION_ID]/cmekSettings"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
     *     "folders/[FOLDER_ID]/cmekSettings"
     *
     * For example:
     *
     *   `"organizations/12345/cmekSettings"`
     *
     * Note: CMEK for the Log Router can be configured for Google Cloud projects,
     * folders, organizations and billing accounts. Once configured for an
     * organization, it applies to all projects and folders in the Google Cloud
     * organization.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to
 * [UpdateCmekSettings][google.logging.v2.ConfigServiceV2.UpdateCmekSettings].
 *
 * See [Enabling CMEK for Log
 * Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
 * more information.
 *
 * @generated from protobuf message google.logging.v2.UpdateCmekSettingsRequest
 */
export interface UpdateCmekSettingsRequest {
    /**
     * Required. The resource name for the CMEK settings to update.
     *
     *     "projects/[PROJECT_ID]/cmekSettings"
     *     "organizations/[ORGANIZATION_ID]/cmekSettings"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
     *     "folders/[FOLDER_ID]/cmekSettings"
     *
     * For example:
     *
     *   `"organizations/12345/cmekSettings"`
     *
     * Note: CMEK for the Log Router can currently only be configured for Google
     * Cloud organizations. Once configured, it applies to all projects and
     * folders in the Google Cloud organization.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Required. The CMEK settings to update.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf field: google.logging.v2.CmekSettings cmek_settings = 2;
     */
    cmekSettings?: CmekSettings;
    /**
     * Optional. Field mask identifying which fields from `cmek_settings` should
     * be updated. A field will be overwritten if and only if it is in the update
     * mask. Output only fields cannot be updated.
     *
     * See [FieldMask][google.protobuf.FieldMask] for more information.
     *
     * For example: `"updateMask=kmsKeyName"`
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 3;
     */
    updateMask?: FieldMask;
}
/**
 * Describes the customer-managed encryption key (CMEK) settings associated with
 * a project, folder, organization, billing account, or flexible resource.
 *
 * Note: CMEK for the Log Router can currently only be configured for Google
 * Cloud organizations. Once configured, it applies to all projects and folders
 * in the Google Cloud organization.
 *
 * See [Enabling CMEK for Log
 * Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
 * more information.
 *
 * @generated from protobuf message google.logging.v2.CmekSettings
 */
export interface CmekSettings {
    /**
     * Output only. The resource name of the CMEK settings.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The resource name for the configured Cloud KMS key.
     *
     * KMS key name format:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
     *
     *
     *
     * To enable CMEK for the Log Router, set this field to a valid
     * `kms_key_name` for which the associated service account has the required
     * cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
     *
     * The Cloud KMS key used by the Log Router can be updated by changing the
     * `kms_key_name` to a new valid key name or disabled by setting the key name
     * to an empty string. Encryption operations that are in progress will be
     * completed with the key that was in use when they started. Decryption
     * operations will be completed using the key that was used at the time of
     * encryption unless access to that key has been revoked.
     *
     * To disable CMEK for the Log Router, set this field to an empty string.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf field: string kms_key_name = 2;
     */
    kmsKeyName: string;
    /**
     * Output only. The service account that will be used by the Log Router to access your
     * Cloud KMS key.
     *
     * Before enabling CMEK for Log Router, you must first assign the
     * cloudkms.cryptoKeyEncrypterDecrypter role to the service account that
     * the Log Router will use to access your Cloud KMS key. Use
     * [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings] to
     * obtain the service account ID.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf field: string service_account_id = 3;
     */
    serviceAccountId: string;
}
/**
 * The parameters to
 * [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings].
 *
 * See [Enabling CMEK for Log
 * Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
 * more information.
 *
 * @generated from protobuf message google.logging.v2.GetSettingsRequest
 */
export interface GetSettingsRequest {
    /**
     * Required. The resource for which to retrieve settings.
     *
     *     "projects/[PROJECT_ID]/settings"
     *     "organizations/[ORGANIZATION_ID]/settings"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/settings"
     *     "folders/[FOLDER_ID]/settings"
     *
     * For example:
     *
     *   `"organizations/12345/settings"`
     *
     * Note: Settings for the Log Router can be get for Google Cloud projects,
     * folders, organizations and billing accounts. Currently it can only be
     * configured for organizations. Once configured for an organization, it
     * applies to all projects and folders in the Google Cloud organization.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The parameters to
 * [UpdateSettings][google.logging.v2.ConfigServiceV2.UpdateSettings].
 *
 * See [Enabling CMEK for Log
 * Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
 * more information.
 *
 * @generated from protobuf message google.logging.v2.UpdateSettingsRequest
 */
export interface UpdateSettingsRequest {
    /**
     * Required. The resource name for the settings to update.
     *
     *     "organizations/[ORGANIZATION_ID]/settings"
     *
     * For example:
     *
     *   `"organizations/12345/settings"`
     *
     * Note: Settings for the Log Router can currently only be configured for
     * Google Cloud organizations. Once configured, it applies to all projects and
     * folders in the Google Cloud organization.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Required. The settings to update.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf field: google.logging.v2.Settings settings = 2;
     */
    settings?: Settings;
    /**
     * Optional. Field mask identifying which fields from `settings` should
     * be updated. A field will be overwritten if and only if it is in the update
     * mask. Output only fields cannot be updated.
     *
     * See [FieldMask][google.protobuf.FieldMask] for more information.
     *
     * For example: `"updateMask=kmsKeyName"`
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 3;
     */
    updateMask?: FieldMask;
}
/**
 * Describes the settings associated with a project, folder, organization,
 * billing account, or flexible resource.
 *
 * @generated from protobuf message google.logging.v2.Settings
 */
export interface Settings {
    /**
     * Output only. The resource name of the settings.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Optional. The resource name for the configured Cloud KMS key.
     *
     * KMS key name format:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
     *
     * For example:
     *
     *   `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
     *
     *
     *
     * To enable CMEK for the Log Router, set this field to a valid
     * `kms_key_name` for which the associated service account has the required
     * `roles/cloudkms.cryptoKeyEncrypterDecrypter` role assigned for the key.
     *
     * The Cloud KMS key used by the Log Router can be updated by changing the
     * `kms_key_name` to a new valid key name. Encryption operations that are in
     * progress will be completed with the key that was in use when they started.
     * Decryption operations will be completed using the key that was used at the
     * time of encryption unless access to that key has been revoked.
     *
     * To disable CMEK for the Log Router, set this field to an empty string.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf field: string kms_key_name = 2;
     */
    kmsKeyName: string;
    /**
     * Output only. The service account that will be used by the Log Router to access your
     * Cloud KMS key.
     *
     * Before enabling CMEK for Log Router, you must first assign the role
     * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to the service account that
     * the Log Router will use to access your Cloud KMS key. Use
     * [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings] to
     * obtain the service account ID.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf field: string kms_service_account_id = 3;
     */
    kmsServiceAccountId: string;
    /**
     * Optional. The Cloud region that will be used for _Default and _Required log buckets
     * for newly created projects and folders. For example `europe-west1`.
     * This setting does not affect the location of custom log buckets.
     *
     * @generated from protobuf field: string storage_location = 4;
     */
    storageLocation: string;
    /**
     * Optional. If set to true, the _Default sink in newly created projects and folders
     * will created in a disabled state. This can be used to automatically disable
     * log ingestion if there is already an aggregated sink configured in the
     * hierarchy. The _Default sink can be re-enabled manually if needed.
     *
     * @generated from protobuf field: bool disable_default_sink = 5;
     */
    disableDefaultSink: boolean;
}
/**
 * The parameters to CopyLogEntries.
 *
 * @generated from protobuf message google.logging.v2.CopyLogEntriesRequest
 */
export interface CopyLogEntriesRequest {
    /**
     * Required. Log bucket from which to copy log entries.
     *
     * For example:
     *
     *   `"projects/my-project/locations/global/buckets/my-source-bucket"`
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Optional. A filter specifying which log entries to copy. The filter must be no more
     * than 20k characters. An empty filter matches all log entries.
     *
     * @generated from protobuf field: string filter = 3;
     */
    filter: string;
    /**
     * Required. Destination to which to copy log entries.
     *
     * @generated from protobuf field: string destination = 4;
     */
    destination: string;
}
/**
 * Metadata for CopyLogEntries long running operations.
 *
 * @generated from protobuf message google.logging.v2.CopyLogEntriesMetadata
 */
export interface CopyLogEntriesMetadata {
    /**
     * The create time of an operation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 1;
     */
    startTime?: Timestamp;
    /**
     * The end time of an operation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp end_time = 2;
     */
    endTime?: Timestamp;
    /**
     * State of an operation.
     *
     * @generated from protobuf field: google.logging.v2.OperationState state = 3;
     */
    state: OperationState;
    /**
     * Identifies whether the user has requested cancellation of the operation.
     *
     * @generated from protobuf field: bool cancellation_requested = 4;
     */
    cancellationRequested: boolean;
    /**
     * CopyLogEntries RPC request.
     *
     * @generated from protobuf field: google.logging.v2.CopyLogEntriesRequest request = 5;
     */
    request?: CopyLogEntriesRequest;
    /**
     * Estimated progress of the operation (0 - 100%).
     *
     * @generated from protobuf field: int32 progress = 6;
     */
    progress: number;
    /**
     * The IAM identity of a service account that must be granted access to the
     * destination.
     *
     * If the service account is not granted permission to the destination within
     * an hour, the operation will be cancelled.
     *
     * For example: `"serviceAccount:foo@bar.com"`
     *
     * @generated from protobuf field: string writer_identity = 7;
     */
    writerIdentity: string;
}
/**
 * Response type for CopyLogEntries long running operations.
 *
 * @generated from protobuf message google.logging.v2.CopyLogEntriesResponse
 */
export interface CopyLogEntriesResponse {
    /**
     * Number of log entries copied.
     *
     * @generated from protobuf field: int64 log_entries_copied_count = 1;
     */
    logEntriesCopiedCount: bigint;
}
/**
 * LogBucket lifecycle states.
 *
 * @generated from protobuf enum google.logging.v2.LifecycleState
 */
export enum LifecycleState {
    /**
     * Unspecified state. This is only used/useful for distinguishing unset
     * values.
     *
     * @generated from protobuf enum value: LIFECYCLE_STATE_UNSPECIFIED = 0;
     */
    LIFECYCLE_STATE_UNSPECIFIED = 0,
    /**
     * The normal and active state.
     *
     * @generated from protobuf enum value: ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * The resource has been marked for deletion by the user. For some resources
     * (e.g. buckets), this can be reversed by an un-delete operation.
     *
     * @generated from protobuf enum value: DELETE_REQUESTED = 2;
     */
    DELETE_REQUESTED = 2
}
/**
 * List of different operation states.
 * High level state of the operation. This is used to report the job's
 * current state to the user. Once a long running operation is created,
 * the current state of the operation can be queried even before the
 * operation is finished and the final result is available.
 *
 * @generated from protobuf enum google.logging.v2.OperationState
 */
export enum OperationState {
    /**
     * Should not be used.
     *
     * @generated from protobuf enum value: OPERATION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * The operation is scheduled.
     *
     * @generated from protobuf enum value: OPERATION_STATE_SCHEDULED = 1;
     */
    SCHEDULED = 1,
    /**
     * Waiting for necessary permissions.
     *
     * @generated from protobuf enum value: OPERATION_STATE_WAITING_FOR_PERMISSIONS = 2;
     */
    WAITING_FOR_PERMISSIONS = 2,
    /**
     * The operation is running.
     *
     * @generated from protobuf enum value: OPERATION_STATE_RUNNING = 3;
     */
    RUNNING = 3,
    /**
     * The operation was completed successfully.
     *
     * @generated from protobuf enum value: OPERATION_STATE_SUCCEEDED = 4;
     */
    SUCCEEDED = 4,
    /**
     * The operation failed.
     *
     * @generated from protobuf enum value: OPERATION_STATE_FAILED = 5;
     */
    FAILED = 5,
    /**
     * The operation was cancelled by the user.
     *
     * @generated from protobuf enum value: OPERATION_STATE_CANCELLED = 6;
     */
    CANCELLED = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class LogBucket$Type extends MessageType<LogBucket> {
    constructor() {
        super("google.logging.v2.LogBucket", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "create_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 5, name: "update_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 11, name: "retention_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "lifecycle_state", kind: "enum", T: () => ["google.logging.v2.LifecycleState", LifecycleState], options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 15, name: "restricted_fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "cmek_settings", kind: "message", T: () => CmekSettings }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogBucket", pattern: ["projects/{project}/locations/{location}/buckets/{bucket}", "organizations/{organization}/locations/{location}/buckets/{bucket}", "folders/{folder}/locations/{location}/buckets/{bucket}", "billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}"] } });
    }
    create(value?: PartialMessage<LogBucket>): LogBucket {
        const message = { name: "", description: "", retentionDays: 0, locked: false, lifecycleState: 0, restrictedFields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogBucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogBucket): LogBucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 4:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 5:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* int32 retention_days */ 11:
                    message.retentionDays = reader.int32();
                    break;
                case /* bool locked */ 9:
                    message.locked = reader.bool();
                    break;
                case /* google.logging.v2.LifecycleState lifecycle_state */ 12:
                    message.lifecycleState = reader.int32();
                    break;
                case /* repeated string restricted_fields */ 15:
                    message.restrictedFields.push(reader.string());
                    break;
                case /* google.logging.v2.CmekSettings cmek_settings */ 19:
                    message.cmekSettings = CmekSettings.internalBinaryRead(reader, reader.uint32(), options, message.cmekSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogBucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* google.protobuf.Timestamp create_time = 4; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 5; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 retention_days = 11; */
        if (message.retentionDays !== 0)
            writer.tag(11, WireType.Varint).int32(message.retentionDays);
        /* bool locked = 9; */
        if (message.locked !== false)
            writer.tag(9, WireType.Varint).bool(message.locked);
        /* google.logging.v2.LifecycleState lifecycle_state = 12; */
        if (message.lifecycleState !== 0)
            writer.tag(12, WireType.Varint).int32(message.lifecycleState);
        /* repeated string restricted_fields = 15; */
        for (let i = 0; i < message.restrictedFields.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.restrictedFields[i]);
        /* google.logging.v2.CmekSettings cmek_settings = 19; */
        if (message.cmekSettings)
            CmekSettings.internalBinaryWrite(message.cmekSettings, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogBucket
 */
export const LogBucket = new LogBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogView$Type extends MessageType<LogView> {
    constructor() {
        super("google.logging.v2.LogView", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "create_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 5, name: "update_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 7, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogView", pattern: ["projects/{project}/locations/{location}/buckets/{bucket}/views/{view}", "organizations/{organization}/locations/{location}/buckets/{bucket}/views/{view}", "folders/{folder}/locations/{location}/buckets/{bucket}/views/{view}", "billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/views/{view}"] } });
    }
    create(value?: PartialMessage<LogView>): LogView {
        const message = { name: "", description: "", filter: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogView): LogView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 4:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 5:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string filter */ 7:
                    message.filter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* google.protobuf.Timestamp create_time = 4; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 5; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string filter = 7; */
        if (message.filter !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.filter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogView
 */
export const LogView = new LogView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogSink$Type extends MessageType<LogSink> {
    constructor() {
        super("google.logging.v2.LogSink", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "*" } } },
            { no: 5, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 18, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 19, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 16, name: "exclusions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogExclusion, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 6, name: "output_version_format", kind: "enum", T: () => ["google.logging.v2.LogSink.VersionFormat", LogSink_VersionFormat] },
            { no: 8, name: "writer_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 9, name: "include_children", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 12, name: "bigquery_options", kind: "message", oneof: "options", T: () => BigQueryOptions, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 13, name: "create_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 14, name: "update_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogSink", pattern: ["projects/{project}/sinks/{sink}", "organizations/{organization}/sinks/{sink}", "folders/{folder}/sinks/{sink}", "billingAccounts/{billing_account}/sinks/{sink}"] } });
    }
    create(value?: PartialMessage<LogSink>): LogSink {
        const message = { name: "", destination: "", filter: "", description: "", disabled: false, exclusions: [], outputVersionFormat: 0, writerIdentity: "", includeChildren: false, options: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogSink): LogSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string destination */ 3:
                    message.destination = reader.string();
                    break;
                case /* string filter */ 5:
                    message.filter = reader.string();
                    break;
                case /* string description */ 18:
                    message.description = reader.string();
                    break;
                case /* bool disabled */ 19:
                    message.disabled = reader.bool();
                    break;
                case /* repeated google.logging.v2.LogExclusion exclusions */ 16:
                    message.exclusions.push(LogExclusion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true];*/ 6:
                    message.outputVersionFormat = reader.int32();
                    break;
                case /* string writer_identity */ 8:
                    message.writerIdentity = reader.string();
                    break;
                case /* bool include_children */ 9:
                    message.includeChildren = reader.bool();
                    break;
                case /* google.logging.v2.BigQueryOptions bigquery_options */ 12:
                    message.options = {
                        oneofKind: "bigqueryOptions",
                        bigqueryOptions: BigQueryOptions.internalBinaryRead(reader, reader.uint32(), options, (message.options as any).bigqueryOptions)
                    };
                    break;
                case /* google.protobuf.Timestamp create_time */ 13:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 14:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string destination = 3; */
        if (message.destination !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.destination);
        /* string filter = 5; */
        if (message.filter !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.filter);
        /* string description = 18; */
        if (message.description !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.description);
        /* bool disabled = 19; */
        if (message.disabled !== false)
            writer.tag(19, WireType.Varint).bool(message.disabled);
        /* repeated google.logging.v2.LogExclusion exclusions = 16; */
        for (let i = 0; i < message.exclusions.length; i++)
            LogExclusion.internalBinaryWrite(message.exclusions[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true]; */
        if (message.outputVersionFormat !== 0)
            writer.tag(6, WireType.Varint).int32(message.outputVersionFormat);
        /* string writer_identity = 8; */
        if (message.writerIdentity !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.writerIdentity);
        /* bool include_children = 9; */
        if (message.includeChildren !== false)
            writer.tag(9, WireType.Varint).bool(message.includeChildren);
        /* google.logging.v2.BigQueryOptions bigquery_options = 12; */
        if (message.options.oneofKind === "bigqueryOptions")
            BigQueryOptions.internalBinaryWrite(message.options.bigqueryOptions, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 13; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 14; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogSink
 */
export const LogSink = new LogSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BigQueryOptions$Type extends MessageType<BigQueryOptions> {
    constructor() {
        super("google.logging.v2.BigQueryOptions", [
            { no: 1, name: "use_partitioned_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "uses_timestamp_column_partitioning", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ]);
    }
    create(value?: PartialMessage<BigQueryOptions>): BigQueryOptions {
        const message = { usePartitionedTables: false, usesTimestampColumnPartitioning: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BigQueryOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BigQueryOptions): BigQueryOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool use_partitioned_tables */ 1:
                    message.usePartitionedTables = reader.bool();
                    break;
                case /* bool uses_timestamp_column_partitioning */ 3:
                    message.usesTimestampColumnPartitioning = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BigQueryOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool use_partitioned_tables = 1; */
        if (message.usePartitionedTables !== false)
            writer.tag(1, WireType.Varint).bool(message.usePartitionedTables);
        /* bool uses_timestamp_column_partitioning = 3; */
        if (message.usesTimestampColumnPartitioning !== false)
            writer.tag(3, WireType.Varint).bool(message.usesTimestampColumnPartitioning);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.BigQueryOptions
 */
export const BigQueryOptions = new BigQueryOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListBucketsRequest$Type extends MessageType<ListBucketsRequest> {
    constructor() {
        super("google.logging.v2.ListBucketsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogBucket" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<ListBucketsRequest>): ListBucketsRequest {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListBucketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListBucketsRequest): ListBucketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListBucketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListBucketsRequest
 */
export const ListBucketsRequest = new ListBucketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListBucketsResponse$Type extends MessageType<ListBucketsResponse> {
    constructor() {
        super("google.logging.v2.ListBucketsResponse", [
            { no: 1, name: "buckets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogBucket },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListBucketsResponse>): ListBucketsResponse {
        const message = { buckets: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListBucketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListBucketsResponse): ListBucketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogBucket buckets */ 1:
                    message.buckets.push(LogBucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListBucketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.logging.v2.LogBucket buckets = 1; */
        for (let i = 0; i < message.buckets.length; i++)
            LogBucket.internalBinaryWrite(message.buckets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListBucketsResponse
 */
export const ListBucketsResponse = new ListBucketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateBucketRequest$Type extends MessageType<CreateBucketRequest> {
    constructor() {
        super("google.logging.v2.CreateBucketRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogBucket" } } },
            { no: 2, name: "bucket_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "bucket", kind: "message", T: () => LogBucket, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<CreateBucketRequest>): CreateBucketRequest {
        const message = { parent: "", bucketId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateBucketRequest): CreateBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string bucket_id */ 2:
                    message.bucketId = reader.string();
                    break;
                case /* google.logging.v2.LogBucket bucket */ 3:
                    message.bucket = LogBucket.internalBinaryRead(reader, reader.uint32(), options, message.bucket);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string bucket_id = 2; */
        if (message.bucketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bucketId);
        /* google.logging.v2.LogBucket bucket = 3; */
        if (message.bucket)
            LogBucket.internalBinaryWrite(message.bucket, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateBucketRequest
 */
export const CreateBucketRequest = new CreateBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateBucketRequest$Type extends MessageType<UpdateBucketRequest> {
    constructor() {
        super("google.logging.v2.UpdateBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } },
            { no: 2, name: "bucket", kind: "message", T: () => LogBucket, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "update_mask", kind: "message", T: () => FieldMask, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateBucketRequest>): UpdateBucketRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateBucketRequest): UpdateBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.LogBucket bucket */ 2:
                    message.bucket = LogBucket.internalBinaryRead(reader, reader.uint32(), options, message.bucket);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 4:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.LogBucket bucket = 2; */
        if (message.bucket)
            LogBucket.internalBinaryWrite(message.bucket, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 4; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateBucketRequest
 */
export const UpdateBucketRequest = new UpdateBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBucketRequest$Type extends MessageType<GetBucketRequest> {
    constructor() {
        super("google.logging.v2.GetBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } }
        ]);
    }
    create(value?: PartialMessage<GetBucketRequest>): GetBucketRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBucketRequest): GetBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetBucketRequest
 */
export const GetBucketRequest = new GetBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteBucketRequest$Type extends MessageType<DeleteBucketRequest> {
    constructor() {
        super("google.logging.v2.DeleteBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } }
        ]);
    }
    create(value?: PartialMessage<DeleteBucketRequest>): DeleteBucketRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteBucketRequest): DeleteBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteBucketRequest
 */
export const DeleteBucketRequest = new DeleteBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndeleteBucketRequest$Type extends MessageType<UndeleteBucketRequest> {
    constructor() {
        super("google.logging.v2.UndeleteBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } }
        ]);
    }
    create(value?: PartialMessage<UndeleteBucketRequest>): UndeleteBucketRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UndeleteBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UndeleteBucketRequest): UndeleteBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UndeleteBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UndeleteBucketRequest
 */
export const UndeleteBucketRequest = new UndeleteBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListViewsRequest$Type extends MessageType<ListViewsRequest> {
    constructor() {
        super("google.logging.v2.ListViewsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<ListViewsRequest>): ListViewsRequest {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListViewsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListViewsRequest): ListViewsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListViewsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListViewsRequest
 */
export const ListViewsRequest = new ListViewsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListViewsResponse$Type extends MessageType<ListViewsResponse> {
    constructor() {
        super("google.logging.v2.ListViewsResponse", [
            { no: 1, name: "views", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogView },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListViewsResponse>): ListViewsResponse {
        const message = { views: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListViewsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListViewsResponse): ListViewsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogView views */ 1:
                    message.views.push(LogView.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListViewsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.logging.v2.LogView views = 1; */
        for (let i = 0; i < message.views.length; i++)
            LogView.internalBinaryWrite(message.views[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListViewsResponse
 */
export const ListViewsResponse = new ListViewsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateViewRequest$Type extends MessageType<CreateViewRequest> {
    constructor() {
        super("google.logging.v2.CreateViewRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "view_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "view", kind: "message", T: () => LogView, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<CreateViewRequest>): CreateViewRequest {
        const message = { parent: "", viewId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateViewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateViewRequest): CreateViewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string view_id */ 2:
                    message.viewId = reader.string();
                    break;
                case /* google.logging.v2.LogView view */ 3:
                    message.view = LogView.internalBinaryRead(reader, reader.uint32(), options, message.view);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateViewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string view_id = 2; */
        if (message.viewId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.viewId);
        /* google.logging.v2.LogView view = 3; */
        if (message.view)
            LogView.internalBinaryWrite(message.view, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateViewRequest
 */
export const CreateViewRequest = new CreateViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateViewRequest$Type extends MessageType<UpdateViewRequest> {
    constructor() {
        super("google.logging.v2.UpdateViewRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "view", kind: "message", T: () => LogView, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "update_mask", kind: "message", T: () => FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateViewRequest>): UpdateViewRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateViewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateViewRequest): UpdateViewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.LogView view */ 2:
                    message.view = LogView.internalBinaryRead(reader, reader.uint32(), options, message.view);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 4:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateViewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.LogView view = 2; */
        if (message.view)
            LogView.internalBinaryWrite(message.view, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 4; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateViewRequest
 */
export const UpdateViewRequest = new UpdateViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetViewRequest$Type extends MessageType<GetViewRequest> {
    constructor() {
        super("google.logging.v2.GetViewRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogView" } } }
        ]);
    }
    create(value?: PartialMessage<GetViewRequest>): GetViewRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetViewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetViewRequest): GetViewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetViewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetViewRequest
 */
export const GetViewRequest = new GetViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteViewRequest$Type extends MessageType<DeleteViewRequest> {
    constructor() {
        super("google.logging.v2.DeleteViewRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogView" } } }
        ]);
    }
    create(value?: PartialMessage<DeleteViewRequest>): DeleteViewRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteViewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteViewRequest): DeleteViewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteViewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteViewRequest
 */
export const DeleteViewRequest = new DeleteViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSinksRequest$Type extends MessageType<ListSinksRequest> {
    constructor() {
        super("google.logging.v2.ListSinksRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogSink" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<ListSinksRequest>): ListSinksRequest {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListSinksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSinksRequest): ListSinksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSinksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListSinksRequest
 */
export const ListSinksRequest = new ListSinksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSinksResponse$Type extends MessageType<ListSinksResponse> {
    constructor() {
        super("google.logging.v2.ListSinksResponse", [
            { no: 1, name: "sinks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogSink },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListSinksResponse>): ListSinksResponse {
        const message = { sinks: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListSinksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSinksResponse): ListSinksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogSink sinks */ 1:
                    message.sinks.push(LogSink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSinksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.logging.v2.LogSink sinks = 1; */
        for (let i = 0; i < message.sinks.length; i++)
            LogSink.internalBinaryWrite(message.sinks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListSinksResponse
 */
export const ListSinksResponse = new ListSinksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSinkRequest$Type extends MessageType<GetSinkRequest> {
    constructor() {
        super("google.logging.v2.GetSinkRequest", [
            { no: 1, name: "sink_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogSink" } } }
        ]);
    }
    create(value?: PartialMessage<GetSinkRequest>): GetSinkRequest {
        const message = { sinkName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSinkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSinkRequest): GetSinkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sink_name */ 1:
                    message.sinkName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSinkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sink_name = 1; */
        if (message.sinkName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sinkName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetSinkRequest
 */
export const GetSinkRequest = new GetSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSinkRequest$Type extends MessageType<CreateSinkRequest> {
    constructor() {
        super("google.logging.v2.CreateSinkRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogSink" } } },
            { no: 2, name: "sink", kind: "message", T: () => LogSink, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "unique_writer_identity", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<CreateSinkRequest>): CreateSinkRequest {
        const message = { parent: "", uniqueWriterIdentity: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateSinkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSinkRequest): CreateSinkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* google.logging.v2.LogSink sink */ 2:
                    message.sink = LogSink.internalBinaryRead(reader, reader.uint32(), options, message.sink);
                    break;
                case /* bool unique_writer_identity */ 3:
                    message.uniqueWriterIdentity = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSinkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* google.logging.v2.LogSink sink = 2; */
        if (message.sink)
            LogSink.internalBinaryWrite(message.sink, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool unique_writer_identity = 3; */
        if (message.uniqueWriterIdentity !== false)
            writer.tag(3, WireType.Varint).bool(message.uniqueWriterIdentity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateSinkRequest
 */
export const CreateSinkRequest = new CreateSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSinkRequest$Type extends MessageType<UpdateSinkRequest> {
    constructor() {
        super("google.logging.v2.UpdateSinkRequest", [
            { no: 1, name: "sink_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogSink" } } },
            { no: 2, name: "sink", kind: "message", T: () => LogSink, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "unique_writer_identity", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 4, name: "update_mask", kind: "message", T: () => FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateSinkRequest>): UpdateSinkRequest {
        const message = { sinkName: "", uniqueWriterIdentity: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateSinkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateSinkRequest): UpdateSinkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sink_name */ 1:
                    message.sinkName = reader.string();
                    break;
                case /* google.logging.v2.LogSink sink */ 2:
                    message.sink = LogSink.internalBinaryRead(reader, reader.uint32(), options, message.sink);
                    break;
                case /* bool unique_writer_identity */ 3:
                    message.uniqueWriterIdentity = reader.bool();
                    break;
                case /* google.protobuf.FieldMask update_mask */ 4:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateSinkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sink_name = 1; */
        if (message.sinkName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sinkName);
        /* google.logging.v2.LogSink sink = 2; */
        if (message.sink)
            LogSink.internalBinaryWrite(message.sink, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool unique_writer_identity = 3; */
        if (message.uniqueWriterIdentity !== false)
            writer.tag(3, WireType.Varint).bool(message.uniqueWriterIdentity);
        /* google.protobuf.FieldMask update_mask = 4; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateSinkRequest
 */
export const UpdateSinkRequest = new UpdateSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSinkRequest$Type extends MessageType<DeleteSinkRequest> {
    constructor() {
        super("google.logging.v2.DeleteSinkRequest", [
            { no: 1, name: "sink_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogSink" } } }
        ]);
    }
    create(value?: PartialMessage<DeleteSinkRequest>): DeleteSinkRequest {
        const message = { sinkName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteSinkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSinkRequest): DeleteSinkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sink_name */ 1:
                    message.sinkName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSinkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sink_name = 1; */
        if (message.sinkName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sinkName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteSinkRequest
 */
export const DeleteSinkRequest = new DeleteSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogExclusion$Type extends MessageType<LogExclusion> {
    constructor() {
        super("google.logging.v2.LogExclusion", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogExclusion", pattern: ["projects/{project}/exclusions/{exclusion}", "organizations/{organization}/exclusions/{exclusion}", "folders/{folder}/exclusions/{exclusion}", "billingAccounts/{billing_account}/exclusions/{exclusion}"] } });
    }
    create(value?: PartialMessage<LogExclusion>): LogExclusion {
        const message = { name: "", description: "", filter: "", disabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogExclusion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogExclusion): LogExclusion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string filter */ 3:
                    message.filter = reader.string();
                    break;
                case /* bool disabled */ 4:
                    message.disabled = reader.bool();
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogExclusion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string filter = 3; */
        if (message.filter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.filter);
        /* bool disabled = 4; */
        if (message.disabled !== false)
            writer.tag(4, WireType.Varint).bool(message.disabled);
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogExclusion
 */
export const LogExclusion = new LogExclusion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListExclusionsRequest$Type extends MessageType<ListExclusionsRequest> {
    constructor() {
        super("google.logging.v2.ListExclusionsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogExclusion" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<ListExclusionsRequest>): ListExclusionsRequest {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListExclusionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListExclusionsRequest): ListExclusionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListExclusionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListExclusionsRequest
 */
export const ListExclusionsRequest = new ListExclusionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListExclusionsResponse$Type extends MessageType<ListExclusionsResponse> {
    constructor() {
        super("google.logging.v2.ListExclusionsResponse", [
            { no: 1, name: "exclusions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogExclusion },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListExclusionsResponse>): ListExclusionsResponse {
        const message = { exclusions: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListExclusionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListExclusionsResponse): ListExclusionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogExclusion exclusions */ 1:
                    message.exclusions.push(LogExclusion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListExclusionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.logging.v2.LogExclusion exclusions = 1; */
        for (let i = 0; i < message.exclusions.length; i++)
            LogExclusion.internalBinaryWrite(message.exclusions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListExclusionsResponse
 */
export const ListExclusionsResponse = new ListExclusionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExclusionRequest$Type extends MessageType<GetExclusionRequest> {
    constructor() {
        super("google.logging.v2.GetExclusionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogExclusion" } } }
        ]);
    }
    create(value?: PartialMessage<GetExclusionRequest>): GetExclusionRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExclusionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExclusionRequest): GetExclusionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExclusionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetExclusionRequest
 */
export const GetExclusionRequest = new GetExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateExclusionRequest$Type extends MessageType<CreateExclusionRequest> {
    constructor() {
        super("google.logging.v2.CreateExclusionRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogExclusion" } } },
            { no: 2, name: "exclusion", kind: "message", T: () => LogExclusion, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<CreateExclusionRequest>): CreateExclusionRequest {
        const message = { parent: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateExclusionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateExclusionRequest): CreateExclusionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* google.logging.v2.LogExclusion exclusion */ 2:
                    message.exclusion = LogExclusion.internalBinaryRead(reader, reader.uint32(), options, message.exclusion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateExclusionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* google.logging.v2.LogExclusion exclusion = 2; */
        if (message.exclusion)
            LogExclusion.internalBinaryWrite(message.exclusion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateExclusionRequest
 */
export const CreateExclusionRequest = new CreateExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateExclusionRequest$Type extends MessageType<UpdateExclusionRequest> {
    constructor() {
        super("google.logging.v2.UpdateExclusionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogExclusion" } } },
            { no: 2, name: "exclusion", kind: "message", T: () => LogExclusion, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "update_mask", kind: "message", T: () => FieldMask, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateExclusionRequest>): UpdateExclusionRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateExclusionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateExclusionRequest): UpdateExclusionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.LogExclusion exclusion */ 2:
                    message.exclusion = LogExclusion.internalBinaryRead(reader, reader.uint32(), options, message.exclusion);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 3:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateExclusionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.LogExclusion exclusion = 2; */
        if (message.exclusion)
            LogExclusion.internalBinaryWrite(message.exclusion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 3; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateExclusionRequest
 */
export const UpdateExclusionRequest = new UpdateExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteExclusionRequest$Type extends MessageType<DeleteExclusionRequest> {
    constructor() {
        super("google.logging.v2.DeleteExclusionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogExclusion" } } }
        ]);
    }
    create(value?: PartialMessage<DeleteExclusionRequest>): DeleteExclusionRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteExclusionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteExclusionRequest): DeleteExclusionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteExclusionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteExclusionRequest
 */
export const DeleteExclusionRequest = new DeleteExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCmekSettingsRequest$Type extends MessageType<GetCmekSettingsRequest> {
    constructor() {
        super("google.logging.v2.GetCmekSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/CmekSettings" } } }
        ]);
    }
    create(value?: PartialMessage<GetCmekSettingsRequest>): GetCmekSettingsRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCmekSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCmekSettingsRequest): GetCmekSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCmekSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetCmekSettingsRequest
 */
export const GetCmekSettingsRequest = new GetCmekSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCmekSettingsRequest$Type extends MessageType<UpdateCmekSettingsRequest> {
    constructor() {
        super("google.logging.v2.UpdateCmekSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "cmek_settings", kind: "message", T: () => CmekSettings, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "update_mask", kind: "message", T: () => FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateCmekSettingsRequest>): UpdateCmekSettingsRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateCmekSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCmekSettingsRequest): UpdateCmekSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.CmekSettings cmek_settings */ 2:
                    message.cmekSettings = CmekSettings.internalBinaryRead(reader, reader.uint32(), options, message.cmekSettings);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 3:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCmekSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.CmekSettings cmek_settings = 2; */
        if (message.cmekSettings)
            CmekSettings.internalBinaryWrite(message.cmekSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 3; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateCmekSettingsRequest
 */
export const UpdateCmekSettingsRequest = new UpdateCmekSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CmekSettings$Type extends MessageType<CmekSettings> {
    constructor() {
        super("google.logging.v2.CmekSettings", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 2, name: "kms_key_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "service_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/CmekSettings", pattern: ["projects/{project}/cmekSettings", "organizations/{organization}/cmekSettings", "folders/{folder}/cmekSettings", "billingAccounts/{billing_account}/cmekSettings"] } });
    }
    create(value?: PartialMessage<CmekSettings>): CmekSettings {
        const message = { name: "", kmsKeyName: "", serviceAccountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CmekSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CmekSettings): CmekSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string kms_key_name */ 2:
                    message.kmsKeyName = reader.string();
                    break;
                case /* string service_account_id */ 3:
                    message.serviceAccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CmekSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string kms_key_name = 2; */
        if (message.kmsKeyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kmsKeyName);
        /* string service_account_id = 3; */
        if (message.serviceAccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serviceAccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CmekSettings
 */
export const CmekSettings = new CmekSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSettingsRequest$Type extends MessageType<GetSettingsRequest> {
    constructor() {
        super("google.logging.v2.GetSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/Settings" } } }
        ]);
    }
    create(value?: PartialMessage<GetSettingsRequest>): GetSettingsRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSettingsRequest): GetSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetSettingsRequest
 */
export const GetSettingsRequest = new GetSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSettingsRequest$Type extends MessageType<UpdateSettingsRequest> {
    constructor() {
        super("google.logging.v2.UpdateSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "settings", kind: "message", T: () => Settings, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "update_mask", kind: "message", T: () => FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateSettingsRequest>): UpdateSettingsRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateSettingsRequest): UpdateSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.Settings settings */ 2:
                    message.settings = Settings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 3:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.Settings settings = 2; */
        if (message.settings)
            Settings.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 3; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateSettingsRequest
 */
export const UpdateSettingsRequest = new UpdateSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Settings$Type extends MessageType<Settings> {
    constructor() {
        super("google.logging.v2.Settings", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 2, name: "kms_key_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "kms_service_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 4, name: "storage_location", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 5, name: "disable_default_sink", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/Settings", pattern: ["projects/{project}/settings", "organizations/{organization}/settings", "folders/{folder}/settings", "billingAccounts/{billing_account}/settings"] } });
    }
    create(value?: PartialMessage<Settings>): Settings {
        const message = { name: "", kmsKeyName: "", kmsServiceAccountId: "", storageLocation: "", disableDefaultSink: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Settings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Settings): Settings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string kms_key_name */ 2:
                    message.kmsKeyName = reader.string();
                    break;
                case /* string kms_service_account_id */ 3:
                    message.kmsServiceAccountId = reader.string();
                    break;
                case /* string storage_location */ 4:
                    message.storageLocation = reader.string();
                    break;
                case /* bool disable_default_sink */ 5:
                    message.disableDefaultSink = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Settings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string kms_key_name = 2; */
        if (message.kmsKeyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kmsKeyName);
        /* string kms_service_account_id = 3; */
        if (message.kmsServiceAccountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.kmsServiceAccountId);
        /* string storage_location = 4; */
        if (message.storageLocation !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.storageLocation);
        /* bool disable_default_sink = 5; */
        if (message.disableDefaultSink !== false)
            writer.tag(5, WireType.Varint).bool(message.disableDefaultSink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.Settings
 */
export const Settings = new Settings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyLogEntriesRequest$Type extends MessageType<CopyLogEntriesRequest> {
    constructor() {
        super("google.logging.v2.CopyLogEntriesRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 4, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<CopyLogEntriesRequest>): CopyLogEntriesRequest {
        const message = { name: "", filter: "", destination: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyLogEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyLogEntriesRequest): CopyLogEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string filter */ 3:
                    message.filter = reader.string();
                    break;
                case /* string destination */ 4:
                    message.destination = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyLogEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string filter = 3; */
        if (message.filter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.filter);
        /* string destination = 4; */
        if (message.destination !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.destination);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CopyLogEntriesRequest
 */
export const CopyLogEntriesRequest = new CopyLogEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyLogEntriesMetadata$Type extends MessageType<CopyLogEntriesMetadata> {
    constructor() {
        super("google.logging.v2.CopyLogEntriesMetadata", [
            { no: 1, name: "start_time", kind: "message", T: () => Timestamp },
            { no: 2, name: "end_time", kind: "message", T: () => Timestamp },
            { no: 3, name: "state", kind: "enum", T: () => ["google.logging.v2.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 4, name: "cancellation_requested", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "request", kind: "message", T: () => CopyLogEntriesRequest },
            { no: 6, name: "progress", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "writer_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CopyLogEntriesMetadata>): CopyLogEntriesMetadata {
        const message = { state: 0, cancellationRequested: false, progress: 0, writerIdentity: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyLogEntriesMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyLogEntriesMetadata): CopyLogEntriesMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start_time */ 1:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp end_time */ 2:
                    message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                case /* google.logging.v2.OperationState state */ 3:
                    message.state = reader.int32();
                    break;
                case /* bool cancellation_requested */ 4:
                    message.cancellationRequested = reader.bool();
                    break;
                case /* google.logging.v2.CopyLogEntriesRequest request */ 5:
                    message.request = CopyLogEntriesRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* int32 progress */ 6:
                    message.progress = reader.int32();
                    break;
                case /* string writer_identity */ 7:
                    message.writerIdentity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyLogEntriesMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start_time = 1; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end_time = 2; */
        if (message.endTime)
            Timestamp.internalBinaryWrite(message.endTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.logging.v2.OperationState state = 3; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        /* bool cancellation_requested = 4; */
        if (message.cancellationRequested !== false)
            writer.tag(4, WireType.Varint).bool(message.cancellationRequested);
        /* google.logging.v2.CopyLogEntriesRequest request = 5; */
        if (message.request)
            CopyLogEntriesRequest.internalBinaryWrite(message.request, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 progress = 6; */
        if (message.progress !== 0)
            writer.tag(6, WireType.Varint).int32(message.progress);
        /* string writer_identity = 7; */
        if (message.writerIdentity !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.writerIdentity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CopyLogEntriesMetadata
 */
export const CopyLogEntriesMetadata = new CopyLogEntriesMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyLogEntriesResponse$Type extends MessageType<CopyLogEntriesResponse> {
    constructor() {
        super("google.logging.v2.CopyLogEntriesResponse", [
            { no: 1, name: "log_entries_copied_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CopyLogEntriesResponse>): CopyLogEntriesResponse {
        const message = { logEntriesCopiedCount: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyLogEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyLogEntriesResponse): CopyLogEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 log_entries_copied_count */ 1:
                    message.logEntriesCopiedCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyLogEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 log_entries_copied_count = 1; */
        if (message.logEntriesCopiedCount !== 0n)
            writer.tag(1, WireType.Varint).int64(message.logEntriesCopiedCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CopyLogEntriesResponse
 */
export const CopyLogEntriesResponse = new CopyLogEntriesResponse$Type();
/**
 * @generated ServiceType for protobuf service google.logging.v2.ConfigServiceV2
 */
export const ConfigServiceV2 = new ServiceType("google.logging.v2.ConfigServiceV2", [
    { name: "ListBuckets", options: { "google.api.http": { get: "/v2/{parent=*/*/locations/*}/buckets", additionalBindings: [{ get: "/v2/{parent=projects/*/locations/*}/buckets" }, { get: "/v2/{parent=organizations/*/locations/*}/buckets" }, { get: "/v2/{parent=folders/*/locations/*}/buckets" }, { get: "/v2/{parent=billingAccounts/*/locations/*}/buckets" }] }, "google.api.method_signature": ["parent"] }, I: ListBucketsRequest, O: ListBucketsResponse },
    { name: "GetBucket", options: { "google.api.http": { get: "/v2/{name=*/*/locations/*/buckets/*}", additionalBindings: [{ get: "/v2/{name=projects/*/locations/*/buckets/*}" }, { get: "/v2/{name=organizations/*/locations/*/buckets/*}" }, { get: "/v2/{name=folders/*/locations/*/buckets/*}" }, { get: "/v2/{name=billingAccounts/*/buckets/*}" }] } }, I: GetBucketRequest, O: LogBucket },
    { name: "CreateBucket", options: { "google.api.http": { post: "/v2/{parent=*/*/locations/*}/buckets", body: "bucket", additionalBindings: [{ post: "/v2/{parent=projects/*/locations/*}/buckets", body: "bucket" }, { post: "/v2/{parent=organizations/*/locations/*}/buckets", body: "bucket" }, { post: "/v2/{parent=folders/*/locations/*}/buckets", body: "bucket" }, { post: "/v2/{parent=billingAccounts/*/locations/*}/buckets", body: "bucket" }] } }, I: CreateBucketRequest, O: LogBucket },
    { name: "UpdateBucket", options: { "google.api.http": { patch: "/v2/{name=*/*/locations/*/buckets/*}", body: "bucket", additionalBindings: [{ patch: "/v2/{name=projects/*/locations/*/buckets/*}", body: "bucket" }, { patch: "/v2/{name=organizations/*/locations/*/buckets/*}", body: "bucket" }, { patch: "/v2/{name=folders/*/locations/*/buckets/*}", body: "bucket" }, { patch: "/v2/{name=billingAccounts/*/locations/*/buckets/*}", body: "bucket" }] } }, I: UpdateBucketRequest, O: LogBucket },
    { name: "DeleteBucket", options: { "google.api.http": { delete: "/v2/{name=*/*/locations/*/buckets/*}", additionalBindings: [{ delete: "/v2/{name=projects/*/locations/*/buckets/*}" }, { delete: "/v2/{name=organizations/*/locations/*/buckets/*}" }, { delete: "/v2/{name=folders/*/locations/*/buckets/*}" }, { delete: "/v2/{name=billingAccounts/*/locations/*/buckets/*}" }] } }, I: DeleteBucketRequest, O: Empty },
    { name: "UndeleteBucket", options: { "google.api.http": { post: "/v2/{name=*/*/locations/*/buckets/*}:undelete", body: "*", additionalBindings: [{ post: "/v2/{name=projects/*/locations/*/buckets/*}:undelete", body: "*" }, { post: "/v2/{name=organizations/*/locations/*/buckets/*}:undelete", body: "*" }, { post: "/v2/{name=folders/*/locations/*/buckets/*}:undelete", body: "*" }, { post: "/v2/{name=billingAccounts/*/locations/*/buckets/*}:undelete", body: "*" }] } }, I: UndeleteBucketRequest, O: Empty },
    { name: "ListViews", options: { "google.api.http": { get: "/v2/{parent=*/*/locations/*/buckets/*}/views", additionalBindings: [{ get: "/v2/{parent=projects/*/locations/*/buckets/*}/views" }, { get: "/v2/{parent=organizations/*/locations/*/buckets/*}/views" }, { get: "/v2/{parent=folders/*/locations/*/buckets/*}/views" }, { get: "/v2/{parent=billingAccounts/*/locations/*/buckets/*}/views" }] }, "google.api.method_signature": ["parent"] }, I: ListViewsRequest, O: ListViewsResponse },
    { name: "GetView", options: { "google.api.http": { get: "/v2/{name=*/*/locations/*/buckets/*/views/*}", additionalBindings: [{ get: "/v2/{name=projects/*/locations/*/buckets/*/views/*}" }, { get: "/v2/{name=organizations/*/locations/*/buckets/*/views/*}" }, { get: "/v2/{name=folders/*/locations/*/buckets/*/views/*}" }, { get: "/v2/{name=billingAccounts/*/buckets/*/views/*}" }] } }, I: GetViewRequest, O: LogView },
    { name: "CreateView", options: { "google.api.http": { post: "/v2/{parent=*/*/locations/*/buckets/*}/views", body: "view", additionalBindings: [{ post: "/v2/{parent=projects/*/locations/*/buckets/*}/views", body: "view" }, { post: "/v2/{parent=organizations/*/locations/*/buckets/*}/views", body: "view" }, { post: "/v2/{parent=folders/*/locations/*/buckets/*}/views", body: "view" }, { post: "/v2/{parent=billingAccounts/*/locations/*/buckets/*}/views", body: "view" }] } }, I: CreateViewRequest, O: LogView },
    { name: "UpdateView", options: { "google.api.http": { patch: "/v2/{name=*/*/locations/*/buckets/*/views/*}", body: "view", additionalBindings: [{ patch: "/v2/{name=projects/*/locations/*/buckets/*/views/*}", body: "view" }, { patch: "/v2/{name=organizations/*/locations/*/buckets/*/views/*}", body: "view" }, { patch: "/v2/{name=folders/*/locations/*/buckets/*/views/*}", body: "view" }, { patch: "/v2/{name=billingAccounts/*/locations/*/buckets/*/views/*}", body: "view" }] } }, I: UpdateViewRequest, O: LogView },
    { name: "DeleteView", options: { "google.api.http": { delete: "/v2/{name=*/*/locations/*/buckets/*/views/*}", additionalBindings: [{ delete: "/v2/{name=projects/*/locations/*/buckets/*/views/*}" }, { delete: "/v2/{name=organizations/*/locations/*/buckets/*/views/*}" }, { delete: "/v2/{name=folders/*/locations/*/buckets/*/views/*}" }, { delete: "/v2/{name=billingAccounts/*/locations/*/buckets/*/views/*}" }] } }, I: DeleteViewRequest, O: Empty },
    { name: "ListSinks", options: { "google.api.http": { get: "/v2/{parent=*/*}/sinks", additionalBindings: [{ get: "/v2/{parent=projects/*}/sinks" }, { get: "/v2/{parent=organizations/*}/sinks" }, { get: "/v2/{parent=folders/*}/sinks" }, { get: "/v2/{parent=billingAccounts/*}/sinks" }] }, "google.api.method_signature": ["parent"] }, I: ListSinksRequest, O: ListSinksResponse },
    { name: "GetSink", options: { "google.api.http": { get: "/v2/{sink_name=*/*/sinks/*}", additionalBindings: [{ get: "/v2/{sink_name=projects/*/sinks/*}" }, { get: "/v2/{sink_name=organizations/*/sinks/*}" }, { get: "/v2/{sink_name=folders/*/sinks/*}" }, { get: "/v2/{sink_name=billingAccounts/*/sinks/*}" }] }, "google.api.method_signature": ["sink_name"] }, I: GetSinkRequest, O: LogSink },
    { name: "CreateSink", options: { "google.api.http": { post: "/v2/{parent=*/*}/sinks", body: "sink", additionalBindings: [{ post: "/v2/{parent=projects/*}/sinks", body: "sink" }, { post: "/v2/{parent=organizations/*}/sinks", body: "sink" }, { post: "/v2/{parent=folders/*}/sinks", body: "sink" }, { post: "/v2/{parent=billingAccounts/*}/sinks", body: "sink" }] }, "google.api.method_signature": ["parent,sink"] }, I: CreateSinkRequest, O: LogSink },
    { name: "UpdateSink", options: { "google.api.http": { put: "/v2/{sink_name=*/*/sinks/*}", body: "sink", additionalBindings: [{ put: "/v2/{sink_name=projects/*/sinks/*}", body: "sink" }, { put: "/v2/{sink_name=organizations/*/sinks/*}", body: "sink" }, { put: "/v2/{sink_name=folders/*/sinks/*}", body: "sink" }, { put: "/v2/{sink_name=billingAccounts/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=projects/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=organizations/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=folders/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=billingAccounts/*/sinks/*}", body: "sink" }] }, "google.api.method_signature": ["sink_name,sink,update_mask", "sink_name,sink"] }, I: UpdateSinkRequest, O: LogSink },
    { name: "DeleteSink", options: { "google.api.http": { delete: "/v2/{sink_name=*/*/sinks/*}", additionalBindings: [{ delete: "/v2/{sink_name=projects/*/sinks/*}" }, { delete: "/v2/{sink_name=organizations/*/sinks/*}" }, { delete: "/v2/{sink_name=folders/*/sinks/*}" }, { delete: "/v2/{sink_name=billingAccounts/*/sinks/*}" }] }, "google.api.method_signature": ["sink_name"] }, I: DeleteSinkRequest, O: Empty },
    { name: "ListExclusions", options: { "google.api.http": { get: "/v2/{parent=*/*}/exclusions", additionalBindings: [{ get: "/v2/{parent=projects/*}/exclusions" }, { get: "/v2/{parent=organizations/*}/exclusions" }, { get: "/v2/{parent=folders/*}/exclusions" }, { get: "/v2/{parent=billingAccounts/*}/exclusions" }] }, "google.api.method_signature": ["parent"] }, I: ListExclusionsRequest, O: ListExclusionsResponse },
    { name: "GetExclusion", options: { "google.api.http": { get: "/v2/{name=*/*/exclusions/*}", additionalBindings: [{ get: "/v2/{name=projects/*/exclusions/*}" }, { get: "/v2/{name=organizations/*/exclusions/*}" }, { get: "/v2/{name=folders/*/exclusions/*}" }, { get: "/v2/{name=billingAccounts/*/exclusions/*}" }] }, "google.api.method_signature": ["name"] }, I: GetExclusionRequest, O: LogExclusion },
    { name: "CreateExclusion", options: { "google.api.http": { post: "/v2/{parent=*/*}/exclusions", body: "exclusion", additionalBindings: [{ post: "/v2/{parent=projects/*}/exclusions", body: "exclusion" }, { post: "/v2/{parent=organizations/*}/exclusions", body: "exclusion" }, { post: "/v2/{parent=folders/*}/exclusions", body: "exclusion" }, { post: "/v2/{parent=billingAccounts/*}/exclusions", body: "exclusion" }] }, "google.api.method_signature": ["parent,exclusion"] }, I: CreateExclusionRequest, O: LogExclusion },
    { name: "UpdateExclusion", options: { "google.api.http": { patch: "/v2/{name=*/*/exclusions/*}", body: "exclusion", additionalBindings: [{ patch: "/v2/{name=projects/*/exclusions/*}", body: "exclusion" }, { patch: "/v2/{name=organizations/*/exclusions/*}", body: "exclusion" }, { patch: "/v2/{name=folders/*/exclusions/*}", body: "exclusion" }, { patch: "/v2/{name=billingAccounts/*/exclusions/*}", body: "exclusion" }] }, "google.api.method_signature": ["name,exclusion,update_mask"] }, I: UpdateExclusionRequest, O: LogExclusion },
    { name: "DeleteExclusion", options: { "google.api.http": { delete: "/v2/{name=*/*/exclusions/*}", additionalBindings: [{ delete: "/v2/{name=projects/*/exclusions/*}" }, { delete: "/v2/{name=organizations/*/exclusions/*}" }, { delete: "/v2/{name=folders/*/exclusions/*}" }, { delete: "/v2/{name=billingAccounts/*/exclusions/*}" }] }, "google.api.method_signature": ["name"] }, I: DeleteExclusionRequest, O: Empty },
    { name: "GetCmekSettings", options: { "google.api.http": { get: "/v2/{name=*/*}/cmekSettings", additionalBindings: [{ get: "/v2/{name=projects/*}/cmekSettings" }, { get: "/v2/{name=organizations/*}/cmekSettings" }, { get: "/v2/{name=folders/*}/cmekSettings" }, { get: "/v2/{name=billingAccounts/*}/cmekSettings" }] } }, I: GetCmekSettingsRequest, O: CmekSettings },
    { name: "UpdateCmekSettings", options: { "google.api.http": { patch: "/v2/{name=*/*}/cmekSettings", body: "cmek_settings", additionalBindings: [{ patch: "/v2/{name=organizations/*}/cmekSettings", body: "cmek_settings" }] } }, I: UpdateCmekSettingsRequest, O: CmekSettings },
    { name: "GetSettings", options: { "google.api.http": { get: "/v2/{name=*/*}/settings", additionalBindings: [{ get: "/v2/{name=projects/*}/settings" }, { get: "/v2/{name=organizations/*}/settings" }, { get: "/v2/{name=folders/*}/settings" }, { get: "/v2/{name=billingAccounts/*}/settings" }] }, "google.api.method_signature": ["name"] }, I: GetSettingsRequest, O: Settings },
    { name: "UpdateSettings", options: { "google.api.http": { patch: "/v2/{name=*/*}/settings", body: "settings", additionalBindings: [{ patch: "/v2/{name=organizations/*}/settings", body: "settings" }, { patch: "/v2/{name=folders/*}/settings", body: "settings" }] }, "google.api.method_signature": ["settings,update_mask"] }, I: UpdateSettingsRequest, O: Settings },
    { name: "CopyLogEntries", options: { "google.api.http": { post: "/v2/entries:copy", body: "*" }, "google.longrunning.operation_info": { responseType: "CopyLogEntriesResponse", metadataType: "CopyLogEntriesMetadata" } }, I: CopyLogEntriesRequest, O: Operation }
], { "google.api.default_host": "logging.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/cloud-platform.read-only,https://www.googleapis.com/auth/logging.admin,https://www.googleapis.com/auth/logging.read" });
