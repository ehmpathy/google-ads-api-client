// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/logging/v2/logging_metrics.proto" (package "google.logging.v2", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { Empty } from "../../protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../protobuf/timestamp";
import { Distribution_BucketOptions } from "../../api/distribution";
import { MetricDescriptor } from "../../api/metric";
/**
 * Describes a logs-based metric. The value of the metric is the number of log
 * entries that match a logs filter in a given time interval.
 *
 * Logs-based metrics can also be used to extract values from logs and create a
 * distribution of the values. The distribution records the statistics of the
 * extracted values along with an optional histogram of the values as specified
 * by the bucket options.
 *
 * @generated from protobuf message google.logging.v2.LogMetric
 */
export interface LogMetric {
    /**
     * Required. The client-assigned metric identifier.
     * Examples: `"error_count"`, `"nginx/requests"`.
     *
     * Metric identifiers are limited to 100 characters and can include only the
     * following characters: `A-Z`, `a-z`, `0-9`, and the special characters
     * `_-.,+!*',()%/`. The forward-slash character (`/`) denotes a hierarchy of
     * name pieces, and it cannot be the first character of the name.
     *
     * This field is the `[METRIC_ID]` part of a metric resource name in the
     * format "projects/[PROJECT_ID]/metrics/[METRIC_ID]". Example: If the
     * resource name of a metric is
     * `"projects/my-project/metrics/nginx%2Frequests"`, this field's value is
     * `"nginx/requests"`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Optional. A description of this metric, which is used in documentation.
     * The maximum length of the description is 8000 characters.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * Required. An [advanced logs
     * filter](https://cloud.google.com/logging/docs/view/advanced_filters) which
     * is used to match log entries. Example:
     *
     *     "resource.type=gae_app AND severity>=ERROR"
     *
     * The maximum length of the filter is 20000 characters.
     *
     * @generated from protobuf field: string filter = 3;
     */
    filter: string;
    /**
     * Optional. If set to True, then this metric is disabled and it does not
     * generate any points.
     *
     * @generated from protobuf field: bool disabled = 12;
     */
    disabled: boolean;
    /**
     * Optional. The metric descriptor associated with the logs-based metric.
     * If unspecified, it uses a default metric descriptor with a DELTA metric
     * kind, INT64 value type, with no labels and a unit of "1". Such a metric
     * counts the number of log entries matching the `filter` expression.
     *
     * The `name`, `type`, and `description` fields in the `metric_descriptor`
     * are output only, and is constructed using the `name` and `description`
     * field in the LogMetric.
     *
     * To create a logs-based metric that records a distribution of log values, a
     * DELTA metric kind with a DISTRIBUTION value type must be used along with
     * a `value_extractor` expression in the LogMetric.
     *
     * Each label in the metric descriptor must have a matching label
     * name as the key and an extractor expression as the value in the
     * `label_extractors` map.
     *
     * The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot
     * be updated once initially configured. New labels can be added in the
     * `metric_descriptor`, but existing labels cannot be modified except for
     * their description.
     *
     * @generated from protobuf field: google.api.MetricDescriptor metric_descriptor = 5;
     */
    metricDescriptor?: MetricDescriptor;
    /**
     * Optional. A `value_extractor` is required when using a distribution
     * logs-based metric to extract the values to record from a log entry.
     * Two functions are supported for value extraction: `EXTRACT(field)` or
     * `REGEXP_EXTRACT(field, regex)`. The argument are:
     *   1. field: The name of the log entry field from which the value is to be
     *      extracted.
     *   2. regex: A regular expression using the Google RE2 syntax
     *      (https://github.com/google/re2/wiki/Syntax) with a single capture
     *      group to extract data from the specified log entry field. The value
     *      of the field is converted to a string before applying the regex.
     *      It is an error to specify a regex that does not include exactly one
     *      capture group.
     *
     * The result of the extraction must be convertible to a double type, as the
     * distribution always records double values. If either the extraction or
     * the conversion to double fails, then those values are not recorded in the
     * distribution.
     *
     * Example: `REGEXP_EXTRACT(jsonPayload.request, ".*quantity=(\d+).*")`
     *
     * @generated from protobuf field: string value_extractor = 6;
     */
    valueExtractor: string;
    /**
     * Optional. A map from a label key string to an extractor expression which is
     * used to extract data from a log entry field and assign as the label value.
     * Each label key specified in the LabelDescriptor must have an associated
     * extractor expression in this map. The syntax of the extractor expression
     * is the same as for the `value_extractor` field.
     *
     * The extracted value is converted to the type defined in the label
     * descriptor. If the either the extraction or the type conversion fails,
     * the label will have a default value. The default value for a string
     * label is an empty string, for an integer label its 0, and for a boolean
     * label its `false`.
     *
     * Note that there are upper bounds on the maximum number of labels and the
     * number of active time series that are allowed in a project.
     *
     * @generated from protobuf field: map<string, string> label_extractors = 7;
     */
    labelExtractors: {
        [key: string]: string;
    };
    /**
     * Optional. The `bucket_options` are required when the logs-based metric is
     * using a DISTRIBUTION value type and it describes the bucket boundaries
     * used to create a histogram of the extracted values.
     *
     * @generated from protobuf field: google.api.Distribution.BucketOptions bucket_options = 8;
     */
    bucketOptions?: Distribution_BucketOptions;
    /**
     * Output only. The creation timestamp of the metric.
     *
     * This field may not be present for older metrics.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 9;
     */
    createTime?: Timestamp;
    /**
     * Output only. The last update timestamp of the metric.
     *
     * This field may not be present for older metrics.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 10;
     */
    updateTime?: Timestamp;
    /**
     * Deprecated. The API version that created or updated this metric.
     * The v2 format is used by default and cannot be changed.
     *
     * @deprecated
     * @generated from protobuf field: google.logging.v2.LogMetric.ApiVersion version = 4 [deprecated = true];
     */
    version: LogMetric_ApiVersion;
}
/**
 * Logging API version.
 *
 * @generated from protobuf enum google.logging.v2.LogMetric.ApiVersion
 */
export enum LogMetric_ApiVersion {
    /**
     * Logging API v2.
     *
     * @generated from protobuf enum value: V2 = 0;
     */
    V2 = 0,
    /**
     * Logging API v1.
     *
     * @generated from protobuf enum value: V1 = 1;
     */
    V1 = 1
}
/**
 * The parameters to ListLogMetrics.
 *
 * @generated from protobuf message google.logging.v2.ListLogMetricsRequest
 */
export interface ListLogMetricsRequest {
    /**
     * Required. The name of the project containing the metrics:
     *
     *     "projects/[PROJECT_ID]"
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Optional. If present, then retrieve the next batch of results from the
     * preceding call to this method. `pageToken` must be the value of
     * `nextPageToken` from the previous response. The values of other method
     * parameters should be identical to those in the previous call.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * Optional. The maximum number of results to return from this request.
     * Non-positive values are ignored. The presence of `nextPageToken` in the
     * response indicates that more results might be available.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
}
/**
 * Result returned from ListLogMetrics.
 *
 * @generated from protobuf message google.logging.v2.ListLogMetricsResponse
 */
export interface ListLogMetricsResponse {
    /**
     * A list of logs-based metrics.
     *
     * @generated from protobuf field: repeated google.logging.v2.LogMetric metrics = 1;
     */
    metrics: LogMetric[];
    /**
     * If there might be more results than appear in this response, then
     * `nextPageToken` is included. To get the next set of results, call this
     * method again using the value of `nextPageToken` as `pageToken`.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * The parameters to GetLogMetric.
 *
 * @generated from protobuf message google.logging.v2.GetLogMetricRequest
 */
export interface GetLogMetricRequest {
    /**
     * Required. The resource name of the desired metric:
     *
     *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
     *
     * @generated from protobuf field: string metric_name = 1;
     */
    metricName: string;
}
/**
 * The parameters to CreateLogMetric.
 *
 * @generated from protobuf message google.logging.v2.CreateLogMetricRequest
 */
export interface CreateLogMetricRequest {
    /**
     * Required. The resource name of the project in which to create the metric:
     *
     *     "projects/[PROJECT_ID]"
     *
     * The new metric must be provided in the request.
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * Required. The new logs-based metric, which must not have an identifier that
     * already exists.
     *
     * @generated from protobuf field: google.logging.v2.LogMetric metric = 2;
     */
    metric?: LogMetric;
}
/**
 * The parameters to UpdateLogMetric.
 *
 * @generated from protobuf message google.logging.v2.UpdateLogMetricRequest
 */
export interface UpdateLogMetricRequest {
    /**
     * Required. The resource name of the metric to update:
     *
     *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
     *
     * The updated metric must be provided in the request and it's
     * `name` field must be the same as `[METRIC_ID]` If the metric
     * does not exist in `[PROJECT_ID]`, then a new metric is created.
     *
     * @generated from protobuf field: string metric_name = 1;
     */
    metricName: string;
    /**
     * Required. The updated metric.
     *
     * @generated from protobuf field: google.logging.v2.LogMetric metric = 2;
     */
    metric?: LogMetric;
}
/**
 * The parameters to DeleteLogMetric.
 *
 * @generated from protobuf message google.logging.v2.DeleteLogMetricRequest
 */
export interface DeleteLogMetricRequest {
    /**
     * Required. The resource name of the metric to delete:
     *
     *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
     *
     * @generated from protobuf field: string metric_name = 1;
     */
    metricName: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class LogMetric$Type extends MessageType<LogMetric> {
    constructor() {
        super("google.logging.v2.LogMetric", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 12, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 5, name: "metric_descriptor", kind: "message", T: () => MetricDescriptor, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 6, name: "value_extractor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 7, name: "label_extractors", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 8, name: "bucket_options", kind: "message", T: () => Distribution_BucketOptions, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 9, name: "create_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 10, name: "update_time", kind: "message", T: () => Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 4, name: "version", kind: "enum", T: () => ["google.logging.v2.LogMetric.ApiVersion", LogMetric_ApiVersion] }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogMetric", pattern: ["projects/{project}/metrics/{metric}"] } });
    }
    create(value?: PartialMessage<LogMetric>): LogMetric {
        const message = { name: "", description: "", filter: "", disabled: false, valueExtractor: "", labelExtractors: {}, version: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogMetric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogMetric): LogMetric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string filter */ 3:
                    message.filter = reader.string();
                    break;
                case /* bool disabled */ 12:
                    message.disabled = reader.bool();
                    break;
                case /* google.api.MetricDescriptor metric_descriptor */ 5:
                    message.metricDescriptor = MetricDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.metricDescriptor);
                    break;
                case /* string value_extractor */ 6:
                    message.valueExtractor = reader.string();
                    break;
                case /* map<string, string> label_extractors */ 7:
                    this.binaryReadMap7(message.labelExtractors, reader, options);
                    break;
                case /* google.api.Distribution.BucketOptions bucket_options */ 8:
                    message.bucketOptions = Distribution_BucketOptions.internalBinaryRead(reader, reader.uint32(), options, message.bucketOptions);
                    break;
                case /* google.protobuf.Timestamp create_time */ 9:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 10:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* google.logging.v2.LogMetric.ApiVersion version = 4 [deprecated = true];*/ 4:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: LogMetric["labelExtractors"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LogMetric["labelExtractors"] | undefined, val: LogMetric["labelExtractors"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.logging.v2.LogMetric.label_extractors");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: LogMetric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string filter = 3; */
        if (message.filter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.filter);
        /* bool disabled = 12; */
        if (message.disabled !== false)
            writer.tag(12, WireType.Varint).bool(message.disabled);
        /* google.api.MetricDescriptor metric_descriptor = 5; */
        if (message.metricDescriptor)
            MetricDescriptor.internalBinaryWrite(message.metricDescriptor, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string value_extractor = 6; */
        if (message.valueExtractor !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.valueExtractor);
        /* map<string, string> label_extractors = 7; */
        for (let k of Object.keys(message.labelExtractors))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labelExtractors[k]).join();
        /* google.api.Distribution.BucketOptions bucket_options = 8; */
        if (message.bucketOptions)
            Distribution_BucketOptions.internalBinaryWrite(message.bucketOptions, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 9; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 10; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.logging.v2.LogMetric.ApiVersion version = 4 [deprecated = true]; */
        if (message.version !== 0)
            writer.tag(4, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogMetric
 */
export const LogMetric = new LogMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLogMetricsRequest$Type extends MessageType<ListLogMetricsRequest> {
    constructor() {
        super("google.logging.v2.ListLogMetricsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "cloudresourcemanager.googleapis.com/Project" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value?: PartialMessage<ListLogMetricsRequest>): ListLogMetricsRequest {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListLogMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListLogMetricsRequest): ListLogMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListLogMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListLogMetricsRequest
 */
export const ListLogMetricsRequest = new ListLogMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLogMetricsResponse$Type extends MessageType<ListLogMetricsResponse> {
    constructor() {
        super("google.logging.v2.ListLogMetricsResponse", [
            { no: 1, name: "metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogMetric },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListLogMetricsResponse>): ListLogMetricsResponse {
        const message = { metrics: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListLogMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListLogMetricsResponse): ListLogMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogMetric metrics */ 1:
                    message.metrics.push(LogMetric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListLogMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.logging.v2.LogMetric metrics = 1; */
        for (let i = 0; i < message.metrics.length; i++)
            LogMetric.internalBinaryWrite(message.metrics[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListLogMetricsResponse
 */
export const ListLogMetricsResponse = new ListLogMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLogMetricRequest$Type extends MessageType<GetLogMetricRequest> {
    constructor() {
        super("google.logging.v2.GetLogMetricRequest", [
            { no: 1, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogMetric" } } }
        ]);
    }
    create(value?: PartialMessage<GetLogMetricRequest>): GetLogMetricRequest {
        const message = { metricName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLogMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLogMetricRequest): GetLogMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string metric_name */ 1:
                    message.metricName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLogMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string metric_name = 1; */
        if (message.metricName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.metricName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetLogMetricRequest
 */
export const GetLogMetricRequest = new GetLogMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateLogMetricRequest$Type extends MessageType<CreateLogMetricRequest> {
    constructor() {
        super("google.logging.v2.CreateLogMetricRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogMetric" } } },
            { no: 2, name: "metric", kind: "message", T: () => LogMetric, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<CreateLogMetricRequest>): CreateLogMetricRequest {
        const message = { parent: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateLogMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateLogMetricRequest): CreateLogMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* google.logging.v2.LogMetric metric */ 2:
                    message.metric = LogMetric.internalBinaryRead(reader, reader.uint32(), options, message.metric);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateLogMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* google.logging.v2.LogMetric metric = 2; */
        if (message.metric)
            LogMetric.internalBinaryWrite(message.metric, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateLogMetricRequest
 */
export const CreateLogMetricRequest = new CreateLogMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateLogMetricRequest$Type extends MessageType<UpdateLogMetricRequest> {
    constructor() {
        super("google.logging.v2.UpdateLogMetricRequest", [
            { no: 1, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogMetric" } } },
            { no: 2, name: "metric", kind: "message", T: () => LogMetric, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<UpdateLogMetricRequest>): UpdateLogMetricRequest {
        const message = { metricName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateLogMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateLogMetricRequest): UpdateLogMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string metric_name */ 1:
                    message.metricName = reader.string();
                    break;
                case /* google.logging.v2.LogMetric metric */ 2:
                    message.metric = LogMetric.internalBinaryRead(reader, reader.uint32(), options, message.metric);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateLogMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string metric_name = 1; */
        if (message.metricName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.metricName);
        /* google.logging.v2.LogMetric metric = 2; */
        if (message.metric)
            LogMetric.internalBinaryWrite(message.metric, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateLogMetricRequest
 */
export const UpdateLogMetricRequest = new UpdateLogMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteLogMetricRequest$Type extends MessageType<DeleteLogMetricRequest> {
    constructor() {
        super("google.logging.v2.DeleteLogMetricRequest", [
            { no: 1, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogMetric" } } }
        ]);
    }
    create(value?: PartialMessage<DeleteLogMetricRequest>): DeleteLogMetricRequest {
        const message = { metricName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteLogMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteLogMetricRequest): DeleteLogMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string metric_name */ 1:
                    message.metricName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteLogMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string metric_name = 1; */
        if (message.metricName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.metricName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteLogMetricRequest
 */
export const DeleteLogMetricRequest = new DeleteLogMetricRequest$Type();
/**
 * @generated ServiceType for protobuf service google.logging.v2.MetricsServiceV2
 */
export const MetricsServiceV2 = new ServiceType("google.logging.v2.MetricsServiceV2", [
    { name: "ListLogMetrics", options: { "google.api.http": { get: "/v2/{parent=projects/*}/metrics" }, "google.api.method_signature": ["parent"] }, I: ListLogMetricsRequest, O: ListLogMetricsResponse },
    { name: "GetLogMetric", options: { "google.api.http": { get: "/v2/{metric_name=projects/*/metrics/*}" }, "google.api.method_signature": ["metric_name"] }, I: GetLogMetricRequest, O: LogMetric },
    { name: "CreateLogMetric", options: { "google.api.http": { post: "/v2/{parent=projects/*}/metrics", body: "metric" }, "google.api.method_signature": ["parent,metric"] }, I: CreateLogMetricRequest, O: LogMetric },
    { name: "UpdateLogMetric", options: { "google.api.http": { put: "/v2/{metric_name=projects/*/metrics/*}", body: "metric" }, "google.api.method_signature": ["metric_name,metric"] }, I: UpdateLogMetricRequest, O: LogMetric },
    { name: "DeleteLogMetric", options: { "google.api.http": { delete: "/v2/{metric_name=projects/*/metrics/*}" }, "google.api.method_signature": ["metric_name"] }, I: DeleteLogMetricRequest, O: Empty }
], { "google.api.default_host": "logging.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/cloud-platform.read-only,https://www.googleapis.com/auth/logging.admin,https://www.googleapis.com/auth/logging.read,https://www.googleapis.com/auth/logging.write" });
